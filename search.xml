<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>创新特征</title>
    <url>/2020/11/08/%E5%B7%A5%E4%BD%9C%E6%80%9D%E7%BB%B4/%E5%88%9B%E6%96%B0%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<p>创新有两种形式：</p>
<ol>
<li>连续式创新：沿着同一条S曲线进步；</li>
<li>非连续式创新：转换到新的S曲线；</li>
</ol>
<h2 id="一、连续性创新"><a href="#一、连续性创新" class="headerlink" title="一、连续性创新"></a>一、连续性创新</h2><img src="https://gitee.com/hfood/img-cloud/raw/master/202012/image-20201108230818752.png" alt="image-20201108230818752" style="zoom:20%;" />

<p>技术连续性创新的特征</p>
<blockquote>
<p>A. 沿着技术曲线持续改善原有的产品性能</p>
<p>B. 定位于主流市场的主流消费者</p>
<p>C. Better</p>
</blockquote>
<p>案例：</p>
<blockquote>
<ul>
<li>英特尔不断推出性能更强的微处理器</li>
<li>微软Windows操作系统的不断升级</li>
<li>苹果iPhone的升级换代。</li>
</ul>
</blockquote>
<h2 id="二、非连续创新"><a href="#二、非连续创新" class="headerlink" title="二、非连续创新"></a>二、非连续创新</h2><p>新旧技术之间不是继承关系，而是竞争关系，其交替过程就是技术的非连续性断层期。</p>
<img src="https://gitee.com/hfood/img-cloud/raw/master/202012/image-20201108231434104.png" alt="image-20201108231434104" style="zoom:20%;" />

<h2 id="三、企业思维与市场思维"><a href="#三、企业思维与市场思维" class="headerlink" title="三、企业思维与市场思维"></a>三、企业思维与市场思维</h2><ul>
<li><p>企业的基础假设是连续性，其焦点在于运营和管理; </p>
</li>
<li><p>市场的基础假设是不连续性，其重点则是创造与破坏。</p>
</li>
</ul>
<p>市场速度超过个体公司速度的原因：市场是破坏性思维，公司是保护性思维</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下使用iTerm2让SSH记录远程服务器账号和密码</title>
    <url>/2018/10/05/Mac&amp;PC/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8iTerm2%E8%AE%A9SSH%E8%AE%B0%E5%BD%95%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%A6%E5%8F%B7%E5%92%8C%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>iTerm2和Macbook自带的Terminal差不多，但是功能更强大，强烈推荐使用。</p>
<p> 下面说下，如何让iTerm2记住远程服务器SSH登录账号和密码。</p>
<p> 第一步：打开Finder，在菜单栏找到『前往』→ 『前往文件夹…』，输入：~/.ssh/ 然后回车</p>
<p> 第二步：新建一个文件，命名为example吧，里面写入内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set user root</span><br><span class="line">set host 114.114.114.114</span><br><span class="line">set password ********</span><br><span class="line"> </span><br><span class="line">spawn ssh $user@$host</span><br><span class="line">expect &quot;*assword:*&quot;</span><br><span class="line">send &quot;$password\r&quot;</span><br><span class="line">interact</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure>

<p> 第三步：到官方<a href="http://www.iterm2.com/">http://www.iterm2.com/</a>下载并打开iTerm2，菜单栏找到『Profiles』→『Open Profiles…』,打开面板上，点击右下角『Edit  Profiles…』</p>
<p> 第四步：在打开面板，左边应该是选中默认default，右边找到Command，默认应该是Login shell，选中Command，里面输入：expect ~/.ssh/example</p>
<p> 第五步，下次打开iTerm2，是不是默认就登录上服务器了？极大提升效率。<br> 按照以上方法，可以配置profile,对应很多个服务器。这样每次启动可以选择默认操作，然后再profile下拉选中中执行对应的VPS profile，则可以实现自动登录！</p>
<blockquote>
<p>Tips:  如果重新添加相同ip的实例,需要在~/.ssh/known_hosts 里删除该ip的ssh-rsa码</p>
</blockquote>
]]></content>
      <categories>
        <category>Mac&amp;PC</category>
      </categories>
      <tags>
        <tag>电脑技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>iTerm终端设置代理</title>
    <url>/2018/10/10/Mac&amp;PC/iTerm%20%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>某些站点必须爬墙才能访问，但在mac上设置的全局代理，对终端又不起作用，终端需要单独设置代理。<br>在终端中执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export ALL_PROXY=socks5://127.0.0.1:1086/</span><br></pre></td></tr></table></figure>

<p>如果是http的代理:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:1087/</span><br><span class="line">export https_proxy=http://127.0.0.1:1087/</span><br></pre></td></tr></table></figure>

<p>如果需要开机自动设置，把上面的代码加到~/.bash_profile里</p>
<p><code>source  ~/.bash_profile</code> 使文件生效</p>
<p>测试当前终端标签/窗口是否走代理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl ip.gs</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mac&amp;PC</category>
      </categories>
      <tags>
        <tag>电脑技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>58同城面试总结</title>
    <url>/2017/11/15/IT%E6%8A%80%E6%9C%AF/58%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>前言:面试中问了一些基础的问题,非常能反映基本功是否扎实,很佩服58的工程师!</p>
<p>记录两个印象比较深的两道CSS面试题,面试官对效果实现都是希望多种方法实现,平时的积累需要灵活应用:</p>
<a id="more"></a>

<h2 id="1-左固定一个宽度div-右边div宽度自适应-如何实现"><a href="#1-左固定一个宽度div-右边div宽度自适应-如何实现" class="headerlink" title="1.左固定一个宽度div,右边div宽度自适应,如何实现?"></a>1.左固定一个宽度div,右边div宽度自适应,如何实现?</h2><p>听到这个问题我还挺开心的,因为前两天还写过,当时也是试了几次才写出来,只是没有在意和及时总结。现场回答的非常不好，比较惭愧,回到家第一件事就把这个题模拟了一下：</p>
<ul>
<li>利用绝对定位和padding-left实现<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  *&#123;</span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</span></span><br><span class="line">    z-index: 10;</span><br><span class="line"><span class="css">    <span class="selector-tag">min-height</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>:<span class="selector-id">#f00</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</span></span><br><span class="line">    padding-left: 300px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line"><span class="css">    <span class="selector-tag">min-height</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>:<span class="selector-id">#ff0</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>我属于左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>我属于右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-写一个弹窗-怎么居中弹窗里的元素"><a href="#2-写一个弹窗-怎么居中弹窗里的元素" class="headerlink" title="2. 写一个弹窗,怎么居中弹窗里的元素?"></a>2. 写一个弹窗,怎么居中弹窗里的元素?</h2><p>这个问题平时写的比较多,但疏于整理现场只回答了一个方法,面试官希望有更多方法,现场另举了弹性布局,回来后整理了下,主要有以下四种方法:</p>
<h3 id="1-居中浮动元素"><a href="#1-居中浮动元素" class="headerlink" title="1.居中浮动元素:"></a>1.居中浮动元素:</h3><ul>
<li>1.1 利用margin负值<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span> &#123; </span><br><span class="line">  <span class="attribute">width</span>:<span class="number">600px</span> ; </span><br><span class="line">  <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: -<span class="number">150px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">position</span>:absolute;<span class="comment">/*父元素relative*/</span></span><br><span class="line">  <span class="attribute">background-color</span>:pink;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>1.2 利用translate<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>1.3 利用弹性布局`<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>1.4 利用margin特性<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-内容居中"><a href="#2-内容居中" class="headerlink" title="2.内容居中:"></a>2.内容居中:</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>:pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
或者:<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:table-cell;<span class="comment">/*对象作为表格单元*/</span></span><br><span class="line">  <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  <span class="attribute">background-color</span>:pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Backbone学习笔记</title>
    <url>/2017/12/17/IT%E6%8A%80%E6%9C%AF/Backbone-study-note/</url>
    <content><![CDATA[<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>1.简单的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Man = Backbone.Model.extend(&#123;</span><br><span class="line">      initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;你好,你创建了我!&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">var</span> man = <span class="keyword">new</span> Man;</span><br></pre></td></tr></table></figure>
<p>2.对象赋值的两种方法:直接定义默认值和赋值定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Man = Backbone.Model.extend(&#123;</span><br><span class="line">       initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&#x27;你好,你创建了我!&#x27;</span>);</span><br><span class="line">       &#125;,</span><br><span class="line">       defaults: &#123;</span><br><span class="line">           name:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">           age: <span class="string">&#x27;38&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">     <span class="keyword">var</span> man = <span class="keyword">new</span> Man;</span><br><span class="line">     man.set&#123;<span class="attr">name</span>:<span class="string">&quot;李四&quot;</span>&#125;;  <span class="comment">//赋值定义</span></span><br><span class="line">     <span class="built_in">console</span>.log(man.get(<span class="string">&quot;name&quot;</span>))</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>3.监听属性方法:bind</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Man = Backbone.Model.extend(&#123;</span><br><span class="line">        initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;你好,你创建了我!&#x27;</span>);</span><br><span class="line">            <span class="comment">//初始化时绑定监听</span></span><br><span class="line">            <span class="built_in">this</span>.bind(<span class="string">&quot;change:name&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;你改变了name属性为：&quot;</span> + <span class="built_in">this</span>.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        defaults: &#123;</span><br><span class="line">            name:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">            age: <span class="string">&#x27;38&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        aboutMe: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;我叫&#x27;</span> + <span class="built_in">this</span>.get(<span class="string">&#x27;name&#x27;</span>) + <span class="string">&#x27;,今年&#x27;</span> + <span class="built_in">this</span>.get(<span class="string">&#x27;age&#x27;</span>) + <span class="string">&#x27;岁&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> man = <span class="keyword">new</span> Man;</span><br><span class="line">    man.aboutMe();</span><br><span class="line">    man.set(&#123;<span class="attr">name</span>:<span class="string">&#x27;小明&#x27;</span>&#125;);  <span class="comment">//触发绑定的change事件，输出。</span></span><br><span class="line">    man.aboutMe();</span><br></pre></td></tr></table></figure>
<p>4.为对象添加验证规则,以及错误提示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  Man = Backbone.Model.extend(&#123;</span><br><span class="line">      initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;你好,你创建了我!&#x27;</span>);</span><br><span class="line">          <span class="comment">//初始化时绑定监听</span></span><br><span class="line">          <span class="built_in">this</span>.bind(<span class="string">&quot;change:name&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="keyword">var</span> name = <span class="built_in">this</span>.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">&quot;你改变了name属性为：&quot;</span> + name);</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="built_in">this</span>.bind(<span class="string">&quot;invalid&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">model, error</span>)</span>&#123; <span class="comment">// 当model在客户端 validation（验证）失败时触发。</span></span><br><span class="line">              <span class="built_in">console</span>.log(error);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      defaults: &#123;</span><br><span class="line">          name:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">          age: <span class="string">&#x27;38&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      validate:<span class="function"><span class="keyword">function</span>(<span class="params">attributes, options</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(attributes.name == <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;name不能为空！&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      aboutMe: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;我叫&#x27;</span> + <span class="built_in">this</span>.get(<span class="string">&#x27;name&#x27;</span>) + <span class="string">&#x27;,今年&#x27;</span> + <span class="built_in">this</span>.get(<span class="string">&#x27;age&#x27;</span>) + <span class="string">&#x27;岁&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> man = <span class="keyword">new</span> Man;</span><br><span class="line"><span class="comment">//  这种方式添加错误处理也行</span></span><br><span class="line"><span class="comment">/*  man.on(&#x27;invalid&#x27;, function(model, error)&#123;</span></span><br><span class="line"><span class="comment">      alert(error);</span></span><br><span class="line"><span class="comment">    &#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  man.set(&#123;<span class="attr">name</span>:<span class="string">&#x27;&#x27;</span>&#125;);</span><br><span class="line">  man.set(&#123;<span class="attr">name</span>:<span class="string">&#x27;&#x27;</span>&#125;, &#123;<span class="string">&#x27;validate&#x27;</span>:<span class="literal">true</span>&#125;);  <span class="comment">//手动触发验证, set时会触发</span></span><br><span class="line">  man.save(); <span class="comment">//save时触发验证。根据验证规则，弹出错误提示。</span></span><br></pre></td></tr></table></figure>
<p>5.对象的获取和保存</p>
<ul>
<li>save() 会发送POST到模型对应的url，数据格式为json{“name”:”小明”,”age”:38},接着用fetch([options])从服务器端获取数据</li>
<li>fetch({url:’/man/‘}) 发送get请求到/man/这个url中，服务器返回的结果样式是对应的json格式数据<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">man1.fetch(&#123;<span class="attr">url</span>:<span class="string">&#x27;/man/&#x27;</span>,</span><br><span class="line">		success:<span class="function"><span class="keyword">function</span>(<span class="params">model,response</span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">&#x27;get from server success&#x27;</span>);<span class="comment">//model为获取到的数据</span></span><br><span class="line">    	<span class="built_in">console</span>.log(model.get(<span class="string">&#x27;name&#x27;</span>));</span><br><span class="line">    &#125;,</span><br><span class="line">		error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//当返回格式不正确或者是非json数据时，会执行此方法</span></span><br><span class="line">    alert(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> Man = Backbone.Model.extend(&#123;</span><br><span class="line">    url:<span class="string">&#x27;/man/&#x27;</span>,</span><br><span class="line">    initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;你好,你创建了我!&#x27;</span>);</span><br><span class="line">        <span class="comment">//初始化时绑定监听</span></span><br><span class="line">        <span class="built_in">this</span>.bind(<span class="string">&quot;change:name&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> name = <span class="built_in">this</span>.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;你改变了name属性为：&quot;</span> + name);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.bind(<span class="string">&quot;invalid&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">model,error</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>,error);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    defaults: &#123;</span><br><span class="line">        name:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">        age: <span class="string">&#x27;38&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    validate:<span class="function"><span class="keyword">function</span>(<span class="params">attributes</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(attributes.name == <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;name不能为空！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    aboutMe: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;我叫&#x27;</span> + <span class="built_in">this</span>.get(<span class="string">&#x27;name&#x27;</span>) + <span class="string">&#x27;,今年&#x27;</span> + <span class="built_in">this</span>.get(<span class="string">&#x27;age&#x27;</span>) + <span class="string">&#x27;岁&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Man;;</span><br><span class="line">man.set(&#123;<span class="attr">name</span>:<span class="string">&#x27;小明&#x27;</span>&#125;);</span><br><span class="line">man.save();  <span class="comment">//会发送POST到模型对应的url，数据格式为json&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:38&#125;</span></span><br><span class="line"><span class="comment">//然后接着就是从服务器端获取数据使用方法fetch([options])</span></span><br><span class="line"><span class="keyword">var</span> man1 = <span class="keyword">new</span> Man;</span><br><span class="line"><span class="comment">//第一种情况，如果直接使用fetch方法，那么他会发送get请求到你model的url中，</span></span><br><span class="line"><span class="comment">//你在服务器端可以通过判断是get还是post来进行对应的操作。</span></span><br><span class="line">man1.fetch();</span><br><span class="line"><span class="comment">//第二种情况，在fetch中加入参数，如下：</span></span><br><span class="line">man1.fetch(&#123;<span class="attr">url</span>:<span class="string">&#x27;/man/&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">//这样，就会发送get请求到/man/这个url中，</span></span><br><span class="line"><span class="comment">//服务器返回的结果样式应该是对应的json格式数据，同save时POST过去的格式。</span></span><br><span class="line"><span class="comment">//不过接受服务器端返回的数据方法是这样的：</span></span><br><span class="line">man1.fetch(&#123;<span class="attr">url</span>:<span class="string">&#x27;/man/&#x27;</span>,<span class="attr">success</span>:<span class="function"><span class="keyword">function</span>(<span class="params">model,response</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;get from server success&#x27;</span>);</span><br><span class="line">    <span class="comment">//model为获取到的数据</span></span><br><span class="line">    alert(model.get(<span class="string">&#x27;name&#x27;</span>));</span><br><span class="line">    &#125;,<span class="attr">error</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//当返回格式不正确或者是非json数据时，会执行此方法</span></span><br><span class="line">    alert(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><ol>
<li>示例<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Book = Backbone.Model.extend(&#123;</span><br><span class="line">  defaults : &#123; </span><br><span class="line">    title:<span class="string">&#x27;默认标题&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;你好,你创建了我!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  BookShelf = Backbone.Collection.extend(&#123;</span><br><span class="line">      model : Book</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> book1 = <span class="keyword">new</span> Book(&#123;<span class="attr">title</span> : <span class="string">&#x27;book1&#x27;</span>&#125;);</span><br><span class="line">  <span class="keyword">var</span> book2 = <span class="keyword">new</span> Book(&#123;<span class="attr">title</span> : <span class="string">&#x27;book2&#x27;</span>&#125;);</span><br><span class="line">  <span class="keyword">var</span> book3 = <span class="keyword">new</span> Book(&#123;<span class="attr">title</span> : <span class="string">&#x27;book3&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//var bookShelf = new BookShelf([book1, book2, book3]); </span></span><br><span class="line">  <span class="comment">//实例化集合,参数为数组,或者使用add</span></span><br><span class="line">  <span class="keyword">var</span> bookShelf = <span class="keyword">new</span> BookShelf;</span><br><span class="line">  bookShelf.add(book1);</span><br><span class="line">  bookShelf.add(book2);</span><br><span class="line">  bookShelf.add(book3);</span><br><span class="line">  bookShelf.remove(book3);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//基于underscore这个js库，还可以使用each的方法获取collection中的数据</span></span><br><span class="line">  bookShelf.each(<span class="function"><span class="keyword">function</span>(<span class="params">book</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(book.get(<span class="string">&#x27;title&#x27;</span>));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
<li>使用fetch从服务器端获取数据,使用reset渲染<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showAllBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  bookShelf.each(<span class="function"><span class="keyword">function</span>(<span class="params">book</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//将book数据渲染到页面。</span></span><br><span class="line">    <span class="built_in">document</span>.writeln(book.get(<span class="string">&#x27;title&#x27;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  bookShelf.bind(<span class="string">&#x27;reset&#x27;</span>, showAllBooks);</span><br><span class="line">  bookShelf.url = <span class="string">&#x27;/books/&#x27;</span>; <span class="comment">//注意这里</span></span><br><span class="line">  bookShelf.fetch(&#123;</span><br><span class="line">    reset: <span class="literal">true</span>, </span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">collection,response, options</span>)</span>&#123;</span><br><span class="line">        collection.each(<span class="function"><span class="keyword">function</span>(<span class="params">book</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(book.get(<span class="string">&#x27;title&#x27;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params">collection, response, options</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
<li>创建collection推送到server端<br>创建数据，其实就是调用collection的create方法，POST对应的Model对象（json数据）到配置好的url上。之后会返回一个model的实例，如下面代码中的onebook。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> NewBooks = Backbone.Collection.extend(&#123;</span><br><span class="line">  model: Book,</span><br><span class="line">  url: <span class="string">&#x27;/books/&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> books = <span class="keyword">new</span> NewBooks;</span><br><span class="line"><span class="keyword">var</span> onebook = books.create(&#123;</span><br><span class="line">title: <span class="string">&quot;I&#x27;m coming&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>Backbone</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS学习记录</title>
    <url>/2016/10/12/IT%E6%8A%80%E6%9C%AF/CSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="1-上外边距的溢出"><a href="#1-上外边距的溢出" class="headerlink" title="1.上外边距的溢出"></a>1.上外边距的溢出</h4><p>在某些特殊条件下，在为子元素设置上外边距时有可能会作用在父元素上<br>    特殊条件：（同时满足）<br>        1.父元素不能有上边框；<br>        2.为第一个子元素设置上外边距时<br>    解决方案：<br>        1、 为父元素增加上边框：会影响父元素的高度<br>        2、 使用父元素的上内边距来取代子元素的上外边距：会影响父元素的高度<br>        3、 在子元素上增加一个空的<table>元素即可</p>
<a id="more"></a>
<h4 id="2-CSS-Sprites雪碧图"><a href="#2-CSS-Sprites雪碧图" class="headerlink" title="2.CSS Sprites雪碧图"></a>2.CSS Sprites雪碧图</h4><p>将若干副不经常变换的图片封装到一幅大图中<br>配合背景图片以及背景图片定位将想看的图片显示出来<br>1） 在页面中创建一个与要显示区域大小一样的元素<br>2） 将雪碧图作为元素的背景图<br>3） 改变图片在元素中的位置（左上移动）</p>
<h4 id="3-背景简写属性——background"><a href="#3-背景简写属性——background" class="headerlink" title="3.背景简写属性——background"></a>3.背景简写属性——background</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background：color url( ) repeat attachment position;</span><br><span class="line">background: red;</span><br><span class="line">background: url(img&#x2F;mm.png) no-repeat 95% center;</span><br></pre></td></tr></table></figure>

<h4 id="4-字体属性简写方式"><a href="#4-字体属性简写方式" class="headerlink" title="4.字体属性简写方式"></a>4.字体属性简写方式</h4><p>属性：font<br>取值：style variant(小型大写字母) weight size family<br>注意：一定要将Family写出来，否则无效</p>
<h4 id="5-伪类选择器"><a href="#5-伪类选择器" class="headerlink" title="5.伪类选择器"></a>5.伪类选择器</h4><h5 id="1-目标伪类-target"><a href="#1-目标伪类-target" class="headerlink" title="1)目标伪类:  :target"></a>1)目标伪类:  :target</h5><p>对页面中的某个target元素指定样式，该样式只对在用户点击了页面中的超链接并且跳转到target元素后起作用</p>
<h5 id="2-before或-before"><a href="#2-before或-before" class="headerlink" title="2)  :before或::before"></a>2)  :before或::before</h5><p>作用:匹配到某元素的内容区域之前</p>
<ul>
<li>特点:外边距溢出问题<h5 id="3-after或-after"><a href="#3-after或-after" class="headerlink" title="3)  :after或::after"></a>3)  :after或::after</h5>作用:匹配到某元素内容区域之后</li>
<li>解决浮动元素父元素的高度问题 :after</li>
<li>特点：1.在父元素的内容区域之后<pre><code>  2.增加一个“空”元素
  3.必须是块级元素
  4.必须设置clear:both</code></pre>
</li>
</ul>
<h4 id="6-图片和行内快的vertical-align属性"><a href="#6-图片和行内快的vertical-align属性" class="headerlink" title="6.图片和行内快的vertical-align属性"></a>6.图片和行内快的vertical-align属性</h4><pre><code>控制图片或行内块元素两边的文本，相对于他们的对齐方式
取值：
1.    top
2.    middle
3.    bottom
4.    baseline 基线对齐
    a)    行内块：基线是在最后一行文本的底部
    b)    图片：基线是在图片底部向下3px(不一定)位置处</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">img&#123;vertical-align:bottom;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-绝对定位对元素的影响"><a href="#7-绝对定位对元素的影响" class="headerlink" title="7. 绝对定位对元素的影响"></a>7. 绝对定位对元素的影响</h4><ul>
<li><ol>
<li>脱离文档流，允许压在其他元素的上方<ol start="2">
<li>绝对定位的元素会变成块级元素<br> .    margin可以正常使用，但是margin的左右auto值会失效<br> .    绝对定位的元素，将left，right，bottom，top四个值都设置为0 的情况下，margin:auto会让整个元素变得绝对居中</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="8-弹性布局"><a href="#8-弹性布局" class="headerlink" title="8.弹性布局"></a>8.弹性布局</h4><h5 id="8-1-属性-display"><a href="#8-1-属性-display" class="headerlink" title="8.1 属性:display"></a>8.1 属性:display</h5><p>取值:</p>
<blockquote>
<pre><code>1、flex：将块级元素变为弹性布局的容器
2、inline-flex：将行内元素变为弹性布局的容器</code></pre>
</blockquote>
<p>注意：</p>
<blockquote>
<pre><code>  1、 容器中的项目们会自动变为块级元素，允许修改尺寸
  2、 项目们的float、clear、vertical-align、全部失效
  3、 容器的text-align属性也会失效</code></pre>
</blockquote>
<h5 id="8-2-属性flex-wrap"><a href="#8-2-属性flex-wrap" class="headerlink" title="8.2 属性flex-wrap"></a>8.2 属性flex-wrap</h5><p>取值:1.nowrap  2.wrap  3.wrap-reverse</p>
<h5 id="8-3-justify-content"><a href="#8-3-justify-content" class="headerlink" title="8.3 justify-content"></a>8.3 justify-content</h5><p>作用：指定项目在主轴上的对齐方式<br>取值：</p>
<ul>
<li>1、 flex-start在轴的起点对齐</li>
<li>2、 flex-end  在轴的终点对齐</li>
<li>3、 center  居中对齐</li>
<li>4、 <strong>space-between 两端对齐，项目之间的间隔都是相等的</strong></li>
<li>5、 space-around  每个项目两边的空白间距是相等的</li>
</ul>
<h4 id="9-转换-transform"><a href="#9-转换-transform" class="headerlink" title="9.转换 transform"></a>9.转换 transform</h4><p>取值:</p>
<blockquote>
<pre><code>1.位移:translate(x)/translate(x,y)/translateX(x)/translateY(y)
2.缩放:scale(value)/scale（x，y）/scaleX（x）/scaleY（y）
3.旋转:rotate(ndeg)
4.倾斜:skewX(ndeg)/skewY(ndeg)/skew(x)/skew(x,y)</code></pre>
</blockquote>
<p>9.1 转换原点</p>
<blockquote>
<pre><code>属性:transform-origin
取值:1.    两个值：表示原点在x轴和y轴的位置
     2.    三个值：表示原点在x轴、y轴和z轴的位置
    可以取数值/百分比/关键字，多个值用空格隔开</code></pre>
</blockquote>
<p>9.2 3D转换(模拟人眼睛到3D转换物体的距离，取值越大，表示离物体越远，表示离物体越近)</p>
<blockquote>
<pre><code>属性:perspective
取值:rotateX(xdeg)  以x轴为中心轴旋转
     rotateY(ydeg)    以y轴为中心轴旋转
     rotateZ(zdeg)    以z轴为中心轴旋转
     rotate3D(x,y,z,ndeg)
        x,y,z 取值大于0的话，则该轴参与旋转
        x,y,z 取值为0的话，则该轴不参与旋转
        rotate3D(1,0,0,45deg)==&gt;rotateX(45deg)</code></pre>
</blockquote>
<h4 id="10-过渡"><a href="#10-过渡" class="headerlink" title="10.过渡"></a>10.过渡</h4><ul>
<li>属性:transition</li>
<li>取值:property duration timing-function delay;<h4 id="11-动画"><a href="#11-动画" class="headerlink" title="11.动画"></a>11.动画</h4>样式表中,通过@keyframes规则来声明动画<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@keyframes 动画名称name&#123;</span><br><span class="line"> 	0%&#123;</span><br><span class="line"> 		&#x2F;*动画开始时，元素的样式*&#x2F;</span><br><span class="line"> 		属性：值;</span><br><span class="line"> 		属性: 值;</span><br><span class="line"> &#125;</span><br><span class="line"> 50%&#123;</span><br><span class="line"> 	&#x2F;*动画执行到一半时，元素的样式*&#x2F;</span><br><span class="line"> &#125;</span><br><span class="line"> 100%&#123;</span><br><span class="line"> 	&#x2F;*动画结束时，元素的样式*&#x2F;</span><br><span class="line"> 	属性: 值;</span><br><span class="line"> 	属性: 值;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="11-1动画声明的浏览器兼容性"><a href="#11-1动画声明的浏览器兼容性" class="headerlink" title="11.1动画声明的浏览器兼容性"></a>11.1动画声明的浏览器兼容性</h5>  Firefox：@-moz-keyframes{  }<br>  Chrome &amp; Safari: @-webkit-keyframes{   }<br>  Oprea: @-o-keyframes{  }</li>
</ul>
<h5 id="11-2调用动画简写属性-animation"><a href="#11-2调用动画简写属性-animation" class="headerlink" title="11.2调用动画简写属性:animation"></a>11.2调用动画简写属性:animation</h5><p>取值:name duration timing-function delay iteration-count(播放次数) direction</p>
<h5 id="11-3动画填充模式-animation-fill-mode"><a href="#11-3动画填充模式-animation-fill-mode" class="headerlink" title="11.3动画填充模式:animation-fill-mode"></a>11.3动画填充模式:animation-fill-mode</h5><ul>
<li>取值:</li>
</ul>
<blockquote>
<pre><code>  1.none   默认值，无任何效果
  2.forwards   档动画播放完成后，元素将保持在最后一个帧的状态上
  3.backwards  动画播放前，在延迟时间内，动画将保持在第一帧的状态上
  4.both 动画播放前后，分别应用在第一帧和最后一个帧上</code></pre>
</blockquote>
<h5 id="11-4动画播放状态animation-play-state"><a href="#11-4动画播放状态animation-play-state" class="headerlink" title="11.4动画播放状态animation-play-state"></a>11.4动画播放状态animation-play-state</h5><ul>
<li><p>取值</p>
<ol>
<li>paused：动画暂停<ol start="2">
<li>   running：动画播放</li>
</ol>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS样式----文字长度溢出显示省略号</title>
    <url>/2016/11/02/IT%E6%8A%80%E6%9C%AF/CSS%E6%A0%B7%E5%BC%8F---%E6%96%87%E5%AD%97%E9%95%BF%E5%BA%A6%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7/</url>
    <content><![CDATA[<h4 id="text-overflow省略号样式语法结构"><a href="#text-overflow省略号样式语法结构" class="headerlink" title="text-overflow省略号样式语法结构"></a>text-overflow省略号样式语法结构</h4><ul>
<li><p>text-overflow语法：<br><code>text-overflow : clip | ellipsis </code></p>
</li>
<li><p>text-overflow参数值和解释：<br>clip : 　不显示省略标记（…），而是简单的裁切<br>ellipsis : 　当对象内文本溢出时显示省略标记（…）</p>
</li>
<li><p>text-overflow应用说明：<br>CSS text-overflow设置或检索是否使用一个省略号标记（…）标示对象内文本文字的溢出。<br>要想实现显示不完内容将显示省略号代替，还需要html nobr标签完成（nobr禁止换行标签）</p>
</li>
</ul>
<h4 id="text-overflow应用案例"><a href="#text-overflow应用案例" class="headerlink" title="text-overflow应用案例"></a>text-overflow应用案例</h4><ul>
<li>1、实现方法<br>对象设置text-overflow:ellipsis;省略号样式</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span><span class="selector-pseudo">:280px</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span><span class="selector-pseudo">:ellipsis</span>; </span><br><span class="line"><span class="selector-tag">white-space</span><span class="selector-pseudo">:nowrap</span>; <span class="comment">/*规定段落中的文本不进行换行*/</span></span><br><span class="line"><span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM渲染流程</title>
    <url>/2017/11/28/IT%E6%8A%80%E6%9C%AF/DOM%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<img src="https://gitee.com/hfood/img-cloud/raw/master/202012/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.jpg" width="80%" />

<ul>
<li><p>1.解析HTML，构建DOM树（构建DOM节点）。</p>
</li>
<li><p>2.构建渲染树（解析样式信息，包括外部的css文件、style标签中的样式）。渲染树由一些包含有各种属性的矩形组成，他们将会按照正确的顺序显 示到屏幕上。</p>
</li>
<li><p>3.布局渲染树（布局DOM节点），执行布局的过程，将确定每个节点在屏幕上的确切坐标。</p>
</li>
<li><p>4.绘制渲染树（绘制DOM节点，即遍历渲染树），使用UI后端层来绘制每个节点。</p>
<a id="more"></a>
<img src="https://gitee.com/hfood/img-cloud/raw/master/202012/webkit%20%E4%B8%BB%E8%A6%81%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.jpg" width="80%" />
</li>
<li><p>1.HTML标签元素经过HTML解析,依据DOM标准生成DOM树,</p>
</li>
<li><p>2.CSS样式代码经过CSS解析成样式规则,Webkit使用attachment连接DOM节点和可视化信息来构建渲染树;</p>
</li>
<li><p>3.渲染树由渲染对象构成,并使用layout来表示元素布局</p>
</li>
<li><p>4.最后遍历渲染树,最后在浏览器上绘制页面</p>
</li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM通用事件绑定</title>
    <url>/2018/02/18/IT%E6%8A%80%E6%9C%AF/DOM%E9%80%9A%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h3 id="1-认识DOM"><a href="#1-认识DOM" class="headerlink" title="1. 认识DOM"></a>1. 认识DOM</h3><p>DOM(Document Object Model),即文档对象模型,是为了<strong>以编程的方法操作HTML和XML文档内容</strong>制定的标准,主要有三种:</p>
<ul>
<li>核心 DOM - 针对任何结构化文档的标准模型</li>
<li>XML DOM - 针对 XML 文档的标准模型</li>
<li>HTML DOM - 针对 HTML 文档的标准模型</li>
</ul>
<p>这里主要认识HTML DOM</p>
<blockquote>
<p>HTML DOM: 关于如何获取、修改、添加或删除 HTML 元素的标准</p>
</blockquote>
<a id="more"></a>

<p>在DOM中,HTML 文档中的所有内容都是节点,通过HTML DOM,树中的所有节点均可通过Js进行增删改查(操作DOM);</p>
<p><img src="https://haohome.top/18-2-18/22599283.jpg" alt="节点树"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM 教程<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>DOM 第一课<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&quot;p&quot;</span>);<span class="comment">//根据选择器标签查找DOM元素</span></span><br><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);<span class="comment">//根据ID查找DOM元素</span></span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;		<span class="comment">//通过操作DOM事件绑定事件</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;你点击了我&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件的绑定有一个通用的方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;绑定了点击事件&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-DOM事件绑定"><a href="#2-DOM事件绑定" class="headerlink" title="2. DOM事件绑定"></a>2. DOM事件绑定</h3><p>上面讲了两种点击事件绑定的方法，addEventListener是一个通用的事件绑定API，但单词太多，最好自己封装一个绑定方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem,type,fn</span>)</span>&#123;</span><br><span class="line">  event.addEventListener(type,fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给按钮btn绑定点击事件</span></span><br><span class="line">bindEvent(btn,click,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;绑定了点击事件&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>重写的bindEvent是一个通用事件绑定,结合事件冒泡情况,可以更完善:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>激活1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>激活2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p3&quot;</span>&gt;</span>激活3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p4&quot;</span>&gt;</span>激活4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>按之前的事件绑定方式,给每个p元素绑定事件,打印输出对应的innerHTML值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">bindEvent(p1,<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerHTML)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> body=<span class="built_in">document</span>.body;</span><br><span class="line">bindEvent(body,<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e.target.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行后发现,点击p1元素会输出两次,说明该元素绑定了两次单击事件,这是由于给p1元素绑定单击事件时冒泡到父元素div1上;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bindEvent(p1,<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么这样通用事件绑定方法就不通用,需要进行改造:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem,type,selector,fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fn==<span class="literal">null</span>)&#123;		<span class="comment">//如果没有第四个参数</span></span><br><span class="line">  	fn=selector;</span><br><span class="line">    selector=<span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  elem.addEventListener(type,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(selector)&#123;</span><br><span class="line">    	<span class="keyword">var</span> target=e.target</span><br><span class="line">      <span class="keyword">if</span>(target.matches(selector))&#123;</span><br><span class="line">        fn.call(<span class="built_in">this</span>,e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      fn(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> div1=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">bindEvent(div1,<span class="string">&#x27;click&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// e.stopPropagation();</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Data类型的url简介</title>
    <url>/2018/09/28/IT%E6%8A%80%E6%9C%AF/Data%E7%B1%BB%E5%9E%8B%E7%9A%84Url%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="1-定义和语法"><a href="#1-定义和语法" class="headerlink" title="1. 定义和语法"></a>1. 定义和语法</h2><p><strong>Data URLs</strong>，即前缀为 <code>data:</code> 协议的的URL，其允许内容创建者向文档中嵌入小文件。(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/data_URIs">MDN</a>)</p>
<p>这样的好处是减少外部资源的载入,减少http请求</p>
<p>Data URLs 由四个部分组成：前缀(<code>data:</code>)、指示数据类型的MIME类型、如果非文本则为可选的<code>base64</code>标记、数据本身：</p>
<blockquote>
<p><code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></p>
<ul>
<li><code>mediatype </code>是个 MIME 类型的字符串，例如 “<code>image/jpeg</code>“ 表示 JPEG 图像文件,如果被省略，则默认值为 <code>text/plain;charset=US-ASCII</code></li>
</ul>
</blockquote>
<p>实例:</p>
<blockquote>
<p><code>data:,Hello%2C%20World!</code>简单的 text/plain 类型数据</p>
<p><code>data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D</code>上一条示例的 base64 编码版本</p>
<p><code>data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E</code>一个HTML文档源代码 <code>&lt;h1&gt;Hello, World&lt;/h1&gt;</code></p>
<p><code>data:text/html,&lt;script&gt;alert(&#39;hi&#39;);&lt;/script&gt;</code>一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。</p>
</blockquote>
<a id="more"></a>

<h2 id="2-data-url的优缺点"><a href="#2-data-url的优缺点" class="headerlink" title="2. data url的优缺点"></a>2. data url的优缺点</h2><p>优点:</p>
<blockquote>
<ul>
<li>当访问外部资源很麻烦或受限时(这个比较鸡肋)</li>
<li> 当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时（场景较少）</li>
<li> 当图片的体积太小，<strong>占用一个HTTP会话</strong>不是很值得时（雪碧图可以出场了）</li>
</ul>
</blockquote>
<p>缺点:</p>
<blockquote>
<ul>
<li>Base64编码的数据体积通常是<strong>原数据的体积4/3</strong>，也就是Data URL形式的图片会比二进制格式的图片体积大1/3</li>
<li>Data URL形式的图片<strong>不会被浏览器缓存</strong>，这意味着每次访问这样页面时都被下载一次</li>
</ul>
</blockquote>
<h2 id="3-在css中使用"><a href="#3-在css中使用" class="headerlink" title="3.在css中使用"></a>3.在css中使用</h2><p>浏览器会css文件以提高访问效率,所以浏览器也可以缓存css中的data url数据,</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;data:image/gif;b ase64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7&quot;</span>);</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图片不是很大,而且不会是重复在css中使用,适合用data url形式展现</p>
<p>更多请阅读<a href="https://www.99css.com/492/">Data URI&amp;MHTML: 用还是不用？</a></p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>flex弹性布局</title>
    <url>/2018/02/25/IT%E6%8A%80%E6%9C%AF/Flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="flex布局是什么"><a href="#flex布局是什么" class="headerlink" title="flex布局是什么"></a>flex布局是什么</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<blockquote>
<p>任何一个容器都可以指定为flex布局,包括行内元素</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p>
</blockquote>
<p>设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>
<a id="more"></a>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>
<p><img src="https://haohome.top/18-2-25/20821183.jpg"></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>
<blockquote>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>
</blockquote>
<h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>有六个属性设置在容器上:</p>
<ul>
<li><p>flex-direction</p>
</li>
<li><p>flex-wrap</p>
</li>
<li><p>flex-flow  :  flex-direction和flex-wrap的简写  <code>.box &#123;  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125;</code></p>
<p>默认值为<code>row nowrap</code></p>
</li>
<li><p>justify-content</p>
</li>
<li><p>align-items</p>
</li>
<li><p>align-content</p>
</li>
</ul>
<h3 id="1-flex-direction属性"><a href="#1-flex-direction属性" class="headerlink" title="1. flex-direction属性"></a>1. flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>
<blockquote>
<ul>
<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>
<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>
<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>
<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>
</ul>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://haohome.top/18-2-25/16870590.jpg" style="width:70%">

<h3 id="2-flex-wrap属性"><a href="#2-flex-wrap属性" class="headerlink" title="2. flex-wrap属性"></a>2. flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p>
<blockquote>
<ul>
<li><code>nowrap</code>（默认）：不换行。</li>
<li><code>wrap</code>：换行，第一行在上方。</li>
<li><code>wrap-reverse</code>：换行，第一行在下方。</li>
</ul>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>nowrap</li>
</ul>
<img src="https://haohome.top/18-2-25/51964219.jpg" style="width:70%">

<ul>
<li>wrap</li>
</ul>
<img src="https://haohome.top/18-2-25/51329599.jpg" style="width:70%">

<ul>
<li>wrap-reverse</li>
</ul>
<img src="https://haohome.top/18-2-25/48930655.jpg" style="width:70%">

<h3 id="3-justify-content属性"><a href="#3-justify-content属性" class="headerlink" title="3. justify-content属性"></a>3. justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>
<p>可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<blockquote>
<ul>
<li><code>flex-start</code>（默认值）：左对齐</li>
<li><code>flex-end</code>：右对齐</li>
<li><code>center</code>： 居中</li>
<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>
<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://haohome.top/18-2-25/54601068.jpg" style="width:50%">

<h3 id="4-align-items属性"><a href="#4-align-items属性" class="headerlink" title="4. align-items属性"></a>4. align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上对齐方式。</p>
<p>可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<blockquote>
<ul>
<li><code>flex-start</code>：交叉轴的起点对齐。</li>
<li><code>flex-end</code>：交叉轴的终点对齐。</li>
<li><code>center</code>：交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://haohome.top/18-2-25/33824725.jpg" style="width:50%">

<h3 id="5-align-content属性"><a href="#5-align-content属性" class="headerlink" title="5. align-content属性"></a>5. align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<p>可能取6个值:</p>
<blockquote>
<ul>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：与交叉轴的中点对齐。</li>
<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>
</ul>
</blockquote>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<img src="https://haohome.top/18-2-25/45463771.jpg" style="width:50%">

<h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><p>6个属性设置在项目上(子元素);</p>
<blockquote>
<ul>
<li><p><code>order</code></p>
</li>
<li><p><code>flex-grow</code></p>
</li>
<li><p><code>flex-shrink</code></p>
</li>
<li><p><code>flex-basis</code></p>
</li>
<li><p><code>flex</code>: 是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>
<p><code>flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]</code></p>
<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>
<blockquote>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
</blockquote>
</li>
<li><p><code>align-self</code></p>
</li>
</ul>
</blockquote>
<h3 id="1-order属性"><a href="#1-order属性" class="headerlink" title="1. order属性"></a>1. order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://haohome.top/18-2-25/98462050.jpg" style="width:50%">

<h3 id="2-flex-grow属性"><a href="#2-flex-grow属性" class="headerlink" title="2. flex-grow属性"></a>2. flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">	<span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://haohome.top/18-2-25/98462050.jpg" style="width:50%">

<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h3 id="3-flex-shrink属性"><a href="#3-flex-shrink属性" class="headerlink" title="3. flex-shrink属性"></a>3. flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://haohome.top/18-2-25/17444861.jpg" style="width:70%">

<h3 id="4-flex-basis属性"><a href="#4-flex-basis属性" class="headerlink" title="4. flex-basis属性"></a>4. flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即<strong>项目的本身大小</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-basis: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它也可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p>
<h3 id="5-align-self属性"><a href="#5-align-self属性" class="headerlink" title="5. align-self属性"></a>5. align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">  <span class="comment">/*除了auto，其他都与align-items属性完全一致*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://haohome.top/18-2-25/33003949.jpg" style="width:50%">

<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p><a href="https://codepen.io/hfood/pen/MQqMev">骰子</a></p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeMaker模板_数据模型</title>
    <url>/2018/01/01/IT%E6%8A%80%E6%9C%AF/FreeMaker%20%E6%A8%A1%E6%9D%BF_%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="1-模板-数据模型-输出"><a href="#1-模板-数据模型-输出" class="headerlink" title="1. 模板 + 数据模型 = 输出"></a>1. 模板 + 数据模型 = 输出</h2><h3 id="1-1-模板"><a href="#1-1-模板" class="headerlink" title="1.1 模板"></a>1.1 模板</h3><p> 模板与静态HTML类似,区别是包含了一些指令,使网页内容可以动态生成，例如:<br>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome $&#123;user&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Our latest product:</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;latestProduct.url&#125;&quot;</span>&gt;</span>$&#123;latestProduct.name&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>  <a id="more"></a></p>
<ul>
<li><p>${…}：插值表达式(interpolation)</p>
</li>
<li><p>FTL标签：FreeMarker模板的语言标签，标签的名字以 # 开头，用户自定义的FTL标签则需要使用 @ 来代替 #</p>
</li>
<li><p>注释：使用 &lt;#– and –&gt; 来标识</p>
<blockquote>
<p>其他任何不是插值、FTL标签或注释的内容将被视为静态文本，直接在页面输出</p>
</blockquote>
<h3 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h3><p>为模板准备的数据整体被称作为<strong>数据模型</strong><br>数据模型是树形结构,例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(root)</span><br><span class="line"> |</span><br><span class="line"> +- animals</span><br><span class="line"> |   |</span><br><span class="line"> |   +- mouse</span><br><span class="line"> |   |   |   </span><br><span class="line"> |   |   +- size = <span class="string">&quot;small&quot;</span></span><br><span class="line"> |   |   |   </span><br><span class="line"> |   |   +- price = <span class="number">50</span></span><br><span class="line"> |   |</span><br><span class="line"> |   +- elephant</span><br><span class="line"> |   |   |   </span><br><span class="line"> |   |   +- size = <span class="string">&quot;large&quot;</span></span><br><span class="line"> |   |   |   </span><br><span class="line"> |   |   +- price = <span class="number">5000</span></span><br><span class="line"> |   |</span><br><span class="line"> |   +- python</span><br><span class="line"> |       |   </span><br><span class="line"> |       +- size = <span class="string">&quot;medium&quot;</span></span><br><span class="line"> |       |   </span><br><span class="line"> |       +- price = <span class="number">4999</span></span><br><span class="line"> |</span><br><span class="line"> +- message = <span class="string">&quot;It is a test&quot;</span></span><br><span class="line"> |</span><br><span class="line"> +- misc</span><br><span class="line">     |</span><br><span class="line">     +- foo = <span class="string">&quot;Something&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>hashes (哈希表): 指变量中扮演目录角色(比如 root, animals, mouse, elephant, python, misc)</p>
<blockquote>
<p>哈希表存储其他变量(被称为 子变量)， 它们可以通过名称来查找(比如 “animals”, “mouse” 或 “price”)。</p>
</blockquote>
</li>
<li><p>scalars (标量): 指存储单值的变量 (size, price, message 和 foo)</p>
<blockquote>
<p>如果要在模板中使用子变量， 那应该从根root开始指定它的路径，每级之间用点来分隔开。要访问 mouse 的 price ，要从root开始，首先进入到 animals ，之后访问 mouse ，最后访问 price 。就可以这样来写 animals.mouse.price。</p>
</blockquote>
</li>
<li><p>sequences (序列): 像哈希表那样存储子变量，但是子变量没有名字，它们只是列表中的项。在下面这个数据模型中， animals 和 misc.fruits 就是序列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(root)</span><br><span class="line">  |</span><br><span class="line">  +- animals</span><br><span class="line">  |   |</span><br><span class="line">  |   +- (1st)</span><br><span class="line">  |   |   |</span><br><span class="line">  |   |   +- name = <span class="string">&quot;mouse&quot;</span></span><br><span class="line">  |   |   |</span><br><span class="line">  |   |   +- size = <span class="string">&quot;small&quot;</span></span><br><span class="line">  |   |   |</span><br><span class="line">  |   |   +- price = <span class="number">50</span></span><br><span class="line">  |   |</span><br><span class="line">  |   +- (2nd)</span><br><span class="line">  |   |   |</span><br><span class="line">  |   |   +- name = <span class="string">&quot;elephant&quot;</span></span><br><span class="line">  |   |   |</span><br><span class="line">  |   |   +- size = <span class="string">&quot;large&quot;</span></span><br><span class="line">  |   |   |</span><br><span class="line">  |   |   +- price = <span class="number">5000</span></span><br><span class="line">  |   |</span><br><span class="line">  |   +- (3rd)</span><br><span class="line">  |       |</span><br><span class="line">  |       +- name = <span class="string">&quot;python&quot;</span></span><br><span class="line">  |       |</span><br><span class="line">  |       +- size = <span class="string">&quot;medium&quot;</span></span><br><span class="line">  |       |</span><br><span class="line">  |       +- price = <span class="number">4999</span></span><br><span class="line">  |</span><br><span class="line">  +- misc</span><br><span class="line">      |</span><br><span class="line">      +- fruits</span><br><span class="line">          |</span><br><span class="line">          +- (1st) = <span class="string">&quot;orange&quot;</span></span><br><span class="line">          |</span><br><span class="line">          +- (2nd) = <span class="string">&quot;banana&quot;</span></span><br></pre></td></tr></table></figure>
<p>要访问序列的子变量，可以使用方括号形式的数字索引下标。 索引下标从0开始(从0开始也是程序员的传统)，那么第一项的索引就是0， 第二项的索引就是1等等。要得到第一个动物的名称的话，可以这么来写代码 <code>animals[0].name</code>。</p>
</li>
</ul>
<p>  <strong>标量类型可以分为如下的类别：</strong></p>
<ul>
<li>字符串：就是文本，也就是任意的字符序列，比如上面提到的 ‘m’,’o’,’u’, ‘s’,’e’。比如 name 和 size 也是字符串。</li>
<li>数字：这是数值类型，就像上面的 price。 在FreeMarker中，字符串 “50” 和数字 50 是两种完全不同的类型。</li>
<li>日期/时间: 可以是日期-时间格式(存储某一天的日期和时间)， 或者是日期(只有日期，没有时间)，或者是时间(只有时间，没有日期)。</li>
<li>布尔值：对应着对/错(是/否，开/关等值)类似的值。</li>
</ul>
<blockquote>
<p>总结：</p>
<ul>
<li>数据模型可以被看成是树形结构。</li>
<li>标量用于存储单一的值。这种类型的值可以是字符串，数字，日期/时间或者是布尔值。</li>
<li>哈希表是一种存储变量及其相关且有唯一标识名称的容器。</li>
<li>序列是存储有序变量的容器。存储的变量可以通过数字索引来检索，索引通常从0开始。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
        <tag>FreeMaker</tag>
      </tags>
  </entry>
  <entry>
    <title>JS手写状态管理的实现</title>
    <url>/2019/01/31/IT%E6%8A%80%E6%9C%AF/JS%E6%89%8B%E5%86%99%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>一次偶然在掘金看到一位大大分享了老外写的js状态管理文章,通读后就决定自己也写一遍,目的是了解状态管理的内部机制.</p>
</blockquote>
<p>当前的项目多数以组件化开发,状态管理库使得组件间状态管理变得非常方便。</p>
<h3 id="1-订阅发布模块"><a href="#1-订阅发布模块" class="headerlink" title="1. 订阅发布模块"></a>1. 订阅发布模块</h3><p>这个模块实际上是观察者模式,是一种一对多的依赖关系,当对象的某种状态发生改变,所有依赖它的对象都将得到通知,触发已经注册的事件.</p>
<p>在主题<code>Subject</code>类中首先定义<code>this.eventList</code>保存需要注册的事件,依次添加<code>subscribe</code>(订阅)、<code>unsubscribe</code>（取消订阅）、·<code>publish</code>（发布订阅）等方法</p>
<p><code>subscribe</code>和<code>unsubscribe</code>的两个参数:<code>name</code>代表注册事件的唯一名字,<code>fn</code>为事件<code>name</code>的回调函数,表示所有<code>fn</code>方法都注册到名为<code>name</code>的集合下</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.eventList = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 订阅主题</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>name 事件名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>fn 事件方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">subscribe</span>(<span class="params">name, fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.eventList.hasOwnProperty(name)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.eventList[name] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.eventList[name].push(fn)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this.eventList: &#x27;</span>, <span class="built_in">this</span>.eventList);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 取消订阅主题</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>name 事件名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>fn 事件方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">unsubscribe</span>(<span class="params">name, fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fns = <span class="built_in">this</span>.eventList[name];</span><br><span class="line">    <span class="keyword">if</span> (!fns || fns.length == <span class="number">0</span>) &#123; <span class="comment">// 如果没有订阅该事件,直接返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123; <span class="comment">// 如果传入具体函数,表示取消所有对应name的订阅</span></span><br><span class="line">      fns.length = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fns.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fn == fns[i]) &#123;</span><br><span class="line">          fns.splice(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 发布主题,触发订阅事件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">pulish</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>)	<span class="comment">// 获取事件名称</span></span><br><span class="line">    <span class="keyword">var</span> fns = <span class="built_in">this</span>.eventList[name]</span><br><span class="line">    <span class="keyword">if</span> (!fns || fns.length == <span class="number">0</span>) &#123; <span class="comment">// 没有订阅该事件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, fn; i &lt; fns.length; i++) &#123;</span><br><span class="line">      fn = fns[i]</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于观察者类,传入主题、事件名称、事件方法，目的是将事件注册到相应主题上:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">subject, name, fn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subject = subject</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.subject.subscribe(name, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-核心LibStore类"><a href="#2-核心LibStore类" class="headerlink" title="2. 核心LibStore类"></a>2. 核心<code>LibStore</code>类</h3><p>核心<code>LibStore</code>类需要引入上面的订阅发布模块的主题类,状态管理个人理解为一个单例化的主题,所有的状态事件都在同一个主题下进行订阅发布,因此实例化一次<code>Subject</code>即可。同时需要对<code>state</code>数据进行监听和赋值,创建<code>LibStore</code>类需要传入参数<code>params</code>,从参数中获取<code>actions</code>、<code>mutations</code>,或者默认为{}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _self = <span class="built_in">this</span></span><br><span class="line">  <span class="built_in">this</span>._subject = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="built_in">this</span>.mutations = params.mutations ? params.mutations : &#123;&#125;</span><br><span class="line">	<span class="built_in">this</span>.actions = params.actions ? params.actions : &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了判<code>LibStore</code>对象在任意时刻的状态,需要定义<code>status</code>用来记录,状态有三种:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.status = <span class="string">&#x27;resting&#x27;</span>;</span><br><span class="line"><span class="built_in">this</span>.status = <span class="string">&#x27;mutation&#x27;</span>; </span><br><span class="line"><span class="built_in">this</span>.status = <span class="string">&#x27;action&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>存放数据<code>state</code>也会从<code>params</code>传入,但为了监听<code>LibStore</code>中存储的数据变化,我们引入了代理<code>Proxy</code>,使每次访问和改变<code>state</code>数据变化都得到监听,改变<code>state</code>数据时触发主题发布,执行所有依赖<code>stateChange</code>事件的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理状态值,监听状态变化</span></span><br><span class="line"><span class="built_in">this</span>.state = <span class="keyword">new</span> <span class="built_in">Proxy</span>(params.state || &#123;&#125;, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">state, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">state, key, val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_self.status !== <span class="string">&#x27;mutation&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`需要采用mutation来改变状态值`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    state[key] = val</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`状态变化:<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">    _self._subject.pulish(<span class="string">&#x27;stateChange&#x27;</span>, _self.state)</span><br><span class="line">    _self.status = <span class="string">&#x27;resting&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>改变<code>state</code>中数据通过<code>commit</code>或<code>dispatch</code>方法来执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 修改状态值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>name </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>newVal </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="title">commit</span>(<span class="params">name, newVal</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (<span class="built_in">this</span>.mutations[name]) != <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fasle</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.group(<span class="string">`mutation: <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">this</span>.status = <span class="string">&#x27;mutation&#x27;</span>; <span class="comment">// 改变状态</span></span><br><span class="line">  <span class="built_in">this</span>.mutations[name](<span class="built_in">this</span>.state, newVal);</span><br><span class="line">  <span class="built_in">console</span>.groupEnd();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分发执行action的方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  </span>key 的方法属性名 </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  </span>newVal 状态的新值 </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="title">dispatch</span>(<span class="params">key, newVal</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (<span class="built_in">this</span>.actions[key]) != <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fasle</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.group(<span class="string">`action: <span class="subst">$&#123;key&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">this</span>.actions[key](<span class="built_in">this</span>, newVal);</span><br><span class="line">  self.status = <span class="string">&#x27;action&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.groupEnd();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后,将实例化的主题<code>_subject</code>暴露出来,以便后续注册<code>stateChange</code>事件时使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getSubject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>._subject</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-实例化核心LibStore组件"><a href="#3-实例化核心LibStore组件" class="headerlink" title="3. 实例化核心LibStore组件"></a>3. 实例化核心<code>LibStore</code>组件</h3><p>使用<code>vuex</code>的同学对这个组件一定不陌生,主要是配置<code>state</code>、<code>mutations</code>、<code>actions</code>,并把参数传入核心<code>LibStore</code>组件类的实例当中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> libStore <span class="keyword">from</span> <span class="string">&quot;./libStore&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> state = &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mutations = &#123;</span><br><span class="line">  <span class="function"><span class="title">addCount</span>(<span class="params">state, val</span>)</span> &#123;</span><br><span class="line">    state.count = val</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> actions = &#123;</span><br><span class="line">  <span class="function"><span class="title">updateCount</span>(<span class="params">context, val</span>)</span> &#123;</span><br><span class="line">    context.commit(<span class="string">&#x27;addCount&#x27;</span>, val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> libStore(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-注册stateChange事件"><a href="#4-注册stateChange事件" class="headerlink" title="4.注册stateChange事件"></a>4.注册<code>stateChange</code>事件</h3><p><code>StoreChange</code>类将作为应用组件的继承类使用,目的是使使用组件注册<code>stateChange</code>事件,同时获得继承类的<code>update</code>方法,该方法将在<code>state</code>数据变化时的到触发。</p>
<p>引入刚刚实例化<code>LibStore</code>的对象<code>store</code>和订阅发布模块中的观察者类，并注册<code>stateChange</code>事件和回调<code>update</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/assets/lib/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observer &#125; <span class="keyword">from</span> <span class="string">&#x27;./subject&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoreChange</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.update = <span class="built_in">this</span>.update || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">new</span> Observer(store.getSubject(), <span class="string">&#x27;stateChange&#x27;</span>, <span class="built_in">this</span>.update.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-应用实例"><a href="#5-应用实例" class="headerlink" title="5. 应用实例"></a>5. 应用实例</h3><p>实例将采用两个组件<code>Index</code>和<code>Detail</code>,分别代表两个页面,通过<code>hash</code>路由切换挂载实现跳转,需要说明的是,每次挂载组件前需要清除已经在状态对象的单例化主题中注册的<code>stateChange</code>方法,避免重复注册。</p>
<ul>
<li>Index</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面art模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>增加数量<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>减少数量<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&#x27;time&#x27;</span>&gt;</span>&lt;%= count%&gt;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件Js</span></span><br><span class="line"><span class="keyword">import</span> StateChange <span class="keyword">from</span> <span class="string">&#x27;@/assets/lib/stateChange&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/assets/lib/store&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">StateChange</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">$root</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.$root = $root</span><br><span class="line">    <span class="built_in">this</span>.render()</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btn1&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="built_in">this</span>.add.bind(<span class="built_in">this</span>))</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btn2&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="built_in">this</span>.minus.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> indexTmpl = <span class="built_in">require</span>(<span class="string">&#x27;./index.art&#x27;</span>)</span><br><span class="line">    <span class="built_in">this</span>.$root.innerHTML =indexTmpl(&#123;<span class="attr">count</span>:store.state.count&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#time&#x27;</span>).textContent = store.state.count</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = store.state.count</span><br><span class="line">    store.commit(<span class="string">&#x27;addCount&#x27;</span>,++count)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">minus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = store.state.count</span><br><span class="line">    store.dispatch(<span class="string">&#x27;updateCount&#x27;</span>,--count)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Detail</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面art模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>详情<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;count&quot;</span>&gt;</span>&lt;%= count%&gt;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> StateChange <span class="keyword">from</span> <span class="string">&#x27;@/assets/lib/stateChange&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/assets/lib/store&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">StateChange</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">$root</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.$root = $root</span><br><span class="line">    <span class="built_in">this</span>.render()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> detailTmpl = <span class="built_in">require</span>(<span class="string">&#x27;./detail.art&#x27;</span>)</span><br><span class="line">    <span class="built_in">this</span>.$root.innerHTML = detailTmpl(&#123;<span class="attr">count</span>:store.state.count&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文章参考<a href="https://juejin.im/post/5b5ec01a6fb9a04fb4017481">原生 JavaScript 实现 state 状态管理系统</a></p>
<p>最后感谢原文作者和分享作者!</p>
<p><a href="https://juejin.im/post/5c528411e51d456898361e43"><img src="https://badge.juejin.im/entry/5c5286346fb9a049a62d0161/likes.svg?style=flat-square"></a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>state</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的static的使用</title>
    <url>/2017/12/21/IT%E6%8A%80%E6%9C%AF/Java%20%E4%B8%AD%E7%9A%84%20static%20%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="static静态变量的使用"><a href="#static静态变量的使用" class="headerlink" title="static静态变量的使用"></a>static静态变量的使用</h3><p>  通常我们可以基于一个类创建多个该类的对象，每个对象都拥有自己的成员，互相独立。然而在某些时候，我们更希望该类所有的对象共享同一个成员。static的作用在于此;</p>
<ul>
<li>Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。</li>
<li>使用 static 可以修饰变量、方法和代码块。<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> String hobby=<span class="string">&quot;唱歌&quot;</span>;<span class="comment">//static修饰的变量为静态变量,所有类的对象共享hobby;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;通过类名访问hobby: &quot;</span> +HelloWorld.hobby);</span><br><span class="line">    HelloWorld hello=<span class="keyword">new</span> HelloWorld();</span><br><span class="line">    System.out.println(<span class="string">&quot;通过对象名访问hobby: &quot;</span>+hello.hobby);</span><br><span class="line">    hello.hobby=<span class="string">&quot;跳舞&quot;</span>;<span class="comment">//通过对象名的形式修改静态变量的值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;通过类名访问hobby: &quot;</span> +HelloWorld.hobby);<span class="comment">//再次使用类名访问静态变量,值已改变</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间,直到该类被卸载才会进行资源回收！</strong></p>
</blockquote>
</li>
</ul>
<h3 id="static静态方法的使用"><a href="#static静态方法的使用" class="headerlink" title="static静态方法的使用"></a>static静态方法的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  print();<span class="comment">//直接调用同类中静态方法</span></span><br><span class="line">  HelloWorld.print();<span class="comment">//直接使用类名调用静态方法</span></span><br><span class="line">  HelloWorld hello=<span class="keyword">new</span> HelloWorld();</span><br><span class="line">  hello.print();<span class="comment">//通过实例化对象再调用;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用关键字声明静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;你好,世界!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>1.静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">  String name=<span class="string">&quot;小明&quot;</span>;<span class="comment">//费静态变量</span></span><br><span class="line">  <span class="keyword">static</span> String hobby=<span class="string">&quot;唱歌&quot;</span>;<span class="comment">//静态变量hobby</span></span><br><span class="line">  <span class="comment">//在静态方法中调用非静态变量</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println(&quot;欢迎:&quot;+name+&quot;!&quot;);报错,不能直接调用非静态变量</span></span><br><span class="line">    System.out.println(<span class="string">&quot;爱好:&quot;</span>+hobby+<span class="string">&quot;!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//创建类的对象</span></span><br><span class="line">  HelloWorld hello=<span class="keyword">new</span> HelloWorld();</span><br><span class="line">  <span class="comment">//通过对象来实现在静态方法中调用非静态变量</span></span><br><span class="line">    System.out.println(<span class="string">&quot;欢迎:&quot;</span>+hello.name+<span class="string">&quot;!&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;爱好:&quot;</span>+hobby+<span class="string">&quot;!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2.在普通成员方法中，则可以直接访问同类的非静态变量和静态变量<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">&quot;张三&quot;</span>; <span class="comment">//非静态变量</span></span><br><span class="line"><span class="keyword">static</span> String hobby=<span class="string">&quot;唱歌&quot;</span>;<span class="comment">//静态变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;欢迎:&quot;</span>+name+<span class="string">&quot;!&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;爱好:&quot;</span>+hobby+<span class="string">&quot;!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3.静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">//普通成员方法</span></span><br><span class="line">  System.out.println(<span class="string">&quot;你好欢迎您!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;欢迎来到这里&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  HelloWorld hello=<span class="keyword">new</span> HelloWorld();</span><br><span class="line">  hello.show();<span class="comment">//普通成员方法必须通过对象调用</span></span><br><span class="line">  print();<span class="comment">//可以直接调用静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式之单例模式</title>
    <url>/2018/10/06/IT%E6%8A%80%E6%9C%AF/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单例模式是保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<blockquote>
<p>实现方式:用一个变量来标志当前是否已经为某个类创建过对象,若是,则在下一次获取该类实例时,直接返回之前创建的对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">instance</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">login</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;登录框弹窗&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SingleObject.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.instance)&#123;</span><br><span class="line">      <span class="built_in">this</span>.instance = <span class="keyword">new</span> SingleObject()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = SingleObject.getInstance()</span><br><span class="line">obj1.login()</span><br><span class="line"><span class="keyword">let</span> obj2 = SingleObject.getInstance()</span><br><span class="line">obj2.login()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj1===obj2&#x27;</span>,obj1===obj2)</span><br></pre></td></tr></table></figure>

<p>通过<code>SingleObject.getInstance</code>来获取SingleObject类的唯一对象</p>
<a id="more"></a>

<p> 应用场景: 网站的登录框通常只有一个实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&#x27;hide&#x27;</span>		<span class="comment">// 默认隐藏</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.state === <span class="string">&#x27;show&#x27;</span>)&#123;</span><br><span class="line">            alert(<span class="string">&#x27;已经显示&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&#x27;show&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;登录框显示成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">hide</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.state === <span class="string">&#x27;hide&#x27;</span>)&#123;</span><br><span class="line">            alert(<span class="string">&#x27;已经隐藏&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&#x27;hide&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;登录框隐藏成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LoginForm.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;外部&#x27;</span>,instance)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;内部&#x27;</span>,instance)</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LoginForm()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> login1 = LoginForm.getInstance()</span><br><span class="line">login1.show()</span><br><span class="line"><span class="keyword">let</span> login2 = LoginForm.getInstance()</span><br><span class="line">login2.show()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式之迭代器模式</title>
    <url>/2019/01/27/IT%E6%8A%80%E6%9C%AF/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>迭代器模式是指在不暴露对象内部结构的同时,可以<strong>顺序</strong>的访问聚合对象的内部元素</p>
</blockquote>
<p>迭代器主要解决不同的方式来遍历整个整合对象</p>
<p>业务场景:</p>
<ul>
<li>根据不同浏览器获取相应的上传组件对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(...)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="keyword">if</span>(supportFlash())&#123;</span><br><span class="line">        <span class="keyword">return</span> flashUpload</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h5Upload</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果浏览器支持上传控件,会优先选用上传控件,如果没有则判断是否支持flash,如果连flash也没有安装,则采用h5原生的上传方式</p>
</blockquote>
<a id="more"></a>

<p>为了得到一个upload对象,程序使用了try…catch和if语句,造成阅读困难,同时违反开放封闭原则</p>
<p>如果每一种获取upload对象方法封装成独立的函数里,再使用迭代器遍历这些函数组成的集合,从而获取到可用的upload对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getActiveObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(...)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">var</span> getFlashObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(supportFlash())&#123;</span><br><span class="line">      <span class="keyword">return</span> flashUpload</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> getH5Upload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h5Uplaod</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>迭代器只需要做以下工作:</p>
<ul>
<li>提供一个可以遍历集合的方法,使得按照一定的优先级顺序遍历迭代</li>
<li>如果正在被迭代的函数返回一个对象,则表示找到了正确的upload对象,如果返回false,则迭代器继续工作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iteratorUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = <span class="built_in">arguments</span>[ i++ ]; )&#123;</span><br><span class="line">        <span class="keyword">var</span> uploadObj = fn();</span><br><span class="line">        <span class="keyword">if</span> ( uploadObj !== <span class="literal">false</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> uploadObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> uploadObj = iteratorUploadObj(getActiveObj,getFlashObj,getH5Upload)</span><br></pre></td></tr></table></figure>

<p>这样的迭代模式使得获取不同上传对象的方法独立,很方便后续的维护,比如添加了一个上传控件方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newUploadPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(supportPlugin())&#123;</span><br><span class="line">    <span class="keyword">return</span> uploadPluginObj</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> uploadObj = iteratorUploadObj(newUploadPlugin,getActiveObj,getFlashObj,getH5Upload)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式之适配器模式</title>
    <url>/2018/10/07/IT%E6%8A%80%E6%9C%AF/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>适配器模式的作用是解决两个软件实体间的接口不兼容的问题.</p>
<p>这在实际开发过程中会经常遇到,比如后端返回的数据api接口与前端实际需求有差异,我们就需要对数据api接口进行转换一下再使用,这就需要适配器;而在vue中最直接的提现就是computed属性</p>
<p>举个例子:     当向谷歌地图和百度地图都发出显示请求时,两个地图都以各自的方式展示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoogleMap</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">&#x27;开始渲染谷歌地图&#x27;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaiduMap</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">&#x27;开始渲染百度地图&#x27;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderMap</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">map</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span> )&#123;</span><br><span class="line">            map.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> baiduMap = <span class="keyword">new</span> BaiduMap()</span><br><span class="line"><span class="keyword">let</span> baidu = <span class="keyword">new</span> RenderMap(baiduMap)</span><br><span class="line"><span class="keyword">let</span> googleMap = <span class="keyword">new</span> GoogleMap()</span><br><span class="line"><span class="keyword">let</span> google = <span class="keyword">new</span> RenderMap(googleMap)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这段程序正常运行的关键是,两个地图类都提供了show的方法,假如google提供的不是show而是display方法,那我们可通过增加新的适配器来解决:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoogleMap</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">display</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">&#x27;开始渲染谷歌地图&#x27;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoogleAdapter</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">googleMap</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.googleMap = googleMap</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.googleMap.display()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = <span class="keyword">new</span> GoogleMap()</span><br><span class="line"><span class="keyword">let</span> googleMap = <span class="keyword">new</span> GoogleAdapter(g)</span><br><span class="line"><span class="keyword">let</span> google = <span class="keyword">new</span> RenderMap(googleMap)</span><br></pre></td></tr></table></figure>

<p>适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。</p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中extends和implements的区别</title>
    <url>/2017/12/11/IT%E6%8A%80%E6%9C%AF/Java%E4%B8%ADextends%E5%92%8Cimplements%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>在类的声明中,通过关键字extends来创建一个类的子类。一个类通过关键字implements声明自己使用一个或者多个接口。</p>
</blockquote>
<ul>
<li>extends 是继承父类(只要那个类不是声明为final或者那个类定义为abstract的就能继承), 继承之后可以使用父类的方法, 也可以重写父类的方法,可以实现父类，也可以调用父类初始化 this.parent()。而且会覆盖父类定义的变量或者函数。<br>这样的好处是：架构师定义好接口，让工程师实现就可以了。整个项目开发效率和开发成本大大降低。   </li>
<li>implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用;<br>实现父类，子类不可以覆盖父类的方法或者变量。即使子类定义与父类相同的变量或者函数，也会被父类取代掉。 </li>
<li>这两种实现的具体使用，是要看项目的实际情况，需要实现，不可以修改implements，只定义接口需要具体实现，或者可以被修改扩展性好，用extends。<a id="more"></a>

</li>
</ul>
<blockquote>
<p>接口实现的注意点：</p>
</blockquote>
<ul>
<li>实现一个接口就是要实现该接口的所有的方法(抽象类除外)。 </li>
<li>接口中的方法都是抽象的。  </li>
<li>多个无关的类可以实现同一个接口，一个类可以实现多个无关的接口。</li>
<li>JAVA中不支持多重继承，但是可以用接口来实现，这样就要用到implements，继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了 比如 ：<br><code>class A extends B implements C,D,E</code> </li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中super关键字的使用</title>
    <url>/2018/01/01/IT%E6%8A%80%E6%9C%AF/Java%E4%B8%ADsuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>在对象的内部使用,可以代表父类对象</p>
<ul>
<li>1.访问父类的属性<br>super.age</li>
<li>2.访问父类的方法<br>super.eat()</li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的多态</title>
    <url>/2018/01/01/IT%E6%8A%80%E6%9C%AF/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h4 id="1-引用多态"><a href="#1-引用多态" class="headerlink" title="1.引用多态"></a>1.引用多态</h4><ul>
<li>父类的引用可以指向本类的对象</li>
<li>父类的引用可以指向子类的对象<h4 id="2-方法多态"><a href="#2-方法多态" class="headerlink" title="2.方法多态"></a>2.方法多态</h4></li>
<li>创建本类对象时,调用的方法为本类方法</li>
<li>创建子类对象时,调用的方法为<strong>子类重写的方法或者继承的方法</strong><h4 id="3-引用类型转换"><a href="#3-引用类型转换" class="headerlink" title="3.引用类型转换"></a>3.引用类型转换</h4></li>
<li>向上类型转换(隐式/自动类型转换),是小类型向大类型转换</li>
<li><strong>向下类型转换(强制类型转换),是大类型到小类型转换</strong>(存在数据溢出风险)</li>
<li>instanceof运算符:避免类型转换出现的安全问题<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dog dog=<span class="keyword">new</span> Dog();</span><br><span class="line">Animal animal=dog;<span class="comment">//(向上类型转换)</span></span><br><span class="line"><span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">  Dog dog2=(Dog)animal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;无法进行类型转换&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的抽象类</title>
    <url>/2018/01/01/IT%E6%8A%80%E6%9C%AF/Java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="1-语法定义"><a href="#1-语法定义" class="headerlink" title="1.语法定义"></a>1.语法定义</h3><p>抽象类前使用abstract关键字修饰,则该类为抽象类</p>
<h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><ul>
<li>父类只知道子类应该包含哪些方法,但不知道子类如何实现这些方法</li>
<li>从多个具有相同特征的类中抽象出一个抽象类,以这个抽象类作为子类额模板,避免子类设计的随意性<h3 id="3-作用"><a href="#3-作用" class="headerlink" title="3.作用"></a>3.作用</h3>抽象类是约束子类必须有哪些方法,而并不关注子类如何实现这些方法<h3 id="4-使用规则-步骤"><a href="#4-使用规则-步骤" class="headerlink" title="4.使用规则(步骤)"></a>4.使用规则(步骤)</h3></li>
<li>1)abstract定义抽象类</li>
<li>2)abstract定义抽象方法,只有声明,不需要实现(就是定义一个方法名,让子类根据自己情况实现)</li>
<li>3)包含抽象方法的类是抽象类</li>
<li>4)抽象类中可以包含普通方法,也可以没有抽象方法</li>
<li>5)抽象类不能直接创建,可以定义引用变量</li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的接口</title>
    <url>/2018/01/07/IT%E6%8A%80%E6%9C%AF/Java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h3 id="1-接口的概念"><a href="#1-接口的概念" class="headerlink" title="1.接口的概念"></a>1.接口的概念</h3><p>接口定义了某一批类所需要遵守的规范,接口不关心这些类的内部数据,也不关心这些类里方法的实现细节,它只规定这些类里必须提供某些方法;</p>
<h3 id="2-接口定义"><a href="#2-接口定义" class="headerlink" title="2.接口定义"></a>2.接口定义</h3><p>定义接口不再使用class关键字,而使用interface关键字</p>
<h4 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符public] [abstract] interface 接口名 [extends 父接口1,父接口2...]</span><br><span class="line">&#123;</span><br><span class="line">  零个到多个常量定义...</span><br><span class="line">  零个到多个抽象方法的定义...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口是开放的（被继承、被实现），修饰符使用public，不能使用private和protected</p>
<ul>
<li><p>常量<br>接口中的属性是常量,即使定义时不添加public static final修饰符,系统也会自动加上</p>
</li>
<li><p>方法<br>接口中的方法只能是抽象方法,总是使用,即使定义时不添加public abstract修饰符,系统也会自动加上</p>
<h3 id="3-使用接口"><a href="#3-使用接口" class="headerlink" title="3.使用接口"></a>3.使用接口</h3><p>一个类可以实现一个或多个接口,实现接口使用implements关键字</p>
<blockquote>
<p>阶层父类实现接口的语法:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口1,接口2...</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  类体部分  <span class="comment">//如果继承了抽象类,需要实现继承的抽象方法;要实现接口中的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如果要继承父类,继承父类必须在实现接口之前</strong></p>
</blockquote>
</li>
<li><p>补充:接口使用过程中,还经常与匿名内部类配合使用</p>
<blockquote>
<p>匿名内部类就是没有名字的内部类,多用于关注实现而不关注实现类的名称<br>语法格式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Interface i=<span class="keyword">new</span> Interface()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;匿名内部类实现接口的方式&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">i.method();<span class="comment">//直接调用</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的类和对象</title>
    <url>/2018/01/01/IT%E6%8A%80%E6%9C%AF/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h2><ul>
<li>类是对象的类型</li>
<li>类具有相同属性和方法的一组对象的集合</li>
</ul>
<ol>
<li>定义:确定对象将拥有的特征(属性)和方法(行为)</li>
<li>类的组成:属性和方法</li>
<li>定义类的步骤<blockquote>
<p>a.定义类名<br>b.编写类的属性<br>c.编写类的方法<br> !– more –&gt;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">  <span class="comment">//定义属性部分(成员变量)</span></span><br><span class="line">  属性<span class="number">1</span>的类型 属性<span class="number">1</span>;</span><br><span class="line">  属性<span class="number">2</span>的类型 属性<span class="number">2</span>;</span><br><span class="line">  <span class="comment">//定义方法部分</span></span><br><span class="line">  方法<span class="number">1</span>;</span><br><span class="line">  方法<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-对象"><a href="#2-对象" class="headerlink" title="2.对象"></a>2.对象</h2><h3 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h3></li>
</ol>
<ul>
<li>对象具有的各种特征</li>
<li>每个对象的每个属性都拥有特定值<h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3></li>
<li>对象可以执行的操作</li>
</ul>
<p>使用对象的步骤:<br> a. 创建对象(new)<br> b. 使用对象<br>    引用对象的属性:对象名.属性<br>    引用对象的方法:对象名.方法</p>
<blockquote>
<p>类是抽象的概念,对象是一个具体的实物</p>
</blockquote>
<h2 id="3-访问修饰符"><a href="#3-访问修饰符" class="headerlink" title="3.访问修饰符"></a>3.访问修饰符</h2><table>
<thead>
<tr>
<th>访问修饰符</th>
<th>本类</th>
<th>同包</th>
<th>子类</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>默认</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<ul>
<li>属性通常设为private</li>
<li>外部调用对象属性通常通过对象的getter和setter方法</li>
</ul>
<h2 id="4-Object类的方法"><a href="#4-Object类的方法" class="headerlink" title="4.Object类的方法"></a>4.Object类的方法</h2><h3 id="4-1-toString-方法"><a href="#4-1-toString-方法" class="headerlink" title="4.1 toString()方法"></a>4.1 toString()方法</h3><p>默认:toString()方法默认返回的是对象的哈希码(对象的地址字符串)<br>Override:返回的是对象的属性值</p>
<h3 id="4-2-equals-方法"><a href="#4-2-equals-方法" class="headerlink" title="4.2 equals()方法"></a>4.2 equals()方法</h3><p>默认:比较的是对象的引用是否指向同一块内存地址<br>Override:比较对象的属性值(数据)信息</p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js的web服务器路由重构</title>
    <url>/2018/05/02/IT%E6%8A%80%E6%9C%AF/Node.js%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B7%AF%E7%94%B1%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<img src='https://haohome.top/18-5-3/35609573.jpg' width="40%">

<p>Node使JavaScript操作服务器成为可能，同时其带来了强大的文件操作方法。我们在创建一个服务器时，会遇到路由切换的问题，当前express等库是可以识别不同路由并执行不同操作的，最近在回顾Node.js的一些用法，这里就尝试采用原生的方法重构一个路由功能。</p>
<p>原始路由方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> server=http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(req.url==<span class="string">&#x27;/index&#x27;</span>)&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;text/html;charset=UTF-8&#x27;</span>&#125;);</span><br><span class="line">    res.write(<span class="string">&#x27;&lt;h1&gt;这是首页&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.url==<span class="string">&#x27;/products&#x27;</span>)&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;text/html;charset=UTF-8&#x27;</span>&#125;);</span><br><span class="line">    res.write(<span class="string">&#x27;&lt;h1&gt;这是产品页&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.url==<span class="string">&#x27;/detail&#x27;</span>)&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;text/html;charset=UTF-8&#x27;</span>&#125;);</span><br><span class="line">    res.write(<span class="string">&#x27;&lt;h1&gt;这是详情页&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">404</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;text/html;charset=UTF-8&#x27;</span>&#125;);</span><br><span class="line">    res.write(<span class="string">&#x27;&lt;h1&gt;这是404页&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">  res.end(<span class="string">&#x27;欢迎来到NodeJs&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;开始监听3000端口&#x27;</span>)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这样的路由方法看似结构清晰，但实际情况比这复杂的多，有大量的路由和相应的页面响应方法，就会显得臃肿了。</p>
<p>其实，我们可以采用ES6的模块语法，使创建服务器、路由控制、地址处理方法执行分别处于不同模块，最终在一个入口文件中引入：</p>
<p>服务器模块:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">//1.http创建服务器并监听端口方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startServer</span>(<span class="params">route,handle</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> onRequest=<span class="function"><span class="keyword">function</span>(<span class="params">req,resp</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//路由处理</span></span><br><span class="line">    route(handle,req.url,resp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//http创建服务器</span></span><br><span class="line">  <span class="keyword">var</span> server= http.createServer(onRequest)</span><br><span class="line">  <span class="comment">//服务器监听3000端口</span></span><br><span class="line">  server.listen(<span class="number">3000</span>,<span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;运行在3000端口&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.导出路由模块</span></span><br><span class="line"><span class="built_in">module</span>.exports.startServer = startServer;</span><br></pre></td></tr></table></figure>

<p>地址处理方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//网站默认图标</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">favicon</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">  fs.createReadStream(__dirname +<span class="string">&#x27;/favicon.ico&#x27;</span>).pipe(resp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首页</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">  fs.createReadStream(__dirname +<span class="string">&#x27;/index.html&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).pipe(resp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品页</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">products</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">  fs.createReadStream(__dirname +<span class="string">&#x27;/products.html&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).pipe(resp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//详情页</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detail</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">  fs.createReadStream(__dirname +<span class="string">&#x27;/detail.html&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).pipe(resp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将不同页面的方法导出</span></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">  index:index,</span><br><span class="line">  products:products,</span><br><span class="line">  detail:detail,</span><br><span class="line">  favicon:favicon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路由模块:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//1.路由处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle,url,resp</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> handle[url] ===<span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    resp.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;text/html;charset=UTF-8&#x27;</span>&#125;);</span><br><span class="line">    handle[url](resp);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    resp.writeHead(<span class="number">404</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;text/html;charset=UTF-8&#x27;</span>&#125;);</span><br><span class="line">    fs.createReadStream(__dirname+<span class="string">&#x27;/404.html&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).pipe(resp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.route=route;</span><br></pre></td></tr></table></figure>

<p>入口app.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server=<span class="built_in">require</span>(<span class="string">&#x27;./server&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> router=<span class="built_in">require</span>(<span class="string">&#x27;./router&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> handler = <span class="built_in">require</span>(<span class="string">&#x27;./handler&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.匹配url地址,</span></span><br><span class="line"><span class="keyword">var</span> handle = &#123;&#125;;</span><br><span class="line">handle[<span class="string">&quot;/&quot;</span>] = handler.index;</span><br><span class="line">handle[<span class="string">&#x27;/index&#x27;</span>] = handler.index;</span><br><span class="line">handle[<span class="string">&#x27;/products&#x27;</span>] = handler.products;</span><br><span class="line">handle[<span class="string">&#x27;/detail&#x27;</span>] = handler.detail;</span><br><span class="line">handle[<span class="string">&#x27;/favicon.ico&#x27;</span>] = handler.favicon;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.启动服务器</span></span><br><span class="line">server.startServer(router.route,handle)</span><br></pre></td></tr></table></figure>

<p>这样如果增加路由页面，只需在相应的位置依次增加即可，结构清晰！</p>
<p>当使用GET或POST请求时，需要对服务器模块做一些更改:</p>
<ol>
<li>请求为GET时,解析路由地址’?’后面的query语句;</li>
<li>请求为POST时,监听数据流并解析;</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> queryString=<span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startServer</span>(<span class="params">route,handle</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> onRequest=<span class="function"><span class="keyword">function</span>(<span class="params">req,resp</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//url路径</span></span><br><span class="line">    <span class="keyword">var</span> pathName=url.parse(req.url).pathname;</span><br><span class="line">    <span class="comment">//请求为POST时,监听数据流</span></span><br><span class="line">    <span class="keyword">if</span>(req.method==<span class="string">&quot;POST&quot;</span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> data=<span class="string">&quot;&quot;</span>;</span><br><span class="line">      req.on(<span class="string">&#x27;error&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;).on(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        data+=chunk;</span><br><span class="line">      &#125;).on(<span class="string">&#x27;end&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> params=queryString.parse(data);</span><br><span class="line">      route(handle,pathName,resp,params);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//请求为GET时,解析路由query</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> params=url.parse(req.url,<span class="literal">true</span>).query;</span><br><span class="line">      route(handle,pathName,resp,params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> server= http.createServer(onRequest)</span><br><span class="line">  server.listen(<span class="number">3000</span>,<span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;运行在3000端口&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.startServer = startServer;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相应的，增加router和handler的传参。</p>
<p>详细代码：<a href="https://github.com/yifoo/Node/tree/master/Demo-web">Demo-web</a></p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node基础</title>
    <url>/2018/01/21/IT%E6%8A%80%E6%9C%AF/Node_%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="1-HTTP模块"><a href="#1-HTTP模块" class="headerlink" title="1.HTTP模块"></a>1.HTTP模块</h3><ul>
<li>http模块是创建HTTP协议的服务器端应用(代替Apache和php)——接受客户端请求,解析并处理请求,返回响应消息.</li>
<li>http模块还用于创建HTTP协议的客户端应用(模拟浏览器功能)——向其他的服务器发起请求，等待返回响应消息.</li>
</ul>
<p>Node.js中使用http模块创建服务器端应用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> server=http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//客户端请求消息 req.method/url/headers</span></span><br><span class="line">  <span class="comment">//服务器响应消息 res.write()/writeHead()/end</span></span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>);<span class="comment">//监听3000端口</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>eg:http模块请求不同url,响应不同消息主体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> server=http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;text/html;charset=UTF-8&#x27;</span>&#125;);</span><br><span class="line">  <span class="keyword">if</span>(req.url==<span class="string">&#x27;/index&#x27;</span>)&#123;</span><br><span class="line">    res.write(<span class="string">&#x27;&lt;h1&gt;这是首页&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.url==<span class="string">&#x27;/user/login&#x27;</span>)&#123;</span><br><span class="line">    res.write(<span class="string">&#x27;&lt;h1&gt;这是登录页&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.url==<span class="string">&#x27;/user/register&#x27;</span>)&#123;</span><br><span class="line">    res.write(<span class="string">&#x27;&lt;h1&gt;这是注册页&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(<span class="string">&#x27;欢迎来到NodeJs&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>);<span class="comment">//监听3000端口</span></span><br></pre></td></tr></table></figure>

<h3 id="2-fs模块"><a href="#2-fs模块" class="headerlink" title="2.fs模块"></a>2.fs模块</h3><ul>
<li>fs模块提供了文件的读写、更名、删除、遍历目录等操作。</li>
<li>fs模块中大多方法都带有同步和异步两种操作模式</li>
</ul>
<blockquote>
<p>1)异步方法的最后一个参数都是一个回调函数<br>2)传给回调函数的参数取决于具体方法,但回调函数的第一个参数是error异常,如果有异常,会静默失败,需要手动处理;<br>3)同步方法中任何异常都会被立即抛出,可以使用 try/catch 来处理异常，或让异常向上冒泡。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步方法</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.unlink(<span class="string">&#x27;/tmp/hello&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;<span class="comment">//有异常则抛出异常</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;成功删除 /tmp/hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步方法  方法名后+Sync</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.unlinkSync(<span class="string">&#x27;/tmp/hello&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;成功删除 /tmp/hello&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>2.1 判断文件是否存在<br>fs.stat方法:fs.stat(path, callback(err,stats))<br>第一个参数是path(路径),第二个参数是回调函数(第一个参数是异常error,第二个是统计信息描述对象)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.stat(<span class="string">&#x27;data.txt&#x27;</span>, <span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.code);</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(stats);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>2.2 文件路径转换<br>fs.realpath方法:fs.realpath(path[, options], callback(err,realpath)),将相对路径转为绝对路径</p>
<blockquote>
<p>在express中提供文件路径时用到</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.realpath(<span class="string">&#x27;./data.txt&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,resolvedPath</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//如果转换失败,则err中有值,否则为null</span></span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resolvedPath);<span class="comment">// e:\Github\Node\data.txt</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2.3 文件重命名<br>fs.rename方法:fs.rename(oldPath, newPath, callback(err))</p>
<p>2.4 文件读写<br>fs.readFile方法:fs.readFile(path[, options], callback(err,data))<br>fs.writeFile方法:fs.writeFile(file, data[, options], callback(err))</p>
<ul>
<li>options<blockquote>
<ul>
<li>encoding <string> | <null> 默认 = ‘utf8’<br>如果 data 是一个 buffer，则忽略 encoding 选项。它默认为 ‘utf8’.</li>
<li>mode <integer> 默认 = 0o666</li>
<li>flag <string> 默认 = ‘w’,表示”写”,flag==”a”,则为追加append</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.writeFile(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;Hello Node.js&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;The file has been saved!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">fs.writeFile(<span class="string">&#x27;message.txt&#x27;</span>, <span class="string">&#x27;Hello Node.js&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, callback);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多次对同一文件使用 fs.writeFile 且不等待回调，是不安全的。 对于这种情况，强烈推荐使用 fs.createWriteStream。</p>
</blockquote>
<p>2.5 读写流</p>
<ul>
<li><p>读取流</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rs=fs.createReadStream(<span class="string">&#x27;./data.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">rs.on(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123; <span class="comment">//每读取64kb执行data方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(chunk);</span><br><span class="line">  <span class="comment">//看字符串</span></span><br><span class="line">  <span class="comment">// console.log(chunk.toString());</span></span><br><span class="line">  temp+=chunk;<span class="comment">//拼接所有的数据</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//读取流完毕后执行end</span></span><br><span class="line">rs.on(<span class="string">&#x27;end&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(temp);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>写入流</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rs=fs.createReadStream(<span class="string">&#x27;./data.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ws=fs.createWriteStream(<span class="string">&#x27;./data_bak.txt&#x27;</span>);</span><br><span class="line">rs.on(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">  ws.write(chunk);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pipe方法写入数据时,会等当前读出的数据全部写入后,才进行下一次的读取操作,内存利用充分,当时读取时间比较长</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rs=fs.createReadStream(<span class="string">&#x27;./data.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ws=fs.createWriteStream(<span class="string">&#x27;./data_bak.txt&#x27;</span>);</span><br><span class="line">rs.pipe(ws)</span><br></pre></td></tr></table></figure>

<h3 id="3-http第三方模块express"><a href="#3-http第三方模块express" class="headerlink" title="3.http第三方模块express"></a>3.http第三方模块express</h3><ul>
<li>使用步骤：<br> 1.安装<br>  2.使用http模块创建Web服务器，运行express，让其承担请求监听器的任务<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">http.createServer( app ).listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>3.为app对象添加特定URL的请求处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/user&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;     </span><br><span class="line">  <span class="comment">//接收请求消息中的数据</span></span><br><span class="line">  req.query   <span class="comment">//获取查询字符串中的数据&#123; &#125;</span></span><br><span class="line">  req.params  <span class="comment">//获取请求参数(手册自学)</span></span><br><span class="line">  req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">buf</span>)</span>&#123;&#125;)  <span class="comment">//获取请求主体中的数据</span></span><br><span class="line">  <span class="comment">//发送响应消息</span></span><br><span class="line">  res.send(HTML文本);</span><br><span class="line">  res.sendFile(任意类型的文件);</span><br><span class="line">  res.json(对象/数组数据);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>3.1 路由<br>路由，针对客户端的某个请求方法所请求的特定URL，如何给出响应消息的过程，称为“路由”<br>路由 = 请求方法 + 请求URL + 处理函数<br>一个典型的路由形如：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/user&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;     </span><br><span class="line">  <span class="comment">//接收请求消息中的数据</span></span><br><span class="line">  req.query   <span class="comment">//获取查询字符串中的数据&#123; &#125;</span></span><br><span class="line">  req.params  <span class="comment">//获取请求参数(手册自学)</span></span><br><span class="line">  req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">buf</span>)</span>&#123;&#125;)  <span class="comment">//获取请求主体中的数据</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送响应消息</span></span><br><span class="line">  res.send(HTML文本);</span><br><span class="line">  res.sendFile(任意类型的文件);</span><br><span class="line">  res.json(对象/数组数据);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>express.Router</strong></p>
<blockquote>
<p>在 app 目录下创建名为 birds.js 的文件，内容如下：<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该路由使用的中间件</span></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span> <span class="title">timeLog</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Time: &#x27;</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义网站主页的路由</span></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&#x27;Birds home page&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义 about 页面的路由</span></span><br><span class="line">router.get(<span class="string">&#x27;/about&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&#x27;About birds&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><br>然后在应用中加载路由模块：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> birds = <span class="built_in">require</span>(<span class="string">&#x27;./birds&#x27;</span>);</span><br><span class="line">...</span><br><span class="line">app.use(<span class="string">&#x27;/birds&#x27;</span>, birds);</span><br></pre></td></tr></table></figure>
<p>应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。</p>
<ul>
<li>3.2 中间件<br>中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。<br>功能:<br>(1)执行任何代码。<br>(2)修改请求和响应对象。<br>(3)终结请求-响应循环。<br>(4)调用堆栈中的下一个中间件。<br><img src="https://haohome.top/18-1-18/39090586.jpg" alt="中间件"></li>
</ul>
<blockquote>
<p>如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。</p>
</blockquote>
<ul>
<li>应用级中间件<br>应用级中间件绑定到app对象使用app.use()和app.METHOD(),其中，METHOD是需要处理的HTTP请求的方法，例如GET,PUT,POST等等全部小写。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">// 没有挂载路径的中间件，应用的每个请求都会执行该中间件</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Time:&#x27;</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它</span></span><br><span class="line">app.use(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Request Type:&#x27;</span>, req.method);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求</span></span><br><span class="line">app.get(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&#x27;USER&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>3.2.1 在一个挂载点装载一组中间件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息</span></span><br><span class="line">app.use(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Request URL:&#x27;</span>, req.originalUrl);</span><br><span class="line">  next();</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Request Type:&#x27;</span>, req.method);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>3.2.2 下例为指向 /user/:id 的 GET 请求定义了两个路由,但第一个路由终止了请求-响应循环,第二个路由不会被执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个中间件栈，处理指向 /user/:id 的 GET 请求</span></span><br><span class="line">app.get(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ID:&#x27;</span>, req.params.id);</span><br><span class="line">  next();</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&#x27;User Info&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 处理 /user/:id， 打印出用户 id</span></span><br><span class="line">app.get(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.end(req.params.id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>3.2.3 如果需要在中间件栈中跳过剩余中间件，调用next(‘route’)方法将控制权交给下一个路由</p>
<blockquote>
<p>注意：next(‘route’)只对使用app.VERB()或router.VERB()加载的中间件有效。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个中间件栈，处理指向 /user/:id 的 GET 请求</span></span><br><span class="line">app.get(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果 user id 为 0, 跳到下一个路由</span></span><br><span class="line">  <span class="keyword">if</span> (req.params.id == <span class="number">0</span>) next(<span class="string">&#x27;route&#x27;</span>);</span><br><span class="line">  <span class="comment">// 否则将控制权交给栈中下一个中间件</span></span><br><span class="line">  <span class="keyword">else</span> next(); <span class="comment">//</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 渲染常规页面</span></span><br><span class="line">  res.render(<span class="string">&#x27;regular&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 /user/:id， 渲染一个特殊页面</span></span><br><span class="line">app.get(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">&#x27;special&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>路由级中间件 使用方法与应用级中间件类似</p>
<blockquote>
<p>var router = express.Router();</p>
</blockquote>
</li>
<li><p>错误处理中间件<br> 错误处理中间件有4个参数，定义错误处理中间件时必须使用这4个参数。即使不需要next对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.stack);</span><br><span class="line">  res.status(<span class="number">500</span>).send(<span class="string">&#x27;Something broke!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 项目中常用的中间件</p>
</li>
</ul>
<ul>
<li><p>(1)向客户端返回指定目录下的所有静态资源文件<br>  <code>app.use(express.static(&#39;./public&#39;));</code></p>
</li>
<li><p>(2)将客户端POST请求主体中的数据封装到req.body中</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm  i  body-parser</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line">app.use( bodyParser.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">false</span>&#125;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>(3)将请求头部中的Cookie数据封装到req.cookies中</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm   i   cookie-parser</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>);</span><br><span class="line">app.use(cookieParser());  </span><br></pre></td></tr></table></figure>
</li>
<li><p>(4)解决跨域问题cors</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use( cors(&#123;</span><br><span class="line">    origin: [<span class="string">&quot;http://127.0.0.1&quot;</span>, <span class="string">&quot;http://localhost:8080&quot;</span>],</span><br><span class="line">    credentials: <span class="literal">true</span></span><br><span class="line">&#125;) );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置cors:</p>
</blockquote>
</li>
</ul>
<pre><code> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"><span class="keyword">var</span> corsOptions = &#123; <span class="comment">//配置跨域选项 </span></span><br><span class="line">  origin: <span class="string">&#x27;http://example.com&#x27;</span>,</span><br><span class="line">  optionsSuccessStatus: <span class="number">200</span> <span class="comment">// some legacy browsers (IE11, various SmartTVs) choke on 204 </span></span><br><span class="line">&#125;</span><br><span class="line"> app.get(<span class="string">&#x27;/products/:id&#x27;</span>, cors(corsOptions), <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.json(&#123;<span class="attr">msg</span>: <span class="string">&#x27;跨域仅限域名:example.com.&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"> app.listen(<span class="number">80</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;80端口服务器可以跨域&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex入门基础</title>
    <url>/2018/05/14/IT%E6%8A%80%E6%9C%AF/Vuex%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1-Vuex-概念"><a href="#1-Vuex-概念" class="headerlink" title="1. Vuex 概念"></a>1. Vuex 概念</h2><p>Vuex 是一个<strong>状态管理模式</strong>,它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<p>每一个 Vuex 应用的核心就是 store(仓库)，在store中包含组件中的共享<strong>状态</strong><code>state</code>和改变状态的<strong>方法</strong><code>mutations</code>。</p>
<p><strong>store仓库</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>Vuex 的状态存储是响应式的</li>
<li>不能直接改变 store 中的状态,需显式地<strong>提交 (commit) mutation</strong></li>
</ol>
</blockquote>
<a id="more"></a>

<h2 id="2-State单一状态树"><a href="#2-State单一状态树" class="headerlink" title="2. State单一状态树"></a>2. State单一状态树</h2><p>用一个对象包含全部的应用层级状态</p>
<p>Vuex 通过 <code>store</code> 选项，将状态从根组件“注入”到每一个子组件中,子组件需调用 <code>Vue.use(Vuex)</code>：</p>
<p>根组件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根组件:</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store, <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>子组件: 通过<code>computed</code>(计算属性)返回<code>this.$store.state.count</code>来获取相应数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count	<span class="comment">//获取根组件的state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h3><p>简化生成计算属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    computed: mapState (&#123;</span><br><span class="line">        count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line">        countAlias: <span class="string">&#x27;count&#x27;</span>,    <span class="comment">// 别名 `count` 等价于 state =&gt; state.count</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以更简化:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">&#x27;count&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h2 id="3-Getter-从-store-中的-state-派生出状态"><a href="#3-Getter-从-store-中的-state-派生出状态" class="headerlink" title="3. Getter 从 store 中的 state 派生出状态"></a>3. Getter 从 store 中的 state 派生出状态</h2><p>如果我们需要对<code>state</code>对象进行做处理计算，如对列表进行过滤并计数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    doneTodosCount () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果多个组件都要进行这样的处理，那么就要在多个组件中复制该函数,这样效率低下。</p>
<p>Vuex中<code>getters</code>对象，可以方便我们在<code>store</code>中做集中的处理,Getters接受<code>state</code>作为第一个参数：:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Getter 会暴露为 <code>store.getters</code> 对象，可以以属性的形式访问这些值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123; id: 1, text: &#x27;...&#x27;, done: true &#125;]</span></span><br></pre></td></tr></table></figure>

<p>Getter 也可以接受其他 getter 作为第二个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.getters.doneTodosCount <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>

<h3 id="mapGetters辅助函数"><a href="#mapGetters辅助函数" class="headerlink" title="mapGetters辅助函数"></a>mapGetters辅助函数</h3><p>与<code>mapState</code>类似，都能达到简化代码的效果<br><code>mapGetters</code>辅助函数仅仅是将store中的getters映射到局部计算属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 使用对象展开运算符将 getters 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可写作:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed: mapGetters([</span><br><span class="line">    <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>所以在Vue的<code>computed</code>计算属性中会存在两种辅助函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState, mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    computed: &#123;</span><br><span class="line">        mapState(&#123; ... &#125;),</span><br><span class="line">        mapGetter(&#123; ... &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Mutation-更改-Vuex-的-store-中的状态"><a href="#4-Mutation-更改-Vuex-的-store-中的状态" class="headerlink" title="4. Mutation 更改 Vuex 的 store 中的状态"></a>4. Mutation 更改 Vuex 的 store 中的状态</h2><p>每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;	<span class="comment">//type:&#x27;increment&#x27;</span></span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>要唤醒一个 mutation handler，你需要调用 <strong>store.commit</strong> 方法调用<code>mutation type</code>: <code>store.commit(&#39;increment&#39;)</code></p>
<h3 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h3><p> 向 <code>store.commit</code> 传入第二个参数,也就是mutation的<code>payload</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>单单传入一个<code>n</code>，可能并不能满足我们的业务需要，这时候我们可以选择传入一个<code>payload</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mutation: &#123;</span><br><span class="line">    increment (state, payload) &#123;</span><br><span class="line">        state.totalPrice += payload.price + payload.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h3><p>提交 mutation 的另一种方式是直接使用包含 <code>type</code> 属性的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">&#x27;increment&#x27;</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="mapMutations函数"><a href="#mapMutations函数" class="headerlink" title="mapMutations函数"></a>mapMutations函数</h3><p>使用<code>mapMutations</code>辅助函数将组件中的<code>methods</code>映射为<code>store.commit</code>调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 映射 this.increment() 为 this.$store.commit(&#x27;increment&#x27;)</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 映射 this.add() 为 this.$store.commit(&#x27;increment&#x27;)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Action"><a href="#5-Action" class="headerlink" title="5.Action"></a>5.Action</h2><ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
<p>在vuex中,mutation是同步事件:<code>store.commit(&#39;increment&#39;)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p>
<h3 id="分发Action"><a href="#分发Action" class="headerlink" title="分发Action"></a>分发Action</h3><p>Action 通过 <code>store.dispatch</code> 方法触发：<code>store.dispatch(&#39;increment&#39;)</code>;</p>
<p>Actions 支持同样的载荷方式和对象方式进行分发：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">&#x27;incrementAsync&#x27;</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">&#x27;incrementAsync&#x27;</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="在组件中分发Action"><a href="#在组件中分发Action" class="headerlink" title="在组件中分发Action"></a>在组件中分发Action</h3><p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h3><p>Action 通常是异步的，如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>
<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">&#x27;someMutation&#x27;</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在另外一个 action 中也可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">&#x27;someOtherMutation&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们利用 <a href="https://tc39.github.io/ecmascript-asyncawait/">async / await</a>，我们可以如下组合 action：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">&#x27;gotData&#x27;</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">&#x27;gotOtherData&#x27;</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>
</blockquote>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue实现简单分页功能</title>
    <url>/2018/01/21/IT%E6%8A%80%E6%9C%AF/Vue%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>分页功能在列表查询中是一个比较重要的组成部分,按结构划分可分为页码与上一页/下一页:</p>
<ul>
<li><p>页码:通过点击数字,并将页码数字传递到后台查询获取相应的页码内容</p>
</li>
<li><p>上一页/下一页:可以共用一个方法,利用不同参数识别,查询数据逻辑与页码类似;</p>
</li>
</ul>
<blockquote>
<p>页面显示页码:可以采用计算属性computed获得</p>
</blockquote>
<p>下面的案例是我从自己的vue项目中摘取出来:</p>
<a id="more"></a>

<ul>
<li><p>实现分页的CSS部分</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.pages</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pages</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#999</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pages</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="number">#f8b551</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#f8b551</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pages</span> <span class="selector-tag">a</span><span class="selector-class">.cur</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="number">#f8b551</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f8b551</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pages</span> <span class="selector-tag">a</span><span class="selector-class">.default</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现分页的template</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pages&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.self.prevent</span>=<span class="string">&quot;togglePage(-1)&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;default:pno&lt;=1&#125;&quot;</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-for</span>=<span class="string">&quot;(temp,key) in realPage&quot;</span> <span class="attr">:key</span>=<span class="string">key</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;cur:pno==temp&#125;&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.self.prevent</span>=<span class="string">&quot;changePage(temp)&quot;</span>&gt;</span>&#123;&#123;temp&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.self.prevent</span>=<span class="string">&quot;togglePage(1)&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;default:pno&gt;=pageCount&#125;&quot;</span>&gt;</span>下一页	<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--利用事件修饰符 @click.self.prevent阻止对元素自身的点击。--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现分页的Js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  data ()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      newsList:[],</span><br><span class="line">      pno:<span class="number">1</span>,</span><br><span class="line">      pageCount:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.getList()  <span class="comment">//挂载的时候获取新闻列表</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">getList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> self=<span class="built_in">this</span>;</span><br><span class="line">      self.$axios(&#123;</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        baseURL:<span class="string">&#x27;http://127.0.0.1:3000/&#x27;</span>,</span><br><span class="line">        url: <span class="string">&#x27;/news/list/&#x27;</span>+self.pno,</span><br><span class="line">        withCredentials: <span class="literal">true</span>,</span><br><span class="line">        responseType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">        transformResponse:<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">          self.newsList=response.data;</span><br><span class="line">          self.pageCount=response.pageCount;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 点击页面切换</span></span><br><span class="line">    <span class="function"><span class="title">changePage</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> self=<span class="built_in">this</span>;</span><br><span class="line">      self.pno=index;</span><br><span class="line">      self.$axios(&#123;</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        baseURL:<span class="string">&#x27;http://127.0.0.1:3000/&#x27;</span>,</span><br><span class="line">        url: <span class="string">&#x27;/news/list/&#x27;</span>+self.pno,</span><br><span class="line">        withCredentials: <span class="literal">true</span>,</span><br><span class="line">        responseType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">        transformResponse:<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">          self.newsList=response.data;</span><br><span class="line">          self.pageCount=response.pageCount;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//点击上一页/下一页事件</span></span><br><span class="line">    <span class="function"><span class="title">togglePage</span>(<span class="params">index</span>)</span>&#123;<span class="comment">//通过对index赋值来识别按钮</span></span><br><span class="line">      <span class="keyword">var</span> self=<span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">if</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.pno&gt;=self.pageCount)<span class="keyword">return</span>;</span><br><span class="line">        self.pno++;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.pno&lt;=<span class="number">1</span>)<span class="keyword">return</span></span><br><span class="line">        self.pno--;</span><br><span class="line">      &#125;</span><br><span class="line">      self.$axios(&#123;</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        baseURL:<span class="string">&#x27;http://127.0.0.1:3000/&#x27;</span>,</span><br><span class="line">        url: <span class="string">&#x27;/news/list/&#x27;</span>+self.pno,</span><br><span class="line">        withCredentials: <span class="literal">true</span>,</span><br><span class="line">        responseType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">        transformResponse:<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">          self.newsList=response.data;</span><br><span class="line">          self.pageCount=response.pageCount;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed :&#123;  <span class="comment">//vue内置的计算属性,可以直接使用realPage,相当于java的getter方法</span></span><br><span class="line">    realPage:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> left=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> right=<span class="built_in">this</span>.pageCount;</span><br><span class="line">      <span class="keyword">var</span> realCount=[];<span class="comment">//当前可显示的页码数组,如[4,5,6]</span></span><br><span class="line">      <span class="keyword">if</span>(right&gt;=<span class="number">3</span>)&#123;<span class="comment">//控制最多显示3页</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.pno&gt;<span class="number">1</span> &amp;&amp; <span class="built_in">this</span>.pno+<span class="number">1</span>&lt;<span class="built_in">this</span>.pageCount)&#123;</span><br><span class="line">          left=<span class="built_in">this</span>.pno-<span class="number">1</span>;</span><br><span class="line">          right=<span class="built_in">this</span>.pno+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">this</span>.pno&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">          left=<span class="number">1</span>;</span><br><span class="line">          right=<span class="number">3</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           left=<span class="built_in">this</span>.pageCount-<span class="number">2</span>;</span><br><span class="line">           right=<span class="built_in">this</span>.pageCount;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(left&lt;=right)&#123; <span class="comment">//通过循环将当前可显示的页码存到realCount数组中</span></span><br><span class="line">        realCount.push(left);</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> realCount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当页面发生变化,如果需要通知其他组件做出相应变化,可以再增加watch监听页面变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  pno: <span class="function"><span class="keyword">function</span>(<span class="params">newValue,oldValue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的CSS作用域问题</title>
    <url>/2018/02/12/IT%E6%8A%80%E6%9C%AF/Vue%E7%9A%84CSS%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-CSS-作用域问题"><a href="#1-CSS-作用域问题" class="headerlink" title="1. CSS 作用域问题"></a>1. CSS 作用域问题</h3><h4 id="1-1-style标签增加scoped属性"><a href="#1-1-style标签增加scoped属性" class="headerlink" title="1.1 style标签增加scoped属性"></a>1.1 style标签增加scoped属性</h4><p>CSS 只作用于当前组件中的元素,类似于 Shadow DOM 中的样式封装。</p>
<blockquote>
<p>原理: 通过使用 PostCSS 来实现转换</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.example</span> &#123;</span></span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>转换结果:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.example</span><span class="selector-attr">[data-v-f3f3eg9]</span> &#123;</span></span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span> <span class="attr">data-v-f3f3eg9</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="1-2-混用本地和全局样式"><a href="#1-2-混用本地和全局样式" class="headerlink" title="1.2 混用本地和全局样式"></a>1.2 混用本地和全局样式</h4><p>Vue中可以在一个组件中同时使用有作用域和无作用域的样式:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/* 全局样式 */</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/* 本地样式 */</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-子组件的根元素"><a href="#1-3-子组件的根元素" class="headerlink" title="1.3 子组件的根元素"></a>1.3 子组件的根元素</h4><p>子组件使用了scoped后,父组件的样式不会渗透到子组件中,不过子组件的根节点会同时受到父组件和子组件的css影响</p>
<blockquote>
<p>设计目的：为了父组件可以从布局角度出发,调整其子组件根元素的样式</p>
</blockquote>
<h4 id="1-4深度作用选择器"><a href="#1-4深度作用选择器" class="headerlink" title="1.4深度作用选择器"></a>1.4深度作用选择器</h4><p>如果希望scoped样式中的某个样式作用的更深,如影响子组件,可以使用<code>&gt;&gt;&gt;</code>操作符:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.a</span> &gt;&gt;&gt; <span class="selector-class">.b</span> &#123; <span class="comment">/* ... */</span> &#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 解析成:  .a[data-v-f3f3eg9] .b &#123; /* ... */ &#125; --&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>有些像 SASS 之类的预处理器无法正确解析 <code>&gt;&gt;&gt;</code>。这种情况下你可以使用 <code>/deep/</code> 操作符取而代之——这是一个 <code>&gt;&gt;&gt;</code>的别名，同样可以正常工作。</p>
</blockquote>
<h4 id="1-5动态生成的内容"><a href="#1-5动态生成的内容" class="headerlink" title="1.5动态生成的内容"></a>1.5动态生成的内容</h4><p>通过 <code>v-html</code> 创建的 DOM 内容不受作用域内的样式影响，但仍然可以通过深度作用选择器来为他们设置样式。</p>
<h3 id="2-CSS-Modules"><a href="#2-CSS-Modules" class="headerlink" title="2. CSS Modules"></a>2. CSS Modules</h3><h4 id="2-1-使用"><a href="#2-1-使用" class="headerlink" title="2.1 使用"></a>2.1 使用</h4><p>CSS Modules是一个用于模块化和组合 CSS 的流行系统。</p>
<p> 在<code>&lt;style&gt;</code> 上添加 <code>module</code> 属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">module</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.red</span> &#123;</span></span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.bold</span> &#123;</span></span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这将为 <code>css-loader</code> 打开 CSS Modules 模式，生成的 CSS 对象将为组件注入一个名叫 <code>$style</code> 的计算属性，可以在模块中使用动态 class 绑定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;$style.red&quot;</span>&gt;</span></span><br><span class="line">    This should be red</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于具有computed属性,也适用于<code>:class</code> 的 object/array 语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; [$style.red]: isRed &#125;&quot;</span>&gt;</span></span><br><span class="line">      Am I red?</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;[$style.red, $style.bold]&quot;</span>&gt;</span></span><br><span class="line">      Red and bold</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以在 JavaScript 访问它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$style.red)</span><br><span class="line">    <span class="comment">// -&gt; &quot;_1VyoJ-uZOjlOxP7jWUy19_0&quot;</span></span><br><span class="line">    <span class="comment">// an identifier generated based on filename and className.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-自定义注入名称"><a href="#2-2-自定义注入名称" class="headerlink" title="2.2 自定义注入名称"></a>2.2 自定义注入名称</h4><p>在 <code>.vue</code> 中你可以定义不止一个 <code>&lt;style&gt;</code>，为了避免被覆盖，可以通过设置 <code>module</code> 属性来为它们定义注入后计算属性的名称。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">module</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/* identifiers injected as a */</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">module</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/* identifiers injected as b */</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的点赞效果</title>
    <url>/2018/02/14/IT%E6%8A%80%E6%9C%AF/Vue%E7%9A%84%E7%82%B9%E8%B5%9E%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h3 id="1-原生-利用CSS3-Animation-实现"><a href="#1-原生-利用CSS3-Animation-实现" class="headerlink" title="1. 原生: 利用CSS3 Animation 实现"></a>1. 原生: 利用CSS3 Animation 实现</h3><p>animation的动画效果通常是连贯性的，简单的说就是线性渐变的动画。但有些效果不需要连贯性，只需要关键帧之间的跳跃，这时应该使用<code>steps</code> 过渡方式，称之为帧动画。</p>
<p>比较知名的Twitter点赞功能就是采用steps方式：</p>
<p>HTML</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;heart&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>CSS</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.heart</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(heart.png);</span><br><span class="line">  <span class="attribute">background-size</span>: auto <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">:active</span> &#123; <span class="comment">/*当鼠标点击激活时执行动画效果*/</span></span><br><span class="line">  <span class="attribute">transition</span>: background <span class="number">1s</span> <span class="built_in">steps</span>(<span class="number">28</span>); </span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">140rem</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://haohome.top/18-2-14/71551117.jpg" alt="点赞"></p>
<a id="more"></a>

<p>transition的简写方式为:</p>
<p><strong>transition:</strong> property duration timing-function delay</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">transition-property</td>
<td align="center">设置过渡效果的 CSS 属性的名称。</td>
</tr>
<tr>
<td align="center">transition-duration</td>
<td align="center">完成过渡效果需要多少秒或毫秒。</td>
</tr>
<tr>
<td align="center">transition-timing-function</td>
<td align="center">速度效果的速度曲线。</td>
</tr>
<tr>
<td align="center">transition-delay</td>
<td align="center">定义过渡效果何时开始。</td>
</tr>
</tbody></table>
<p>上面的CSS动画效果等同于:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">:active</span>&#123;</span><br><span class="line">  <span class="attribute">animation </span>: heartBlast <span class="number">1s</span> <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>:<span class="built_in">steps</span>(<span class="number">28</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> heartBlast &#123;</span><br><span class="line">  0% &#123;<span class="attribute">background-position</span>: left;&#125;</span><br><span class="line">  100% &#123;<span class="attribute">background-position</span>: right;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逐帧播放红心背景图片达到实现效果</p>
<h3 id="2-Vue的实现方法"><a href="#2-Vue的实现方法" class="headerlink" title="2. Vue的实现方法"></a>2. Vue的实现方法</h3><p>与原生DOM不同的是,vue是一个以数据驱动的框架,可以直接在html上直接绑定相关事件或属性</p>
<p>template</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;i class&#x3D;&quot;heart&quot; :style&#x3D;&quot;star&quot; :class&#x3D;&quot;&#123;hover:parseInt(item.isHover)&#125;&quot; @click&#x3D;&quot;heart(item)&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">&lt;!--item是v-for循环中的某个子项,有pid&#x2F;isHover&#x2F;count等属性--&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过绑定设置元素背景图片,双向绑定css类hover,通过点击事件heart控制hover类显示以及点赞数量count变化</p>
</blockquote>
<p>script</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name:<span class="string">&#x27;MainBox&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      star:&#123;</span><br><span class="line">        backgroundImage:<span class="string">&#x27;url(&#x27;</span> + <span class="built_in">require</span>(<span class="string">&#x27;../../assets/img/web_heart_animation.png&#x27;</span>) + <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      isHover:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    <span class="function"><span class="title">updateCount</span>(<span class="params">pid,count</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">        url:<span class="string">&#x27;/updateCarrousel.php&#x27;</span>,</span><br><span class="line">        baseURL: <span class="string">&#x27;http://www.haohome.top/yx/data&#x27;</span>,</span><br><span class="line">        methods:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        params:&#123;<span class="attr">pid</span>:pid,<span class="attr">count</span>:count&#125;, <span class="comment">//pid:当前id,count:当前id已点赞数量</span></span><br><span class="line">        responseType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">        transformResponse:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">var</span> code=data.code;</span><br><span class="line">          <span class="keyword">if</span>(code)&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;点赞成功&quot;</span>);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;点赞失败&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">heart</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(item.isHover==<span class="string">&quot;0&quot;</span>)&#123;</span><br><span class="line">        item.isHover=<span class="string">&quot;1&quot;</span>,			<span class="comment">//点赞动画class:hover绑定</span></span><br><span class="line">        item.count++;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        item.isHover=<span class="string">&quot;0&quot;</span></span><br><span class="line">        item.count--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.updateCount(item.pid,item.count)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>style</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.heart</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: auto <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-class">.hover</span> &#123; </span><br><span class="line">  <span class="attribute">transition</span>: background <span class="number">1s</span> <span class="built_in">steps</span>(<span class="number">28</span>); </span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">140rem</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://haohome.top/18-2-14/71807336.jpg" alt="vue点赞"></p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目总结</title>
    <url>/2018/10/31/IT%E6%8A%80%E6%9C%AF/Vue%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>最近做了一个内嵌在APP的H5项目,起初是准备自己选择vue框架和UI库搭建项目框架,后来发现已经有项目组采用了一个muse-ui库.为了APP的页面整体统一性,我只好clone了小伙伴的项目,在其基础上继续开发.</p>
<p>项目开发过程中遇到了不少坑,这个迭代开发结束就来逐步总结下.</p>
<a id="more"></a>

<p>闲话不多说,开始正题:</p>
<h2 id="2-关于muse-ui"><a href="#2-关于muse-ui" class="headerlink" title="2. 关于muse-ui"></a>2. 关于muse-ui</h2><p>这个框架采用material风格,对vue的支持就很友好,图标也是Google官方推荐的<code>Material Icons</code>字体包,用起来也很方便。官方有详细的安装介绍,<code>import</code>后采用<code>Vue.use()</code>即可:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> MuseUI <span class="keyword">from</span> <span class="string">&#x27;muse-ui&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;muse-ui/dist/muse-ui.css&#x27;</span></span><br><span class="line">Vue.use(MuseUI)</span><br></pre></td></tr></table></figure>

<p>我们的项目采用的是muse2.1版本,官方现在已经是3.0版本的了,2.1版本的API文档写的不是详细,所以当遇到坑时就头疼了.</p>
<h2 id="3-基于muse-ui封装表单组件"><a href="#3-基于muse-ui封装表单组件" class="headerlink" title="3. 基于muse-ui封装表单组件"></a>3. 基于muse-ui封装表单组件</h2><p>由于我们项目此次主要是表单,里面有大量的<code>input</code>、<code>textarea</code>、<code>select</code>等表单的应用场景,我们选择了对muse-ui表单组件进行二次封装,以利于ui组件适用于本项目移动端的样式,同时表单组件可随处复用。</p>
<h4 id="3-1-组件数据双向绑定v-model"><a href="#3-1-组件数据双向绑定v-model" class="headerlink" title="3.1 组件数据双向绑定v-model"></a>3.1 组件数据双向绑定v-model</h4><p>数据双向绑定是vue中比较实用的一个功能,如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;formInput&#x27;</span>, &#123;</span><br><span class="line">   data:&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">      val:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;input v-model=&#x27;val&#x27;&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而在父组件中,如何去实现实时获取子组件<code>formInput</code>的<code>value</code>呢?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;parent&#x27;</span>,&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">        	inputVal:<span class="string">&quot;&quot;</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`&lt;form-input v-model=&quot;inputVal&quot;&gt;&lt;/form-input&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>vue的父子组件传递有一个口诀:<code>props down,events up</code>即父组件通过<code>props</code>向子组件传值,子组件通过<code>evens</code>向父组件传值,另外在官方文档中有这样的介绍:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input v-model&#x3D;&quot;searchText&quot;&gt;</span><br><span class="line">&lt;!-- 等价于 --&gt;</span><br><span class="line">&lt;input</span><br><span class="line">  v-bind:value&#x3D;&quot;searchText&quot;</span><br><span class="line">  v-on:input&#x3D;&quot;searchText &#x3D; $event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>当用在组件上时:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value&#x3D;&quot;searchText&quot;</span><br><span class="line">  v-on:input&#x3D;&quot;searchText &#x3D; $event&quot;&gt;</span><br><span class="line">&lt;&#x2F;custom-input&gt;</span><br><span class="line">即</span><br><span class="line">&lt;custom-input v-model&#x3D;&quot;searchText&quot;&gt;&lt;&#x2F;custom-input&gt;</span><br></pre></td></tr></table></figure>

<p>为了能正常传值,组件内的 <code>&lt;input&gt;</code> 必须：</p>
<ul>
<li>将其 <code>value</code> 特性绑定到一个名叫 <code>value</code> 的 prop 上</li>
<li>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>input</code> 事件抛出</li>
</ul>
<p>这段相当于让自定义组件通过<code>input</code>事件触发父组件的自定义事件,并传值给父组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;custom-input&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样就能达到我们想要的目的了.</p>
<p>在单选框和复选框这类可能会将<code>value</code>用作不同的特性,vue提供了另一种方式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;base-checkbox&#x27;</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">&#x27;checked&#x27;</span>,</span><br><span class="line">    event: <span class="string">&#x27;change&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type=&quot;checkbox&quot;</span></span><br><span class="line"><span class="string">      v-bind:checked=&quot;checked&quot;</span></span><br><span class="line"><span class="string">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 组件上</span></span><br><span class="line">&lt;base-checkbox v-model=<span class="string">&quot;lovingVue&quot;</span>&gt;&lt;/base-checkbox&gt;</span><br><span class="line"><span class="comment">// lovingVue 的值将会传入这个名为 checked 的 prop</span></span><br><span class="line"><span class="comment">// ! 需要在组件的 props 选项里声明 checked 这个 prop。</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-列表遍历v-for删除指定元素"><a href="#3-2-列表遍历v-for删除指定元素" class="headerlink" title="3.2 列表遍历v-for删除指定元素"></a>3.2 列表遍历v-for删除指定元素</h4><p>有时数组列表渲染我们比较喜欢采用数组本身的下标索引作为v-for绑定的key值如:</p>
<iframe width="100%" height="300" src="//jsrun.net/jqXKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>在做图片上传的时候,需要添加上传进度和删除图片,彼此间互不干扰,这就需要每个组件都需要具备独立的功能:</p>
<blockquote>
<ul>
<li>图片预览</li>
<li>图片自动压缩</li>
<li>图片上传</li>
<li>上传进度动态展示</li>
<li>删除图片</li>
<li>上传失败错误图标</li>
<li>点击错误图标重传</li>
</ul>
</blockquote>
<p>我写了两个组件,一个是图片<code>single</code>组件,一个是图片<code>list</code>组件,在实际运行的时候发现,删除某一张图片会自动删除最后一张图片,通过<code>console.log</code>控制台打印索引<code>index</code>,删除的索引是正确的,百思不得其解!最后百度才发现问题出在了循环<code>v-for</code>的<code>:key</code>上了</p>
<p>为方便理解,先举个例子:</p>
<iframe width="100%" height="300" src="//jsrun.net/z8hKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p><code>single</code>图片组件具备了上述功能,选择一个图片后在<code>list</code>组件及时<code>push</code>一个图片的对象<code>this.arr.push(item)</code>,这样页面就能通过<code>v-for</code>动态渲染,但使用后发现直接删除<code>arr</code>某个元素就只会删除集合最后一个元素.</p>
<p>这是由于列表的生成是通过绑定的arr数组来生成的，当arr删除掉一项时，列表的dom对象自然也会减少一项。但是由于v-for循环的是子组件，子组件内部显示数据并未绑定arr数组里的属性，因此子组件的显示数据并未按新数组重新渲染，体现出来的结果就是最后一个元素被删掉了</p>
<p>针对<code>arr</code>添加唯一性的索引就能解决这个问题,<code>this.arr.push(&#123; id: this.id, data: item &#125;);</code>,将<code>:key</code>绑定到<code>id</code></p>
<blockquote>
<p>由于v-for循环的是子组件，子组件内部显示数据并未绑定fileList数组里的属性,子组件的显示数据并未按新数组重新渲染,<strong>体现出来的结果</strong>就是最后一个元素被删掉了。</p>
</blockquote>
<h2 id="4-移动端拍照图片压缩上传"><a href="#4-移动端拍照图片压缩上传" class="headerlink" title="4. 移动端拍照图片压缩上传"></a>4. 移动端拍照图片压缩上传</h2><p>移动端图片上传存在两个问题:</p>
<ol>
<li><p>图片压缩</p>
<p>当前手机拍出来的照片像素高、尺寸大，而且使用 base64 编码的照片会比原照片大，用 canvas 来渲染这照片的速度会相对比较慢，那么上传的时候进行压缩就非常有必要的</p>
<p>图片压缩可以有两个阶段可以控制：</p>
<ul>
<li>控制<code>canvas</code>画布大小</li>
<li><code>canvas</code>转<code>blob</code>对象或<code>base64</code>,控制质量比例</li>
</ul>
<p><strong>Tips:</strong></p>
<p>1.1 <code>canvas</code>转<code>blob</code>对象:<code>canvas.toBlob(callback, type, radio)</code></p>
<blockquote>
<p> callback: 回调函数，可获得一个单独的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a>对象参数<br> type: 指定图片格式，默认格式为<code>image/png</code><br> radio: 当请求图片格式为<code>image/jpeg</code>或者<code>image/webp</code>时用来指定图片展示质量</p>
</blockquote>
<p>Blob 对象相当于一个容器，可以用于存放二进制数据。它有两个属性，size 属性表示字节长度，type 属性表示 MIME 类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">canvas.toBlob(<span class="function"><span class="keyword">function</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = URL.createObjectURL(blob);</span><br><span class="line">  <span class="keyword">var</span> newImg = <span class="keyword">new</span> Image();</span><br><span class="line">  newImg.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    URL.revokeObjectURL(url)	<span class="comment">// URL.revokeObjectURL():释放一个之前通过调用 URL.createObjectURL() 创建的已经存在的 URL 对象。当你结束使用某个 URL 对象时，应该通过调用这个方法来让浏览器知道不再需要保持这个文件的引用,避免消耗资源</span></span><br><span class="line">  &#125;;</span><br><span class="line">  newImg.src=url;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生成JPEG格式的图片</span></span><br><span class="line">canvas.toBlob(<span class="function"><span class="keyword">function</span>(<span class="params">blob</span>)</span>&#123;...&#125;, <span class="string">&quot;image/jpeg&quot;</span>, <span class="number">0.95</span>); <span class="comment">// JPEG at 95% quality</span></span><br></pre></td></tr></table></figure>

<p><code>canvas.toBlob</code>方法在低版本的<code>ios</code>存在兼容性问题,需要添加一下代码实现兼容:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!HTMLCanvasElement.prototype.toBlob) &#123;</span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(HTMLCanvasElement.prototype, <span class="string">&#x27;toBlob&#x27;</span>, &#123;</span><br><span class="line"> value: <span class="function"><span class="keyword">function</span> (<span class="params">callback, type, quality</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> binStr = atob( <span class="built_in">this</span>.toDataURL(type, quality).split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>] ),</span><br><span class="line">len = binStr.length,</span><br><span class="line">arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(len);</span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++ ) &#123;</span><br><span class="line">   arr[i] = binStr.charCodeAt(i);</span><br><span class="line"> 	&#125;</span><br><span class="line">	  callback( <span class="keyword">new</span> Blob( [arr], &#123;<span class="attr">type</span>: type || <span class="string">&#x27;image/png&#x27;</span>&#125; ) );</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.2 <code>canvas</code>转<code>base64</code>:直接调用方法<code>canvas.toDataURL(type, radio)</code></p>
<blockquote>
<p>type: 图片格式，默认为 <code>image/png</code></p>
<p>radio: 当请求图片格式为<code>image/jpeg</code>或者<code>image/webp</code>时用来指定图片展示质量</p>
<p>与转blob对象不同的是,<code>canvas.toDataURL</code>直接返回base64 的图片</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newImg = <span class="keyword">new</span> Image();</span><br><span class="line">newImg.src=canvas.toDataURL(<span class="string">&quot;image/png&quot;</span>,<span class="number">0.8</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传进度展示</p>
<p>文件上传需要用到<code>XMLHttpRequest:progress</code>方法,在<code>axios</code>的api中提供了现成的<code>onUploadProgress</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">  url:<span class="string">&#x27;/upload&#x27;</span></span><br><span class="line">  method: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">  data: data,</span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">      self.radio = (event.loaded / event.total) * <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当上传存在跨域的时候,浏览器在跨域请求前会默认发个<code>options</code>请求来验证是否跨域,这是后端服务器需要处理<code>options</code>请求</p>
<blockquote>
<p><code>OPTIONS</code> 方法用来查询针对请求 URI 指定的资源支持的方法。</p>
</blockquote>
<img src='https://haohome.top/18-11-8/51395595.jpg' width="50%">

<table>
<thead>
<tr>
<th>请求</th>
<th>OPTIONS*HTTP/1.1</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td><a href="http://www.zhongguo.com/upload">www.zhongguo.com/upload</a></td>
</tr>
<tr>
<td>响应</td>
<td>HTTP/1.1 200 OK</td>
</tr>
<tr>
<td>Allow</td>
<td>GET, POST, HEAD, OPTIONS(返回服务器支持的方法)</td>
</tr>
</tbody></table>
<p>如果后端未对<code>OPTIONS</code>请求做处理,前端文件<code>post</code>上传文件会失败的</p>
<p><strong>当后端对<code>OPTIONS</code>请求做出响应200时,前端才会继续发送<code>post</code>请求</strong>,这就是我们在调试时看到文件上传时会默认发<code>OPTIONS</code>和<code>post</code>两个请求的原因</p>
</li>
<li><p>拍照图片旋转</p>
<p>在手机上通过H5网页<code>input</code>标签拍照上传图片，有一些手机会出现图片旋转了90°的问题,这些手机竖着拍的时候才会出现这种问题，横拍出来的照片就正常显示。因此，可以通过获取手机拍照角度来对照片进行旋转，从而解决这个问题。</p>
<p><code>Orientation</code>:通过这个参数可以识别图片的拍摄角度,手机拍出来的图片会带有这个参数</p>
<table>
<thead>
<tr>
<th align="center">旋转角度</th>
<th align="center">参数值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0°</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">顺时针90°</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">逆时针90°</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">180°</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>想要获取 <code>Orientation</code> 参数，可以通过 <code>exif.js</code> 库来操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue项目可直接安装</span></span><br><span class="line">npm i exif-js -D</span><br><span class="line"><span class="comment">//在图片组件中直接引入</span></span><br><span class="line"><span class="keyword">import</span> Exif <span class="keyword">from</span> <span class="string">&#x27;exif-js&#x27;</span></span><br><span class="line">Exif.getData(file, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> Orientation = Exif.getTag(<span class="built_in">this</span>, <span class="string">&#x27;Orientation&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在对图片进行<code>canvas</code>绘图时,就可以针对<code>Orientation</code>参数做判断处理:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Orientation &amp;&amp; Orientation != <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (Orientation) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:     <span class="comment">// 旋转90度</span></span><br><span class="line">      canvas.width = imgHeight;</span><br><span class="line">      canvas.height = imgWidth;</span><br><span class="line">      ctx.rotate(<span class="built_in">Math</span>.PI / <span class="number">2</span>);</span><br><span class="line">      <span class="comment">// (0,-imgHeight) 从旋转原理图那里获得的起始点</span></span><br><span class="line">      ctx.drawImage(img, <span class="number">0</span>, -imgHeight, imgWidth, imgHeight);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:     <span class="comment">// 旋转180度</span></span><br><span class="line">      ctx.rotate(<span class="built_in">Math</span>.PI);</span><br><span class="line">      ctx.drawImage(img, -imgWidth, -imgHeight, imgWidth, imgHeight);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:     <span class="comment">// 旋转-90度</span></span><br><span class="line">      canvas.width = imgHeight;</span><br><span class="line">      canvas.height = imgWidth;</span><br><span class="line">      ctx.rotate(<span class="number">3</span> * <span class="built_in">Math</span>.PI / <span class="number">2</span>);</span><br><span class="line">      ctx.drawImage(img, -imgWidth, <span class="number">0</span>, imgWidth, imgHeight);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  canvas.width = imgWidth;</span><br><span class="line">  canvas.height = imgHeight;</span><br><span class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, imgWidth, imgHeight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Demo: <a href="./%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E4%B8%8E%E5%8E%8B%E7%BC%A9.md">图片上传与压缩</a></p>
</li>
</ol>
<h2 id="5-webkit-overflow-scrolling的坑"><a href="#5-webkit-overflow-scrolling的坑" class="headerlink" title="5. -webkit-overflow-scrolling的坑"></a>5. -webkit-overflow-scrolling的坑</h2><p>项目中有一个获取数据后纯展示的页面,在ios平台上滑动不流畅,经过查询才了解到在ios的safari浏览器和app内核浏览器中，当一个h5页面内容超出屏幕高度，我们手指去滑动屏幕的时候，只要手势一离开屏幕，滚动立刻结束,按照教程我按下面设置了:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">   <span class="attribute">-webkit-overflow-scrolling</span>: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果在app中出现了fixed 定位元素失效</p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>vue</tag>
        <tag>项目总结</tag>
      </tags>
  </entry>
  <entry>
    <title>flex-shrink 新弹性和模型属性</title>
    <url>/2017/11/09/IT%E6%8A%80%E6%9C%AF/flex-shrink%20%20%E6%96%B0%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><ul>
<li>flex-shrink：<number></li>
<li>默认值：1</li>
<li>适用于：flex子项</li>
<li>继承性：无</li>
<li>动画性：是</li>
<li>计算值：指定值<a id="more"></a>
<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4>设置或检索弹性盒的收缩比率。<br>根据弹性盒子元素所设置的收缩因子作为比率来收缩空间。<br>示例：a,b,c将按照1:1:3的比率来收缩空间<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;flex&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.flex</span>&#123;<span class="attribute">display</span>:flex;<span class="attribute">width</span>:<span class="number">400px</span>;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">list-style</span>:none;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.flex</span> <span class="selector-tag">li</span>&#123;<span class="attribute">width</span>:<span class="number">200px</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.flex</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(3)</span>&#123;<span class="attribute">flex-shrink</span>:<span class="number">3</span>;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><ol>
<li>flex-shrink的默认值为1，如果没有显示定义该属性，将会自动按照默认值1在所有因子相加之后计算比率来进行空间收缩。</li>
</ol>
</li>
</ul>
<ol>
<li>本例中c显式的定义了flex-shrink，a,b没有显式定义，但将根据默认值1来计算，可以看到总共将剩余空间分成了5份，其中a占1份，b占1份，c占3分，即1:1:3</li>
<li>我们可以看到父容器定义为400px，子项被定义为200px，相加之后即为600px，超出父容器200px。那么这么超出的200px需要被a,b,c消化</li>
<li>通过收缩因子，所以加权综合可得200<em>1+200</em>1+200*3=1000px；</li>
<li>于是我们可以计算a,b,c将被移除的溢出量是多少：</li>
</ol>
<blockquote>
<p> a被移除溢出量：(200*1/1000)*200，即约等于40px</p>
<p> b被移除溢出量：(200*1/1000)*200，即约等于40px</p>
<p> c被移除溢出量：(200*3/1000)*200，即约等于120px</p>
<p> 最后a,b,c的实际宽度分别为：200-40=160px, 200-40=160px, 200-120=80px</p>
</blockquote>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>get和post推荐使用场景</title>
    <url>/2017/12/10/IT%E6%8A%80%E6%9C%AF/get%E5%92%8Cpost%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<ul>
<li>查询数据时用GET,因为通常查询条件较少;</li>
<li>提交数据(表单)时用POST,因为通常提交的数据较多.</li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>hashchange事件</title>
    <url>/2018/08/28/IT%E6%8A%80%E6%9C%AF/hashchange%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>最近在写公司的后台管理系统，因为需求需要刷新后保持原来页面,原有的单页面组件跳转方式不能满足，所以在原有项目基础上增加了路由功能,目前比较简单的路由切换就是通过监听hash变化，实现不同页面的加载。</p>
</blockquote>
<p>当 一个窗口地址的 hash （URL 中 # 后面的部分）改变时就会触发 hashchange 事件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = handleHashChange;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//hash变化的处理逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>hashchange 事件回调函数对象主要有两个参数会用到:</p>
<ul>
<li><p>newURL: 当前页面新的URL</p>
</li>
<li><p>oldURL: 当前页面旧的URL</p>
</li>
</ul>
<p>但在IE浏览器里,这两个属性不被支持,需要在绑定hashchange事件前添加以下代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.HashChangeEvent)(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> lastURL=<span class="built_in">document</span>.URL;</span><br><span class="line">	<span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">Object</span>.defineProperty(event,<span class="string">&quot;oldURL&quot;</span>,&#123;<span class="attr">enumerable</span>:<span class="literal">true</span>,<span class="attr">configurable</span>:<span class="literal">true</span>,<span class="attr">value</span>:lastURL&#125;);</span><br><span class="line">		<span class="built_in">Object</span>.defineProperty(event,<span class="string">&quot;newURL&quot;</span>,&#123;<span class="attr">enumerable</span>:<span class="literal">true</span>,<span class="attr">configurable</span>:<span class="literal">true</span>,<span class="attr">value</span>:<span class="built_in">document</span>.URL&#125;);</span><br><span class="line">		lastURL=<span class="built_in">document</span>.URL;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>hash</tag>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数组以及对象的深拷贝</title>
    <url>/2018/02/22/IT%E6%8A%80%E6%9C%AF/javascript%20%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>转载自 csdn博客 <strong>FengCms FungLeo</strong>  博客:<a href="http://blog.csdn.net/fungleo/article/details/54931379">原文链接</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在js中，数组和对象的复制如果使用<code>=</code>号来进行复制，那只是浅拷贝。如下图演示：<br><img src="https://haohome.top/18-4-10/66887533.jpg" alt="img"><br>如上，<code>arr</code>的修改，会影响<code>arr2</code>的值，这显然在绝大多数情况下，并不是我们所需要的结果。<br>因此，数组以及对象的深拷贝就是<code>javascript</code>的一个基本功了。</p>
<h2 id="数组的深拷贝"><a href="#数组的深拷贝" class="headerlink" title="数组的深拷贝"></a>数组的深拷贝</h2><p>条条大道通罗马，实现数组的深拷贝，是有好几种方法的。举例如下：</p>
<a id="more"></a>
<h3 id="for-循环实现数组的深拷贝"><a href="#for-循环实现数组的深拷贝" class="headerlink" title="for 循环实现数组的深拷贝"></a>for 循环实现数组的深拷贝</h3><p>for循环是非常好用的。如果不知道高级方法，通过for循环能够完成我们大多数的需求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = copyArr(arr)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">     res.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，通过对数组的for循环，即可实现对数组的深拷贝了。</p>
<h3 id="slice-方法实现数组的深拷贝"><a href="#slice-方法实现数组的深拷贝" class="headerlink" title="slice 方法实现数组的深拷贝"></a>slice 方法实现数组的深拷贝</h3><p>这个代码实现非常简单。原理也比较好理解，他是将原数组中抽离部分出来形成一个新数组。我们只要设置为抽离全部，即可完成数组的深拷贝。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.slice(<span class="number">0</span>)</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1fcj8i9uye5j305n03rmx8.jpg" alt="img"><br>更多 <code>slice</code> 内容请访问 <a href="http://www.w3school.com.cn/jsref/jsref_slice_array.asp">w3school JavaScript slice 方法 </a></p>
<h3 id="concat-方法实现数组的深拷贝"><a href="#concat-方法实现数组的深拷贝" class="headerlink" title="concat 方法实现数组的深拷贝"></a>concat 方法实现数组的深拷贝</h3><p>这个代码也非常简单，原理更加粗暴。它是用于连接多个数组组成一个新的数组的方法。那么，我们只要连接它自己，即可完成数组的深拷贝。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.concat()</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(arr2)<span class="comment">//12345</span></span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fcj8mi1kvtj305g043t8s.jpg" alt="img"><br>更多 <code>concat</code> 内容请访问 <a href="http://www.w3school.com.cn/jsref/jsref_concat_array.asp">w3school JavaScript concat 方法 </a></p>
<h3 id="2017年10月31日补充：ES6扩展运算符实现数组的深拷贝"><a href="#2017年10月31日补充：ES6扩展运算符实现数组的深拷贝" class="headerlink" title="2017年10月31日补充：ES6扩展运算符实现数组的深拷贝"></a>2017年10月31日补充：ES6扩展运算符实现数组的深拷贝</h3><p>OK，以上之前讲的方法全部过时了，用下面的方法实现数组的深拷贝是最简单的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> [ ...arr2 ] = arr</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(arr2)<span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="http://img.blog.csdn.net/20171031142723093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRnVuZ0xlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ES6扩展运算符实现数组的深拷贝"></p>
<h2 id="对象的深拷贝"><a href="#对象的深拷贝" class="headerlink" title="对象的深拷贝"></a>对象的深拷贝</h2><p>对象的深拷贝相比数组也没有困难许多，列举两个方法。</p>
<h3 id="万能的for循环实现对象的深拷贝"><a href="#万能的for循环实现对象的深拷贝" class="headerlink" title="万能的for循环实现对象的深拷贝"></a>万能的for循环实现对象的深拷贝</h3><p>在很多时候，for循环能够解决大问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;FungLeo&#x27;</span>,</span><br><span class="line">  sex: <span class="string">&#x27;man&#x27;</span>,</span><br><span class="line">  old: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = copyObj(obj)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    res[key] = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换成json再转换成对象实现对象的深拷贝"><a href="#转换成json再转换成对象实现对象的深拷贝" class="headerlink" title="转换成json再转换成对象实现对象的深拷贝"></a>转换成json再转换成对象实现对象的深拷贝</h3><p>上面的代码实在是比较长，所以，用一个更暴力的方法吧！代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;FungLeo&#x27;</span>,</span><br><span class="line">  sex: <span class="string">&#x27;man&#x27;</span>,</span><br><span class="line">  old: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br></pre></td></tr></table></figure>

<p>这个原理没什么好解释的，实在是够简单粗暴的啦！</p>
<h3 id="2017年10月31日补充：-扩展运算符实现对象的深拷贝"><a href="#2017年10月31日补充：-扩展运算符实现对象的深拷贝" class="headerlink" title="2017年10月31日补充： 扩展运算符实现对象的深拷贝"></a>2017年10月31日补充： 扩展运算符实现对象的深拷贝</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;FungLeo&#x27;</span>,</span><br><span class="line">  sex: <span class="string">&#x27;man&#x27;</span>,</span><br><span class="line">  old: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; ...obj2 &#125; = obj</span><br><span class="line">obj.old = <span class="string">&#x27;22&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj2)</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="http://img.blog.csdn.net/20171031143034799?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRnVuZ0xlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="扩展运算符实现对象的深拷贝"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>数组和对象的深拷贝是js中最常见的应用。理解各种方法是必须的。希望对大家有所帮助。<br>本文中并没有对异常进行处理，主要在讲原理。更多的数组以及对象的操作方法，可以参考<code>lodash</code>的源码，查看它的源码可以让你的js基础变得非常牢固。我也在学习中。</p>
<blockquote>
<p>2017年10月31日补充，使用es6提供的扩展运算符的方法实现深拷贝，简单，高效。并且，对象的深拷贝不会像使用 <code>JSON</code> 方法深拷贝一样，丢失函数等信息，只能用来深拷贝 <code>JSON</code> 数据格式的对象。推荐大家使用。</p>
</blockquote>
<h3 id="补充一个数组去重的方法"><a href="#补充一个数组去重的方法" class="headerlink" title="补充一个数组去重的方法"></a>补充一个数组去重的方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(array)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(dedupe(arr))	<span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JS判断当前文本输入状态</title>
    <url>/2018/08/28/IT%E6%8A%80%E6%9C%AF/js%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<blockquote>
<p>最近在重构我的网址导航页面,这是我认识前端网页的启蒙项目,网上找的模板,然后修改链接、微调样式，成为了最初的网页导航1.0。</p>
</blockquote>
<p>在搜索的时候，我们需要按<code>Enter</code>键实现直接跳转搜索，因此添加了按键监听事件。但问题出现了:</p>
<ul>
<li><p>绑定<code>keyup</code>事件会将输入法中的英文文字输入到文字框并直接触发搜索按钮</p>
</li>
<li><p>单纯按键监听，并没有判断中文输入状态</p>
</li>
</ul>
<a id="more"></a>

<p>网上查了一些资料：</p>
<ol>
<li><p>键盘事件:<br>当一个键盘被按下并松开时,每个浏览器都会触发三个事件:<code>keydown、keypress、keyup</code><br><code>keydown</code>事件发生在按键被按下的时候，接着触发<code>keypress</code>，松开按键的时候触发<code>keyup</code>事件</p>
<p>还有一个事件就是<code>input</code>:input事件能够检测用户的每一次输入</p>
<p>以上事件在英文状态下没有问题,但在中文状态下,依然捕获到的是英文,如下图:</p>
<p><img src="https://haohome.top/18-8-28/85753032.jpg" alt="image"></p>
</li>
<li><p>中文输入法</p>
<blockquote>
<p><code>firfox</code>：输入触发<code>keydown</code>，回车确认输入触发<code>keyup</code><br><code>chrome</code>：输入触发<code>keydown</code>、<code>keyup</code>，回车确认输入只触发<code>keydown</code><br><code>IE</code>：输入触发<code>keydown</code>、<code>keyup</code>，回车确认输入触发<code>keydown</code>，<code>keyup</code><br><code>Safari</code>：输入触发<code>keydown</code>、<code>keyup</code>，回车确认输入触发<code>keydown</code>，<code>keyup</code><br><code>opera</code>：输入触发<code>keydown</code>、<code>keyup</code>，回车确认输入触发<code>keydown</code>，<code>keyup</code><br>在<code>input</code>、<code>textarea</code>中，中文输入法时：没有触发<code>keypress</code>事件<br><code>keypress</code>事件：对中文输入法支持不好，无法响应中文输入；无法响应系统功能键</p>
</blockquote>
</li>
</ol>
<iframe width="100%" height="300" src="//jsrun.net/bmgKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p><strong>解决方案</strong>:</p>
<ol>
<li><p>利用<code>change</code>事件:</p>
<p>监听输入框最终内容变化识别,当文本输入状态完成,并且<code>input</code>失去焦点再触发<code>enter</code>事件</p>
<blockquote>
<p>通常情况下,文本框中文输入状态时,按下回车会触发相应的按钮,此时<code>input</code>会失去焦点并触发<code>change</code>事件,此时将输入状态传给按钮事件,即可判断并执行相应事件</p>
</blockquote>
</li>
<li><p>利用<code>compositionstart</code>和<code>compositionend</code>事件(事件不兼容旧浏览器)</p>
<p><code>compositionstart</code>:事件触发于一段文字的输入之前</p>
<p><code>compositionend</code>事件:当文本段落的组成完成或取消时, <code>compositionend </code>事件将被激发</p>
<p>简单来说，非直接输入法如中文输入开始时，触发<code>compositionstart</code>事件，结束时触发<code>compositionend</code>事件</p>
<p>两类解决方案都可以监听到当前输入框的输入状态,结合input事件，就能对所有的输入进行实时的检测了</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doing=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> doSomething=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//我要干点啥</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;testInput&#x27;</span>).addEventListener(<span class="string">&#x27;compositionstart&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    doing=<span class="literal">true</span>;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;testInput&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!doing)&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;testInput&#x27;</span>).addEventListener(<span class="string">&#x27;compositionend&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    doing=<span class="literal">false</span>;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title>ready与load比较</title>
    <url>/2017/11/11/IT%E6%8A%80%E6%9C%AF/ready%E4%B8%8Eload/</url>
    <content><![CDATA[<h4 id="1-执行时间不同："><a href="#1-执行时间不同：" class="headerlink" title="1.执行时间不同："></a>1.执行时间不同：</h4><ul>
<li>$(document).ready()是指html解析完毕，dom树已经建立起来,页面内容(html,css,js,图片)还未加载完成</li>
<li>$(window).load()是指页面所有的加载完毕。<a id="more"></a></li>
</ul>
<h4 id="2-执行次数不同"><a href="#2-执行次数不同" class="headerlink" title="2.执行次数不同"></a>2.执行次数不同</h4><ul>
<li>$(document).ready()可以执行多次。可以写多个。</li>
<li>$(window).load()一个页面,只能有一个，如果出现多个，则只会调用最后一个，之前的都会被覆盖。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;test1&quot;</span>);<span class="comment">//这段代码会被执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">  $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;test2&quot;</span>);<span class="comment">//这段代码会被执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">  $(<span class="built_in">window</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;test1&quot;</span>);<span class="comment">//这段代码不会被执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">  $(<span class="built_in">window</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;test2&quot;</span>);<span class="comment">//这段代码将被执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="3-执行效率不同"><a href="#3-执行效率不同" class="headerlink" title="3.执行效率不同"></a>3.执行效率不同</h4><ul>
<li>$(document).ready()执行效率相对高一些</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&quot;.the_body a&quot;</span>).attr(<span class="string">&quot;onclick&quot;</span>,<span class="string">&quot;alert(&#x27;test&#x27;)&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  $(<span class="built_in">window</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&quot;.close_btn&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       $(<span class="string">&quot;#app_down&quot;</span>).hide();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-js和jQuery"><a href="#4-js和jQuery" class="headerlink" title="4.js和jQuery"></a>4.js和jQuery</h4><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">原生js</th>
<th align="center">jQuery</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">document.ready=function(){}</td>
<td align="center">$(document).ready(function(){})==$(function(){})</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">window.onload=function(){}</td>
<td align="center">$(window).load(function(){})</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">window.location.reload();</td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Viewport剖析</title>
    <url>/2018/02/20/IT%E6%8A%80%E6%9C%AF/viewports%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>转载自W3CPlus创始人 <strong>大漠</strong>  博客:<a href="https://www.w3cplus.com/css/viewports.html">原文链接</a></p>
<h2 id="1-桌面（pc）浏览器"><a href="#1-桌面（pc）浏览器" class="headerlink" title="1. 桌面（pc）浏览器"></a>1. 桌面（pc）浏览器</h2><h3 id="1-1-设备的pixels和CSS的pixels"><a href="#1-1-设备的pixels和CSS的pixels" class="headerlink" title="1.1 设备的pixels和CSS的pixels"></a>1.1 设备的pixels和CSS的pixels</h3><p>pixels决定了你工作所用的那些设备上正式的分辨率。在大多数情况下，能够从screen.width/height上取出具体值</p>
<p>如果用户缩放（zoom）了浏览器，当然必须改变计算方式。</p>
<p>现代浏览器上的缩放，是基于“伸展”pixels。结果是，html元素上的宽度并没有因为缩放200%而由128pix变成256px，而是真实的pixels的被计算成了双倍。html元素在形式上依然是128CSS的pixels，即便它占用了256设备的pixels 。</p>
<a id="more"></a>

<ul>
<li>有4个1像素，缩放为100%的html元素，CSS的pixels完整的和设备的pixels重叠:</li>
</ul>
<p><img src="https://haohome.top/18-2-20/75842280.jpg"></p>
<ul>
<li>当我们缩小浏览器时，CSS的pixels开始收缩，导致1单位的设备的pixels上重叠了多个CSS的pixels</li>
</ul>
<p><img src="https://haohome.top/18-2-20/45453120.jpg"></p>
<ul>
<li>同理，放大浏览器时，相反的事情发生了，CSS的pixels开始扩大，导致1单位的CSS的pixels上重叠了多个设备的pixels</li>
</ul>
<p><img src="https://haohome.top/18-2-20/30776207.jpg"></p>
<blockquote>
<p>你只需要关注CSS的pixels，这些pixels指定你的样式被如何渲染.</p>
</blockquote>
<h3 id="1-2-100-缩放"><a href="#1-2-100-缩放" class="headerlink" title="1.2 100% 缩放"></a>1.2 100% 缩放</h3><p>在缩放级别为100%时，1单位的CSS的pixel是严格相等于1单位的设备pixel，通常会在100%缩放级别下测试网站</p>
<h4 id="1-2-1-屏幕尺寸-Screen-size"><a href="#1-2-1-屏幕尺寸-Screen-size" class="headerlink" title="1.2.1 屏幕尺寸 Screen size"></a>1.2.1 屏幕尺寸 Screen size</h4><blockquote>
<p>含义：用户的屏幕的完整大小。这两个属性包含了用户屏幕的完整宽度/高度,尺寸使用设备的pixels来定义，他们的值不会因为缩放而改变(显示器的特征，而不是浏览器)</p>
<p>度量：设备的pixels,<strong>screen.width/height</strong>  (基本无用)</p>
<p>兼容性问题：IE8里，不管使用IE7模式还是IE8模式，都以CSS的pixels来度量</p>
</blockquote>
<p><img src="https://haohome.top/18-2-20/90621892.jpg" alt="img-w150"></p>
<h4 id="1-2-2-浏览器尺寸-Window-size"><a href="#1-2-2-浏览器尺寸-Window-size" class="headerlink" title="1.2.2 浏览器尺寸 Window size"></a>1.2.2 浏览器尺寸 Window size</h4><blockquote>
<p>含义：包含滚动条尺寸的浏览器完整尺寸; 想要知道的浏览器的内部尺寸。它定义了当前用户有多大区域，可供你的CSS布局占用<br>度量：CSS的pixels, <strong>window.innerWidth/Height</strong><br>兼容性问题：IE不支持，Opera用设备pixels来度量</p>
</blockquote>
<p><img src="https://haohome.top/18-2-20/38410284.jpg"></p>
<h4 id="1-2-3-滚动移位-Scrolling-offset"><a href="#1-2-3-滚动移位-Scrolling-offset" class="headerlink" title="1.2.3 滚动移位 Scrolling offset"></a>1.2.3 滚动移位 Scrolling offset</h4><ul>
<li><blockquote>
<p>含义：页面的移位 , 定义了页面(document)的相对于窗口原点的水平、垂直位移。因此你能够定位用户滚动了多少的滚动条距离。</p>
<p>度量：CSS的pixels, <strong>window.pageX/YOffset</strong></p>
<p>兼容性问题：pageXOffset 和 pageYOffset 在 IE 8 及之前版本的IE不支持, 使用”document.body.scrollLeft” and “document.body.scrollTop” 来取代</p>
</blockquote>
<p><img src="https://haohome.top/18-2-20/96319637.jpg"></p>
</li>
</ul>
<h4 id="1-2-4-视窗-viewport"><a href="#1-2-4-视窗-viewport" class="headerlink" title="1.2.4 视窗 viewport"></a>1.2.4 视窗 viewport</h4><p>viewport的功能在于控制你网站的最高块状（block）容器：<code>&lt;html&gt;</code> 元素。viewport是严格的等于浏览器的窗口,viewport不是一个HTML的概念，不能通过CSS修改它。</p>
<blockquote>
<p>举个例子~假设你定义了一个可变尺寸的布局（liquid layout），且你定义一个侧边栏的宽度为width: 10%。当你改变浏览器窗口大小时，该侧边栏会自动扩张和收缩。</p>
<p><strong>原理是侧边栏的宽度为它父元素宽度的10%</strong></p>
</blockquote>
<p>一个块级元素占有起父元素的100%的宽度（这里有异常情况，暂时忽略）。所以<code>&lt;body&gt;</code>的宽度就是其父元素<code>&lt;html&gt;</code>的宽度。</p>
<p>那么<code>&lt;html&gt;</code>元素到底有多宽？因为它的宽度恰好为浏览器的宽度。所以你的侧边栏宽度width: 10%会占用10%的浏览器宽度。所以的web开发人员都直观的知道和使用该特性了。 但是你也许不知道原理。在原理上，<code>&lt;html&gt;</code>的宽度受viewport所限制，<code>&lt;html&gt;</code>元素为viewport宽度的100%。</p>
<h4 id="1-2-5-页面宽度-document-width"><a href="#1-2-5-页面宽度-document-width" class="headerlink" title="1.2.5 页面宽度 document width"></a>1.2.5 页面宽度 document width</h4><ul>
<li><strong>度量viewport 尺寸</strong> :</li>
</ul>
<blockquote>
<p>含义：viewport的尺寸</p>
<p>度量：CSS的pixels,  <strong>document. documentElement. clientWidth/Height</strong></p>
<p>兼容性问题：无</p>
</blockquote>
<p>document.documentElement实际上就是·<code>&lt;html&gt;</code>元素：HTML文档的根元素，然而viewport是比<code>&lt;html&gt;</code>更高级别的元素，打个比喻，它是容纳<code>&lt;html&gt;</code>元素的元素。</p>
<p>document. documentElement. clientWidth/Height只会给出viewport的尺寸，而不管<code>&lt;html&gt;</code>元素尺寸如何改变</p>
<ul>
<li><strong>度量<code>&lt;html&gt;</code> 元素</strong></li>
</ul>
<blockquote>
<p>含义：<code>&lt;html&gt;</code>的尺寸</p>
<p>度量：CSS的pixels, <strong>document. documentElement. offsetWidth/Height</strong></p>
<p>兼容性问题：IE用这个值标示viewport的尺寸而非<code>&lt;html&gt;</code></p>
</blockquote>
<p>如果clientWidth/Height一直用以标示viewport的尺寸，我们该如何去获取<code>&lt;html&gt;</code>元素的尺寸呢？答案是：document.documentElement.offsetWidth/Height。</p>
<img src="https://haohome.top/18-2-20/47353138.jpg" style="width:50%">

<p>这个特性对真实的让你访问块级元素<code>&lt;html&gt;</code>元素，如果你为<code>&lt;html&gt;</code>元素赋值了宽度，offsetWidth会真实的反应出来</p>
<p><img src="https://haohome.top/18-2-20/39845698.jpg"></p>
<h3 id="1-3-几种尺寸区别"><a href="#1-3-几种尺寸区别" class="headerlink" title="1.3 几种尺寸区别"></a>1.3 几种尺寸区别</h3><ul>
<li>window.innerWidth/Height 包含滚动条</li>
<li>document. documentElement. clientWidth/Height: 不包含滚动条 viewport尺寸</li>
<li>document. documentElement. offsetWidth：html尺寸</li>
</ul>
<h3 id="1-4-事件坐标"><a href="#1-4-事件坐标" class="headerlink" title="1.4 事件坐标"></a>1.4 事件坐标</h3><ul>
<li>pageX/Y：从<code>&lt;html&gt;</code>原点到事件触发点的CSS的 pixels   <strong>(使用概率:90%)</strong></li>
<li>clientX/Y：从viewport原点（浏览器窗口）到事件触发点的CSS的 pixels <strong>(使用概率:10%)</strong></li>
<li>screenX/Y：从用户显示器窗口原点到事件触发点的设备 的 pixels。**(使用概率:0%)**</li>
<li>兼容性问题：IE不支持pageX/Y,IE使用CSSpixels来度量screanX/Y</li>
</ul>
<img src="https://haohome.top/18-2-20/56020173.jpg" style="width:50%">

<img src="https://haohome.top/18-2-20/40182805.jpg" style="width:50%">

<img src="https://haohome.top/18-2-20/3998183.jpg" style="width:50%">

<h3 id="1-5-Media查询"><a href="#1-5-Media查询" class="headerlink" title="1.5 Media查询"></a>1.5 Media查询</h3><ul>
<li>含义：可以根据页面的特定宽度来定义特殊的CSS规则。</li>
<li>度量：<strong>width/height 和 device-width/device-heigh</strong></li>
<li>兼容性问题：IE不支持.</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.sidebar</span> &#123; <span class="attribute">width</span>: <span class="number">300px</span>; &#125; </span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">400px</span>) &#123; </span><br><span class="line">  <span class="selector-tag">div</span><span class="selector-class">.sidebar</span> &#123; <span class="attribute">width</span>: <span class="number">100px</span>; &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果宽度大于400px，那么sidebar宽度为300px。反之，sidebar宽度为100px*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>device-width/height: 使用screen.width/height来做为的判定值。该值<strong>以设备的pixels来度量</strong></li>
<li>width/height: 使用documentElement.clientWidth/Height即viewport的值。该值<strong>以CSS的pixels来度量</strong></li>
</ul>
</blockquote>
<img src="https://haohome.top/18-2-20/35575919.jpg" style="width:70%">

<h2 id="2-移动端浏览器"><a href="#2-移动端浏览器" class="headerlink" title="2. 移动端浏览器"></a>2. 移动端浏览器</h2><h3 id="2-1-一些概念"><a href="#2-1-一些概念" class="headerlink" title="2.1 一些概念"></a>2.1 一些概念</h3><h4 id="2-1-1-视窗-viewport"><a href="#2-1-1-视窗-viewport" class="headerlink" title="2.1.1 视窗 viewport"></a>2.1.1 视窗 viewport</h4><p>简单的理解，viewport是严格等于浏览器的窗口。在桌面浏览器中，viewport就是浏览器窗口的宽度高度。但在移动端设备上就有点复杂。</p>
<p>移动端的viewport太窄，为了能更好为CSS布局服务，所以提供了两个viewport：虚拟的viewportvisualviewport和布局的viewportlayoutviewport。</p>
<h4 id="2-1-2-物理像素-physical-pixel"><a href="#2-1-2-物理像素-physical-pixel" class="headerlink" title="2.1.2 物理像素(physical pixel)"></a>2.1.2 物理像素(physical pixel)</h4><p>又称为设备像素</p>
<ul>
<li><strong>设备独立像素(density-independent pixel)</strong></li>
</ul>
<p>设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。</p>
<ul>
<li><strong>CSS像素</strong></li>
</ul>
<p>CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs。</p>
<ul>
<li><strong>屏幕密度</strong></li>
</ul>
<p>屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。</p>
<ul>
<li><strong>设备像素比(device pixel ratio)</strong></li>
</ul>
<p>设备像素比简称为<strong>dpr</strong>，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">设备像素比 ＝ 物理像素 / 设备独立像素</span><br></pre></td></tr></table></figure>

<p>在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。</p>
<p>在CSS中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。</p>
<p>dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。</p>
<img src="https://haohome.top/18-2-20/49223947.jpg" style="width:50%">

<blockquote>
<p>iPhone6的设备宽度和高度为<code>375pt * 667pt</code>,可以理解为设备的独立像素；而其dpr为<code>2</code>，根据上面公式，我们可以很轻松得知其物理像素为<code>750pt * 1334pt</code>。</p>
</blockquote>
<p>在不同的屏幕上，CSS像素所呈现的物理尺寸是一致的，而不同的是CSS像素所对应的物理像素具数是不一致的。在普通屏幕下1个CSS像素对应1个物理像素，而在Retina屏幕下，1个CSS像素对应的却是4个物理像素。</p>
<p>在移动端时代屏幕适配除了Layout之外，还要考虑到图片的适配，因为其直接影响到页面显示质量</p>
<img src="https://haohome.top/18-2-20/89052097.jpg" style="width:100%">

<ul>
<li><strong>meta标签</strong></li>
</ul>
<p>viewport的<code>meta</code>标签，其主要用来告诉浏览器如何规范的渲染Web页面，而你则需要告诉它视窗有多大。</p>
<p>在开发移动端页面，我们需要设置<code>meta</code>标签如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码以显示网页的屏幕宽度定义了视窗宽度。网页的比例和最大比例被设置为100%。</p>
<ul>
<li><strong>CSS单位rem</strong></li>
</ul>
<p>在<a href="http://www.w3.org/TR/css3-values/#rem-unit">W3C</a>规范中是这样描述<code>rem</code>的: <code>font size of the root element</code> </p>
<p>简单的理解，rem就是相对于根元素<code>&lt;html&gt;</code> 的font-size来做计算。</p>
<h3 id="2-2-适配方案"><a href="#2-2-适配方案" class="headerlink" title="2.2 适配方案"></a>2.2 适配方案</h3><p>在移动端布局，我们需要面对两个最为重要的问题：</p>
<ul>
<li>各终端下的适配问题</li>
<li>Retina屏的细节处理</li>
</ul>
<h4 id="2-2-1-适配终端"><a href="#2-2-1-适配终端" class="headerlink" title="2.2.1 适配终端"></a>2.2.1 适配终端</h4><p>以前的<a href="https://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html">Flexible方案</a>是通过JavaScript来模拟<code>vw</code>的特性，如今<code>vw</code>已经得到了众多浏览器的支持，也就是说，可以直接考虑将<code>vw</code>单位运用于我们的适配布局中。</p>
<p><code>vw</code> 是基于Viewport视窗的长度单位，这里的视窗（Viewport）指的就是浏览器可视化的区域，而这个可视区域是<code>window.innerWidth/window.innerHeight</code>的大小。用下图简单的来示意一下：</p>
<img src="https://haohome.top/18-2-20/13841113.jpg" style="width:100%">

<p>在<a href="https://www.w3.org/TR/css3-values/">CSS Values and Units Module Level 3</a>中和Viewport相关的单位有四个，分别为<code>vw</code>、<code>vh</code>、<code>vmin</code>和<code>vmax</code>。</p>
<ul>
<li><code>vw</code>：是Viewport’s width的简写,<code>1vw</code>等于<code>window.innerWidth</code>的<code>1%</code></li>
<li><code>vh</code>：和<code>vw</code>类似，是Viewport’s height的简写，<code>1vh</code>等于<code>window.innerHeihgt</code>的<code>1%</code></li>
<li><code>vmin</code>：<code>vmin</code>的值是当前<code>vw</code>和<code>vh</code>中较小的值</li>
<li><code>vmax</code>：<code>vmax</code>的值是当前<code>vw</code>和<code>vh</code>中较大的值</li>
</ul>
<blockquote>
<p><code>vmin</code>和<code>vmax</code>是根据Viewport中长度偏大的那个维度值计算出来的，如果<code>window.innerHeight &gt; window.innerWidth</code>则<code>vmin</code>取百分之一的<code>window.innerWidth</code>，<code>vmax</code>取百分之一的<code>window.innerHeight</code>计算。</p>
</blockquote>
<img src="https://haohome.top/18-2-20/54143700.jpg" style="width:50%">

<p>这个方案中大胆的使用<code>vw</code>来替代以前Flexible中的<code>rem</code>缩放方案</p>
<p>目前出视觉设计稿，我们都是使用<code>750px</code>宽度的，从上面的原理来看，那么<code>100vw = 750px</code>，即<code>1vw = 7.5px</code>。那么我们可以根据设计图上的<code>px</code>值直接转换成对应的<code>vw</code>值。看到这里，很多同学开始感到崩溃，又要计算，能不能简便一点，能不能再简单一点，其实是可以的，我们可以使用PostCSS的插件<a href="https://github.com/evrone/postcss-px-to-viewport">postcss-px-to-viewport</a>，让我们可以直接在代码中写<code>px</code>，比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[w-369]</span>&#123; <span class="attribute">width</span>: <span class="number">369px</span>; &#125; </span><br><span class="line"><span class="selector-attr">[w-369]</span> <span class="selector-tag">h2</span> <span class="selector-tag">span</span> &#123; </span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#FF5000</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#FF5000</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">5px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PostCSS编译之后就是我们所需要的带vw代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[w-369]</span> &#123; <span class="attribute">width</span>: <span class="number">49.2vw</span>; &#125; </span><br><span class="line"><span class="selector-attr">[w-369]</span> <span class="selector-tag">h2</span> <span class="selector-tag">span</span> &#123; </span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ff5000</span>; </span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>; </span><br><span class="line">  <span class="attribute">display</span>: inline-block; </span><br><span class="line">  <span class="attribute">border-radius</span>: .<span class="number">53333vw</span>; </span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0.26667vw</span> <span class="number">0.26667vw</span> <span class="number">#ff5000</span>; </span><br><span class="line">  <span class="attribute">padding</span>: .<span class="number">26667vw</span> .<span class="number">66667vw</span>; &#125; </span><br><span class="line"><span class="selector-attr">[w-369]</span> <span class="selector-tag">h2</span> <span class="selector-tag">span</span>, </span><br><span class="line"><span class="selector-attr">[w-369]</span> <span class="selector-tag">i</span> &#123; </span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2.66667vw</span>; </span><br><span class="line">  <span class="attribute">margin-right</span>: .<span class="number">66667vw</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际使用的时候，你可以对该插件进行相关的参数配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;postcss-px-to-viewport&quot;</span>: &#123;</span><br><span class="line">    viewportWidth: <span class="number">750</span>,</span><br><span class="line">    viewportHeight: <span class="number">1334</span>,</span><br><span class="line">    unitPrecision: <span class="number">5</span>,</span><br><span class="line">    viewportUnit: <span class="string">&#x27;vw&#x27;</span>,</span><br><span class="line">    selectorBlackList: [],</span><br><span class="line">    minPixelValue: <span class="number">1</span>,</span><br><span class="line">    mediaQuery: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设你的设计稿不是<code>750px</code>而是<code>1125px</code>，那么你就可以修改<code>vewportWidth</code>的值。有关于该插件的详细介绍，<a href="https://github.com/evrone/postcss-px-to-viewport">可以阅读其官方使用文档</a>。</p>
<p>在哪些地方可以使用<code>vw</code>来适配我们的页面。根据相关的测试：</p>
<ul>
<li>容器适配，可以使用<code>vw</code></li>
<li>文本的适配，可以使用<code>vw</code></li>
<li>大于<code>1px</code>的边框、圆角、阴影都可以使用<code>vw</code></li>
<li>内距和外距，可以使用<code>vw</code></li>
</ul>
<p>另外有一个细节需要特别的提出，比如我们有一个这样的设计：</p>
<img src="https://haohome.top/18-2-20/51749019.jpg" style="width:60%">

<p>如果我们直接使用：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[w-188-246]</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">188px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[w-187-246]</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">187px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的效果会造成<code>[w-187-246]</code>容器的高度小于<code>[w-188-246]</code>容器的高度。这个时候我们就需要考虑到<a href="https://www.w3cplus.com/css/aspect-ratio.html">容器的长宽比缩放</a>。这方面的方案很多，但我还是推荐工具化来处理，这里推荐@一丝 姐姐写的一个PostCSS插件<a href="https://github.com/yisibl/postcss-aspect-ratio-mini">postcss-aspect-ratio-mini</a>。这个插件使用很简单，不需要做任何的配置，你只需要本地安装一下就OK。使用的时候如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[aspectratio]</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[aspectratio]</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[aspectratio-content]</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[aspectratio]</span><span class="selector-attr">[aspect-ratio=<span class="string">&quot;188/246&quot;</span>]</span>&#123;</span><br><span class="line">    <span class="attribute">aspect-ratio</span>: <span class="string">&#x27;188:246&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译出来：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[aspectratio]</span><span class="selector-attr">[aspect-ratio=<span class="string">&quot;188/246&quot;</span>]</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">130.85106382978725%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以完美的实现长宽比的效果。</p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack入门</title>
    <url>/2018/01/28/IT%E6%8A%80%E6%9C%AF/webpack%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>webpack 是一个现代 JavaScript 应用程序的<strong>静态模块打包器</strong>(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
<h4 id="1-1-入口-entry"><a href="#1-1-入口-entry" class="headerlink" title="1.1 入口(entry )"></a>1.1 <a href="https://doc.webpack-china.org/concepts/entry-points">入口(entry )</a></h4><p>入口起点指示 webpack 应该使用哪个模块，来作为构建其内部<em>依赖图</em>的开始。</p>
<p>每个依赖项随即被处理，最后<strong>输出到称之为 bundles 的文件</strong>中</p>
<blockquote>
<p>可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）</p>
</blockquote>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./file.js&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-出口-output"><a href="#1-2-出口-output" class="headerlink" title="1.2 出口(output)"></a>1.2 <a href="https://doc.webpack-china.org/concepts/output">出口(output)</a></h4><p><code>output</code>属性的最低要求是，将它的值设置为一个对象，包括以下两点：</p>
<ul>
<li><code>filename</code> 用于输出文件的文件名。</li>
<li>目标输出目录 <code>path</code> 的绝对路径。</li>
</ul>
<p><code>output</code>  属性告诉 webpack 在<strong>哪里(path)输出它所创建的 bundles</strong>，以及如何命名这些文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./file.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span>  <span class="comment">//输出的文件名将为file.bundle.js,在当前文件夹dist目录下</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>output.filename</code> 决定了每个输出 bundle 的名称</p>
</blockquote>
<table>
<thead>
<tr>
<th>模板</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[hash]</td>
<td>模块标识符(module identifier)的 hash</td>
</tr>
<tr>
<td>[chunkhash]</td>
<td>chunk 内容的 hash</td>
</tr>
<tr>
<td>[name]</td>
<td>模块名称</td>
</tr>
<tr>
<td>[id]</td>
<td>模块标识符(module identifier)</td>
</tr>
<tr>
<td>[query]</td>
<td>模块的 query，例如，文件名 <code>?</code> 后面的字符串</td>
</tr>
</tbody></table>
<h4 id="1-3-loader"><a href="#1-3-loader" class="headerlink" title="1.3 loader"></a>1.3 <a href="https://doc.webpack-china.org/concepts/loaders">loader</a></h4><p><em>loader</em> 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效<a href="https://doc.webpack-china.org/concepts/modules">模块</a>.</p>
<blockquote>
<p>本质: webpack loader 将所有类型的文件，转换为应用程序的依赖图可以直接引用的模块。</p>
</blockquote>
<p> webpack 的配置中 <strong>loader</strong> 有两个目标:</p>
<ul>
<li>1.识别出应该被对应的 loader 进行转换的那些文件。(使用 <code>test</code> 属性)</li>
<li>2.转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）(<code>use</code> 属性)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, use: <span class="string">&#x27;raw-loader&#x27;</span> &#125;</span><br><span class="line">    ]  <span class="comment">//当webpack打包require()/import 语句中被解析为&#x27;.txt&#x27;的路径时,先使用raw-loader转换一下</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-插件-plugins"><a href="#1-4-插件-plugins" class="headerlink" title="1.4 插件(plugins)"></a>1.4 <a href="https://doc.webpack-china.org/concepts/plugins/">插件(plugins)</a></h4><p>插件的执行范围比较广,包括从打包优化和压缩,一直到重新定义环境中的变量</p>
<ul>
<li>使用步骤：先require（），再添加到plugins数组中</li>
<li>tips：<ul>
<li>①多数插件可以通过选项options自定义</li>
<li>②多次使用同一个插件时，可以通过new 创建实例</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./file.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, use: <span class="string">&#x27;raw-loader&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>&#125;)<span class="comment">//使用html模板</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-配置-Configuration"><a href="#1-5-配置-Configuration" class="headerlink" title="1.5 配置(Configuration)"></a>1.5 配置(Configuration)</h4><p> webpack 的配置文件，是导出一个对象的 JavaScript 文件(module.exports)</p>
<p>webpack 配置是标准的 <code>Node.js CommonJS</code> 模块:</p>
<ul>
<li>通过 <code>require(...)</code> 导入其他文件</li>
<li>通过 <code>require(...)</code> 使用 npm 的工具函数</li>
<li>使用 JavaScript 控制流表达式，例如 <code>?:</code> 操作符</li>
<li>对常用值使用常量或变量</li>
<li>编写并执行函数来生成部分配置</li>
</ul>
<p><strong>配置类型(可略过)</strong></p>
<p>在<a href="https://doc.webpack-china.org/guides/development">开发</a>和<a href="https://doc.webpack-china.org/guides/production">生产构建</a>之间，消除 <code>webpack.config.js</code> 的差异,（至少）有两种选项:</p>
<ol>
<li>导出一个函数,包含两个参数:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env, argv</span>) </span>&#123;<span class="comment">//env:environment,argv:一个选项 map 对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    devtool: env.production ? <span class="string">&#x27;source-maps&#x27;</span> : <span class="string">&#x27;eval&#x27;</span>,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">       compress: argv[<span class="string">&#x27;optimize-minimize&#x27;</span>] <span class="comment">// 只有传入 -p 或 --optimize-minimize</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>导出一个 Promise</li>
</ol>
<p>webpack 将运行由配置文件导出的函数，并且等待 Promise 返回。便于需要异步地加载所需的配置变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;</span><br><span class="line">        entry: <span class="string">&#x27;./app.js&#x27;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>导出多个配置对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;./dist-amd.js&#x27;</span>,</span><br><span class="line">    libraryTarget: <span class="string">&#x27;amd&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  entry: <span class="string">&#x27;./app.js&#x27;</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;./dist-commonjs.js&#x27;</span>,</span><br><span class="line">    libraryTarget: <span class="string">&#x27;commonjs&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  entry: <span class="string">&#x27;./app.js&#x27;</span>,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h4 id="1-6-模块-Modules"><a href="#1-6-模块-Modules" class="headerlink" title="1.6 模块(Modules)"></a>1.6 模块(Modules)</h4><p>对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系,如:</p>
<ul>
<li>ES2015 import 语句</li>
<li>CommonJS require() 语句</li>
<li>AMD define 和 require 语句</li>
<li>css/sass/less 文件中的 @import 语句。</li>
<li>样式(url(…))或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接(image url)</li>
</ul>
<blockquote>
<p>webpack 通过 <em>loader</em> 可以支持各种语言和预处理器编写模块。</p>
</blockquote>
<h4 id="1-7-模块解析-Module-Resolution"><a href="#1-7-模块解析-Module-Resolution" class="headerlink" title="1.7 模块解析(Module Resolution)"></a>1.7 模块解析(Module Resolution)</h4><p>一个模块可以作为另一个模块的依赖模块，然后被后者引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;path/to/module&#x27;</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;path/to/module&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-8-构建目标-Targets"><a href="#1-8-构建目标-Targets" class="headerlink" title="1.8 构建目标(Targets)"></a>1.8 构建目标(Targets)</h4><p>多个 Target:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> serverConfig = &#123;</span><br><span class="line">  target: <span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;lib.node.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> clientConfig = &#123;</span><br><span class="line">  target: <span class="string">&#x27;web&#x27;</span>, <span class="comment">// &lt;=== 默认是 &#x27;web&#x27;，可省略</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;lib.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = [ serverConfig, clientConfig ];</span><br><span class="line"><span class="comment">//将在dist 文件夹下创建 lib.js 和 lib.node.js 文件。</span></span><br></pre></td></tr></table></figure>

<h4 id="1-9-Manifest"><a href="#1-9-Manifest" class="headerlink" title="1.9 Manifest"></a>1.9 Manifest</h4><ul>
<li>runtime:在模块交互时，连接模块所需的加载和解析逻辑</li>
<li>manifest:当编译器(compiler)开始执行、解析和映射应用程序时，保留的所有模块详细要点的数据集合</li>
</ul>
<blockquote>
<p>通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块。</p>
</blockquote>
<h4 id="1-10-模块热替换-Hot-Module-Replacement"><a href="#1-10-模块热替换-Hot-Module-Replacement" class="headerlink" title="1.10 模块热替换(Hot Module Replacement)"></a>1.10 <a href="https://doc.webpack-china.org/concepts/hot-module-replacement/">模块热替换(Hot Module Replacement)</a></h4><p>在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面</p>
<ul>
<li>保留在完全重新加载页面时丢失的应用程序状态。</li>
<li>只更新变更内容，以节省宝贵的开发时间。</li>
<li>调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。</li>
</ul>
<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack</span><br><span class="line">npm install --save-dev webpack@&lt;version&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.<a href="https://doc.webpack-china.org/configuration/">配置</a></h3><p>在webpack.config.js文件中进行配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;   <span class="comment">// string | object | array</span></span><br><span class="line">    app: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    print: <span class="string">&#x27;./src/print.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123; 		<span class="comment">// webpack 如何输出结果的相关选项, 必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span>,<span class="comment">//文件名模板	</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    publicPath: <span class="string">&#x27;/&#x27;</span> 	 <span class="comment">// 输出解析文件的目录，url 相对于 HTML 页面</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">&#x27;inline-source-map&#x27;</span>,<span class="comment">//追踪到错误和警告在源代码中的原始位置</span></span><br><span class="line">  devServer: &#123;  <span class="comment">//提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)</span></span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>),  <span class="comment">//服务器的位置</span></span><br><span class="line">    port: <span class="number">3000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>]),<span class="comment">//每次build都会清理dist文件夹</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;  <span class="comment">//指定模板输出,自动生成新的index,所有的bundle 会自动添加到 html 中</span></span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">      template: <span class="string">&#x27;src/assets/test.html&#x27;</span><span class="comment">//模板文件路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;				<span class="comment">//加载对应资源</span></span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         test: <span class="regexp">/\.(csv|tsv)$/</span>,</span><br><span class="line">         use: [</span><br><span class="line">           <span class="string">&#x27;csv-loader&#x27;</span></span><br><span class="line">         ]</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         test: <span class="regexp">/\.xml$/</span>,</span><br><span class="line">         use: [</span><br><span class="line">           <span class="string">&#x27;xml-loader&#x27;</span></span><br><span class="line">         ]</span><br><span class="line">       &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-环境构建"><a href="#4-环境构建" class="headerlink" title="4.环境构建"></a>4.环境构建</h3><h4 id="4-1-配置"><a href="#4-1-配置" class="headerlink" title="4.1 配置"></a>4.1 配置</h4><ul>
<li>开发环境(development)：需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server；</li>
<li>生产环境(production)：我们的目标转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间；</li>
</ul>
<blockquote>
<p>由于要遵循逻辑分离，我们通常建议为每个环境编写<strong>彼此独立的 webpack 配置</strong>，但会保留”通用”配置。</p>
</blockquote>
<p>通过工具<code>webpack-merge</code> ,将”通用”配置合并在一起:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-merge</span><br></pre></td></tr></table></figure>

<p><strong>project项目结构</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">webpack-demo</span><br><span class="line">  |- package.json</span><br><span class="line">  |- config</span><br><span class="line">    |- webpack.common.js</span><br><span class="line">    |- webpack.dev.js</span><br><span class="line">    |- webpack.prod.js</span><br><span class="line">  |-src</span><br><span class="line">	|-index.js</span><br><span class="line">  |- index.html</span><br></pre></td></tr></table></figure>

<p><strong>webpack.common.js公共配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: path.resolve(__dirname,<span class="string">&#x27;../src/index.js&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;  <span class="comment">//别名,引入第三方库jQuery之后起的别名</span></span><br><span class="line">      jquery: path.resolve(__dirname,<span class="string">&#x27;../libs/jquery-3.2.1.js&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(<span class="comment">//清理文件夹</span></span><br><span class="line">      [<span class="string">&#x27;*.js&#x27;</span>,<span class="string">&#x27;*.map&#x27;</span>,<span class="string">&#x27;*.png&#x27;</span>,<span class="string">&#x27;*.css&#x27;</span>,<span class="string">&#x27;*.html&#x27;</span>],　 <span class="comment">//匹配删除的文件,若为*则全部删除</span></span><br><span class="line">      &#123;</span><br><span class="line">        root: path.resolve(__dirname,<span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">        verbose:  <span class="literal">true</span>,  <span class="comment">//开启在控制台输出信息</span></span><br><span class="line">      &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;  <span class="comment">//指定模板输出</span></span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">      template: <span class="string">&#x27;./index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;     <span class="comment">//自动生成全局变量,一旦引用,就会打包</span></span><br><span class="line">      $:<span class="string">&quot;jquery&quot;</span>,</span><br><span class="line">      jQuery:<span class="string">&quot;jquery&quot;</span>,</span><br><span class="line">      <span class="string">&#x27;window.jQuery&#x27;</span>:<span class="string">&quot;jquery&quot;</span>,</span><br><span class="line">      <span class="string">&#x27;window.$&#x27;</span>:<span class="string">&quot;jquery&quot;</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, </span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [<span class="string">&quot;env&quot;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,  </span><br><span class="line">  output: &#123;   <span class="comment">//打包输出配置路径</span></span><br><span class="line">    filename: <span class="string">&#x27;[name]-[hash].bundle.js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">    publicPath: <span class="string">&#x27;&#x27;</span> <span class="comment">//上线的绝对地址 可以为http://www.haohome.top/</span></span><br><span class="line">  &#125;,  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>webpack.dev.js 开发配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;  <span class="comment">//与公共配置合并</span></span><br><span class="line">  devtool: <span class="string">&#x27;inline-source-map&#x27;</span>,<span class="comment">//追踪错误和警告</span></span><br><span class="line">  devServer: &#123;  <span class="comment">//提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)</span></span><br><span class="line">    contentBase:path.resolve(__dirname, <span class="string">&quot;../&quot;</span>),  <span class="comment">//服务器的位置</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>webpack.prod.js 生产配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);<span class="comment">//代码压缩工具</span></span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  devtool: <span class="string">&#x27;source-map&#x27;</span>,	<span class="comment">//调试源码(debug)和运行基准测试(benchmark tests)很有用</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyJSPlugin(&#123;</span><br><span class="line">      sourceMap: <span class="literal">true</span>		<span class="comment">//如果配置了devtool则加改选项</span></span><br><span class="line">    &#125;)			</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line">/ 避免在生产中使用 inline-*** 和 <span class="built_in">eval</span>-***，因为它们可以增加 bundle 大小，并降低整体性能。</span><br></pre></td></tr></table></figure>

<p><strong>package.json配置NPM Scripts:</strong> </p>
<p>把 <code>scripts</code> 重新指向到新配置。我们将 <code>npm start</code> 定义为<em>开发环境</em>脚本，并在其中使用 <code>webpack-dev-server</code>，将 <code>npm run build</code> 定义为<em>生产环境</em>脚本:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server --progress --colors --open --config webpack.dev.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --progress --colors --config webpack.prod.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-指定环境"><a href="#4-2-指定环境" class="headerlink" title="4.2 指定环境"></a>4.2 指定环境</h4><p>许多 library 将通过与 <code>process.env.NODE_ENV</code> 环境变量关联，以决定 library 中应该引用哪些内容。当使用 <code>process.env.NODE_ENV === &#39;production&#39;</code> 时，一些 library 可能针对具体用户的环境进行代码优化，从而删除或添加一些重要代码。</p>
<p>可以使用 webpack 内置的 <code>DefinePlugin</code>为所有的依赖定义这个变量</p>
<p><strong>webpack.prod.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+ <span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);<span class="comment">//引入webpack</span></span><br><span class="line">  <span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">    devtool: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> UglifyJSPlugin(&#123;</span><br><span class="line">        sourceMap: <span class="literal">true</span></span><br><span class="line">      &#125;),</span><br><span class="line">+     <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">+       <span class="string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="built_in">JSON</span>.stringify(<span class="string">&#x27;production&#x27;</span>)<span class="comment">//指定为生产环境</span></span><br><span class="line">+     &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>一道简单的setTimeout面试题</title>
    <url>/2018/03/05/IT%E6%8A%80%E6%9C%AF/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>这是一道很入门的js面试题，考察JavaScript的单线程事件执行机制:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)	<span class="comment">//10*10</span></span><br><span class="line">  &#125;, <span class="number">10</span> * i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不理解原因的可能会认为输出0,1,2,3,4,5,6,7,8,9。事实并不是这样，原因很简单：</p>
<p>先看下JavaScript的单线程和异步：</p>
<img src="https://haohome.top/18-3-5/89406852.jpg" width="80%" >

<blockquote>
<ul>
<li>JS是单线程语言，浏览器只分配给JS一个主线程用来执行任务（函数）；</li>
<li>任务一次只能一次，任务会形成队列排队执行；</li>
<li>浏览器会为setTimeout（定时器，异步）单独开一个线程，异步任务完成后会触发回调函数，这时就把回调函数放到主线程任务队列等待执行</li>
</ul>
</blockquote>
<a id="more"></a>

<p>具体到例子：</p>
<ul>
<li>js没有块级作用域，for循环中i提升为全局变量；</li>
<li>setTimeout是异步执行，而for循环为同步执行，每执行一次for循环，setTimeout执行一次，触发一次回调函数；</li>
<li>for循环已经执行完时setTimeout内部回调函数开始，i值为10，故最后连续输出10个10</li>
</ul>
<p>如果需要输出连续数字，则需要采用闭包或ES6语法中的let</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, <span class="number">10</span> * j)</span><br><span class="line">  &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;  i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">10</span> * i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包：</p>
<ul>
<li>JavaScript的函数会形成作用域，闭包就是记住变量不受污染</li>
<li>i作为参数传入匿名函数被记住</li>
</ul>
<p>let：</p>
<ul>
<li>在{  }内形成块级作用域；</li>
<li>生成不同的i实例，形成一个匿名函数自调，类似于闭包</li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>js</tag>
        <tag>events</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JavaScript之this</title>
    <url>/2018/10/21/IT%E6%8A%80%E6%9C%AF/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B9%8Bthis/</url>
    <content><![CDATA[<h2 id="初识this"><a href="#初识this" class="headerlink" title="初识this"></a>初识this</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> greeting = <span class="string">&quot;Hello, I&#x27;m &quot;</span> + identify.call( <span class="built_in">this</span> );</span><br><span class="line">	<span class="built_in">console</span>.log( greeting );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">	name: <span class="string">&quot;Kyle&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">	name: <span class="string">&quot;Reader&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">identify.call( me ); <span class="comment">// KYLE</span></span><br><span class="line">identify.call( you ); <span class="comment">// READER</span></span><br><span class="line"></span><br><span class="line">speak.call( me ); <span class="comment">// Hello, I&#x27;m KYLE</span></span><br><span class="line">speak.call( you ); <span class="comment">// Hello, I&#x27;m READER</span></span><br></pre></td></tr></table></figure>

<p>这个代码片段允许 <code>identify()</code> 和 <code>speak()</code> 函数对多个 <em>环境</em> 对象（<code>me</code> 和 <code>you</code>）进行复用，而不是针对每个对象定义函数的分离版本。</p>
<a id="more"></a>

<p>如果不用this,也可以明确的将环境对象传递给 <code>identify()</code> 和 <code>speak()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> context.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> greeting = <span class="string">&quot;Hello, I&#x27;m &quot;</span> + identify( context );</span><br><span class="line">	<span class="built_in">console</span>.log( greeting );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify( you ); <span class="comment">// READER</span></span><br><span class="line">speak( me ); <span class="comment">// Hello, I&#x27;m KYLE</span></span><br></pre></td></tr></table></figure>

<p><code>this</code> 机制提供了更优雅的方式来隐含地“传递”一个对象引用，导致更加干净的API设计和更容易的复用。</p>
<p>将执行环境作为一个明确参数传递，通常比传递 <code>this</code> 执行环境要乱。</p>
<blockquote>
<p><strong>this可以自动引用执行环境对象</strong></p>
</blockquote>
<p>看下面这段代码,追踪foo被调用了几次:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">&quot;foo: &quot;</span> + num );<span class="comment">// 追踪 `foo` 被调用了多少次</span></span><br><span class="line">	<span class="built_in">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">		foo( i );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `foo` 被调用了多少次？</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 0 -- 这他妈怎么回事……？</span></span><br></pre></td></tr></table></figure>

<p><code>foo.count</code> <em>依然</em> 是 <code>0</code>, 即便四个 <code>console.log</code> 语句明明告诉我们 <code>foo(..)</code> 实际上被调用了四次。源于对于 <code>this</code>（在 <code>this.count++</code> 中）的含义进行了 <em>过于字面化</em> 的解释。</p>
<p>当代码执行 <code>foo.count = 0</code> 时，它确实向函数对象 <code>foo</code> 添加了一个 <code>count</code> 属性。但是对于函数内部的 <code>this.count</code> 引用，<code>this</code> 其实 <em>根本就不</em> 指向那个函数对象，即便属性名称一样，但根对象也不同，因而产生了混淆。</p>
<p>创建另一个对象来持有 <code>count</code> 属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">&quot;foo: &quot;</span> + num );</span><br><span class="line">	<span class="comment">// 追踪 `foo` 被调用了多少次</span></span><br><span class="line">	data.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">	count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">		foo( i );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `foo` 被调用了多少次？</span></span><br><span class="line"><span class="built_in">console</span>.log( data.count ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>看到这里,你应该知道this的指向，this指向了window，这涉及到了<strong>词法作用域</strong></p>
<p>为了从函数对象内部引用它自己，一般来说通过 this 是不够的。你通常需要通过一个指向它的词法标识符（变量）得到函数对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	foo.count = <span class="number">4</span>; <span class="comment">// `foo` 引用它自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 匿名函数（没有名字）不能引用它自己</span></span><br><span class="line">&#125;, <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line">第一个函数，称为“命名函数”，foo 是一个引用，可以用于在它内部引用自己。</span><br><span class="line">而在第二个例子中,传递给 <span class="built_in">setTimeout</span>(..) 的回调函数没有名称标识符（所以被称为“匿名函数”），所以没有合适的办法引用函数对象自己。</span><br></pre></td></tr></table></figure>

<ul>
<li>通过命名函数调用自己,每个地方都是用<code>foo</code> 标识符作为对函数的引用(完全依靠foo的词法作用域):</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">&quot;foo: &quot;</span> + num );</span><br><span class="line">	foo.count++;	<span class="comment">// 追踪 `foo` 被调用了多少次</span></span><br><span class="line">&#125;</span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">		foo( i );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 4  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>利用call强迫this指向foo</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">&quot;foo: &quot;</span> + num );	</span><br><span class="line">	<span class="comment">// 注意：由于 `foo` 的被调用方式（见下方），`this` 现在确实是 `foo`</span></span><br><span class="line">	<span class="built_in">this</span>.count++; <span class="comment">// 追踪 `foo` 被调用了多少次</span></span><br><span class="line">&#125;</span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">		foo.call( foo, i );<span class="comment">// 使用 `call(..)`，我们可以保证 `this` 指向函数对象(`foo`)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h2 id="解惑this"><a href="#解惑this" class="headerlink" title="解惑this"></a>解惑this</h2><h3 id="调用点（Call-site）"><a href="#调用点（Call-site）" class="headerlink" title="调用点（Call-site）"></a>调用点（Call-site）</h3><p>函数在代码中被调用的位置（<strong>不是被声明的位置</strong>）</p>
<p> <strong>调用栈（call-stack）</strong>: 使我们到达当前执行位置而被调用的所有方法的堆栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用栈是: `baz`</span></span><br><span class="line">    <span class="comment">// 我们的调用点是 global scope（全局作用域）</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&quot;baz&quot;</span> );</span><br><span class="line">    bar(); <span class="comment">// &lt;-- `bar` 的调用点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用栈是: `baz` -&gt; `bar`</span></span><br><span class="line">    <span class="comment">// 我们的调用点位于 `baz`</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&quot;bar&quot;</span> );</span><br><span class="line">    foo(); <span class="comment">// &lt;-- `foo` 的 call-site</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用栈是: `baz` -&gt; `bar` -&gt; `foo`</span></span><br><span class="line">    <span class="comment">// 我们的调用点位于 `bar`</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&quot;foo&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line">baz(); <span class="comment">// &lt;-- `baz` 的调用点</span></span><br></pre></td></tr></table></figure>

<h3 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h3><h4 id="默认绑定（Default-Binding"><a href="#默认绑定（Default-Binding" class="headerlink" title="默认绑定（Default Binding)"></a>默认绑定（Default Binding)</h4><p>该规则源于函数调用最常见的情况:独立函数调用。可以认为这种 <code>this</code> 规则是在没有其他规则适用时的默认规则。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 2  独立函数的调用,相当于window.foo(),对此方法调用的this实施了默认绑定,使this指向全局对象window</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>strict mode</code> 在这里生效，那么对于 <em>默认绑定</em> 来说全局对象是不合法的，所以 <code>this</code> 将被设置为 <code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">	&quot;use strict&quot;</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">// TypeError: `this` is `undefined`</span></span><br></pre></td></tr></table></figure>

<p><strong>有一个重要的细节:</strong> 即便所有的 <code>this</code> 绑定规则都是完全基于调用点的,如果<code>foo()</code>的内容没有在<code>strict mode</code>下执行,对于 <em>默认绑定</em> 来说全局对象是 <strong>唯一</strong> 合法的；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">	&quot;use strict&quot;</span>;</span><br><span class="line">	foo(); <span class="comment">// 2</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>foo()</code> 的调用点的 <code>strict mode</code> 状态与此无关。</p>
</blockquote>
<h4 id="隐含绑定（Implicit-Binding"><a href="#隐含绑定（Implicit-Binding" class="headerlink" title="隐含绑定（Implicit Binding)"></a>隐含绑定（Implicit Binding)</h4><p>调用点是否有一个环境对象（<code>context object</code>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p> <code>foo()</code> 被声明然后作为引用属性添加到 <code>obj</code> 上，<code>obj</code>通过函数引用调用<code>foo()</code>,<code>foo()</code>内的this就指代调用对象obj;</p>
<blockquote>
<p>可以这样理解:this是在函数执行时自动创建的一个关键词,会自动指向正在调用当前函数的对象</p>
</blockquote>
<h4 id="隐含丢失（Implicitly-Lost）"><a href="#隐含丢失（Implicitly-Lost）" class="headerlink" title="隐含丢失（Implicitly Lost）"></a>隐含丢失（Implicitly Lost）</h4><p>当一个 <em>隐含绑定</em> 丢失了它的绑定，这通常意味着它会退回到 <em>默认绑定</em>， 根据 <code>strict mode</code> 的状态，其结果不是全局对象就是 <code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数引用！</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">// `a` 也是一个全局对象的属性</span></span><br><span class="line">bar(); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里bar仅仅是对foo的一个应用而已,调用点是bar(),因此默认绑定适用这里;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// `fn` 只不过 `foo` 的另一个引用</span></span><br><span class="line">	fn(); <span class="comment">// &lt;-- 调用点!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">// `a` 也是一个全局对象的属性</span></span><br><span class="line">doFoo( obj.foo ); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure>

<p>看到这里,可以看出this的指向是由函数对象的调用点决定的</p>
<h4 id="明确绑定（Explicit-Binding）"><a href="#明确绑定（Explicit-Binding）" class="headerlink" title="明确绑定（Explicit Binding）"></a>明确绑定（Explicit Binding）</h4><p>如果你想强制一个函数调用使用某个特定对象作为 <code>this</code> 绑定,通过call或apply方法,用于指定this</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>foo.call(..)</code> 使用 <em>明确绑定</em> 来调用 <code>foo</code>，允许我们强制函数的 <code>this</code> 指向 <code>obj</code>。</p>
<p>如果你传递一个简单基本类型值（<code>string</code>，<code>boolean</code>，或 <code>number</code> 类型）作为 <code>this</code> 绑定，那么这个基本类型值会被包装在它的对象类型中（分别是 <code>new String(..)</code>，<code>new Boolean(..)</code>，或 <code>new Number(..)</code>）。这通常称为“封箱（boxing）”。</p>
<p><strong>硬绑定（Hard Binding）</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	foo.call( obj );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">setTimeout</span>( bar, <span class="number">100</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `bar` 将 `foo` 的 `this` 硬绑定到 `obj`</span></span><br><span class="line"><span class="comment">// 所以它不可以被覆盖</span></span><br><span class="line">bar.call( <span class="built_in">window</span> ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>我们创建了一个函数 <code>bar()</code>，在它的内部手动调用 <code>foo.call(obj)</code>，由此强制 <code>this</code> 绑定到 <code>obj</code> 并调用 <code>foo</code>。无论你过后怎样调用函数 <code>bar</code>，它总是手动使用 <code>obj</code> 调用 <code>foo</code>。这种绑定即明确又坚定，所以我们称之为 <em>硬绑定（hard binding）</em></p>
<p>用 <em>硬绑定</em> 将一个函数包装起来的最典型的方法，是为所有传入的参数和传出的返回值创建一个通道：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="built_in">this</span>.a, something );</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> foo.apply( obj, <span class="built_in">arguments</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p><strong>API 调用的“环境”</strong></p>
<p>许多库中的函数，和许多在 JavaScript 语言以及宿主环境中的内建函数，都提供一个可选参数，通常称为“环境（context）”，这种设计作为一种替代方案来确保你的回调函数使用特定的 <code>this</code> 而不必非得使用 <code>bind(..)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( el, <span class="built_in">this</span>.id );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	id: <span class="string">&quot;awesome&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `obj` 作为 `this` 来调用 `foo(..)`</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj ); <span class="comment">// 1 awesome  2 awesome  3 awesome</span></span><br></pre></td></tr></table></figure>

<p>从内部来说，几乎可以确定这种类型的函数是通过 <code>call(..)</code> 或 <code>apply(..)</code> 来使用 <em>明确绑定</em> </p>
<h4 id="new-绑定（new-Binding）"><a href="#new-绑定（new-Binding）" class="headerlink" title="new 绑定（new Binding）"></a><code>new</code> 绑定（<code>new</code> Binding）</h4><p>当在函数前面被加入 <code>new</code> 调用时:</p>
<ol>
<li>创建一个新的空对象</li>
<li>自动让新的子对象继承构造函数继承原型对象</li>
<li>调用构造函数，将构造函数中的this执行正在创建的新的空对象中强行添加新成员将新对象地址返回给变量</li>
<li>将新对象地址返回给变量保存</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo( <span class="number">2</span> );</span><br><span class="line"><span class="built_in">console</span>.log( bar.a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>以上就是函数调用中的四种 <code>this</code> 绑定规则,通常需要找到调用点然后考察哪一种规则适用于它。但四种规则是有优先级的,</p>
<h4 id="判定-this"><a href="#判定-this" class="headerlink" title="判定 this"></a>判定 <code>this</code></h4><ol>
<li><p>函数是通过 <code>new</code> 被调用的吗（<strong>new 绑定</strong>）？如果是，<code>this</code> 就是新构建的对象。</p>
<p><code>var bar = new foo()</code></p>
</li>
<li><p>函数是通过 <code>call</code> 或 <code>apply</code> 被调用（<strong>明确绑定</strong>），甚至是隐藏在 <code>bind</code> <em>硬绑定</em> 之中吗？如果是，<code>this</code> 就是那个被明确指定的对象。</p>
<p><code>var bar = foo.call( obj2 )</code></p>
</li>
<li><p>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（<strong>隐含绑定</strong>）？如果是，<code>this</code> 就是那个环境对象。</p>
<p><code>var bar = obj1.foo()</code></p>
</li>
<li><p>否则，使用默认的 <code>this</code>（<strong>默认绑定</strong>）。如果在 <code>strict mode</code> 下，就是 <code>undefined</code>，否则是 <code>global</code> 对象。</p>
<p><code>var bar = foo()</code></p>
</li>
</ol>
<p>以上，就是理解对于普通的函数调用来说的 <code>this</code> 绑定规则 <em>所需的全部</em>。</p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>YDKJS</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JavaScript之词法作用域与动态作用域</title>
    <url>/2018/10/20/IT%E6%8A%80%E6%9C%AF/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B9%8B%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在写代码的过程中,我们经常分不清作用域中变量的值指向什么,主要原因是我们分不清楚是应该按照函数的调用顺序还是按照函数位置的嵌套顺序查找变量.作用域有两种工作模式:词法作用域和动态作用域,词法作用域也叫静态作用域.</p>
<blockquote>
<ul>
<li>词法作用域关心函数在<strong>何处声明</strong>，作用域链基于作用域嵌套 </li>
<li>动态作用域关心函数在<strong>何处调用</strong>，作用域链基于调用栈</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p><a href="https://www.cnblogs.com/xiaohuochai/p/5700095.html">词法作用域是定义在词法阶段的作用域，是由写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变</a>.</p>
<p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">foo();  <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>因为bar函数是在全局声明的，所以是输出全局变量a的值</p>
<p>词法作用域中又分为函数作用域和块级作用域,JavaScript没有动态作用域,它是基于函数作用域的,但同时也有块级作用域,如with关键字、try-catch语句的catch子句、let关键字（ES6）、const关键字（ES6）</p>
<h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><p>我们经常会把词法作用域和this机制弄混淆,这是因为this机制从某种程度上与动态作用域类似.</p>
<p>动态作用域并不关心函数和作用域是如何声明以及在任何处声明的，只关心它们从何处调用</p>
<p>继续拿上面的例子,如果处于动态作用域,变量a应首先在bar()中查找,没有找到会顺着调用栈在调用bar()函数的地方也就是foo()函数中查找,找到赋值a为1,所以输出1</p>
<blockquote>
<p>两种作用域的区别，简而言之，词法作用域是在定义时确定的，而动态作用域是在运行时确定的</p>
</blockquote>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>YDKJS</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JavaScript之闭包</title>
    <url>/2018/10/18/IT%E6%8A%80%E6%9C%AF/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B9%8B%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><blockquote>
<p>闭包是函数和声明该函数的词法环境的组合。(来自:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">MDN</a>)</p>
<p>另一种定义:<strong>是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另外一个函数。</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>; <span class="comment">// name 是一个被 init 创建的局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// displayName() 是内部函数,一个闭包</span></span><br><span class="line">        alert(name); <span class="comment">// 使用了父函数中声明的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    displayName();</span><br><span class="line">&#125;</span><br><span class="line">init();		<span class="comment">// 弹出Mozilla</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>init()</code> 创建了一个局部变量 <code>name</code> 和一个名为 <code>displayName()</code> 的函数。</li>
<li><code>displayName()</code> 内没有自己的局部变量，然而它可以访问到外部函数的变量name;</li>
<li>但是，如果有同名变量 <code>name</code> 在 <code>displayName()</code> 中被定义，则会优先使用 <code>displayName()</code> 中定义的 <code>name</code> 。</li>
</ul>
<p>这个<em>词法作用域</em>的例子介绍了引擎是如何解析函数嵌套中的变量的</p>
<a id="more"></a>

<p>闭包是由函数以及创建该函数的词法环境组合而成,<strong>这个环境包含了这个闭包创建时所能访问的所有局部变量</strong>。函数<code>displayName()</code>具有一个涵盖<code>init()</code>作用域的闭包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc = makeFunc();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>myFunc</code> 是执行 <code>makeFunc</code> 时创建的 <code>displayName</code> 函数实例的引用，而 <code>displayName</code> 实例<strong>仍</strong>可访问其词法作用域中的变量(闭包环境)，即可以访问到 <code>name</code> 。</p>
</li>
<li><p>当 <code>myFunc</code> 被调用时，<code>name</code> 仍可被访问，其值 <code>Mozilla</code> 就被传递到<code>alert</code>中。</p>
</li>
</ul>
<p>再看一个例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">4</span>)); <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们定义了 <code>makeAdder(x)</code> 函数，它接受一个参数 <code>x</code> ，并返回一个新的函数</p>
</li>
<li><p>返回的函数接受一个参数 <code>y</code>，并返回<code>x+y</code>的值</p>
</li>
</ul>
<p><code>makeAdder</code> 是一个函数工厂 ,其创建了两个新函数,新函数执行时其参数<code>y</code>与<code>makeAdder</code>形成的闭包环境中的参数<code>x</code>相加;</p>
<p>而<code>add5</code> 和 <code>add10</code> 都是闭包,它们共享相同的函数定义，但是保存了不同的词法环境。在 <code>add5</code>的环境中，<code>x</code> 为 5。而在 <code>add10</code> 中，<code>x</code> 则为 10。</p>
<p>这就是闭包: 它允许将函数与其所操作的某些数据（环境）关联起来,类似于面向对象,允许对象的属性与一个或多个方法关联</p>
<h2 id="2-一个常见的错误-循环和闭包"><a href="#2-一个常见的错误-循环和闭包" class="headerlink" title="2. 一个常见的错误:循环和闭包"></a>2. 一个常见的错误:循环和闭包</h2><iframe width="100%" height="200" src="//jsrun.net/w2hKp/embedded/js,result/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>这是一道经典的面试题,<code>setTimeout</code>定时器是一个异步回调的方法,当执行定时器回调函数时,回调函数内部的i都通过词法作用域共享变量i,而此时<code>for</code>循环已经终止,i值为6,因此每个打印出来的都为6</p>
<p>而如果希望打印的是1,2,3,4,5,通过声明并立即执行一个函数来创建作用域,循环中的每个迭代都给自己捕获一个<code>i</code>的副本储存,结果就能实现,如:</p>
<iframe width="100%" height="200" src="//jsrun.net/N2hKp/embedded/js,result/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>ES6语法中let会创建块级作用域,很简单就能实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;,i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-用闭包模拟私有方法-模块模式"><a href="#3-用闭包模拟私有方法-模块模式" class="headerlink" title="3.用闭包模拟私有方法(模块模式)"></a>3.用闭包模拟私有方法(模块模式)</h2><p>在java的编程语言中,是支持方法声明为私有的,即他们只能被同一个类中的其他方法所调用,JavaScript不支持(typescript支持),但js是可以通过闭包的方式模拟私有方法;</p>
<p><strong>私有化方法有利于限制对代码的访问</strong>,还提供了管理全局命名空间的能力,避免非核心方法影响了代码的公共接口部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> count1= Counter()</span><br><span class="line"><span class="built_in">console</span>.log(count1.value());	<span class="comment">//0</span></span><br><span class="line">count1.increment();</span><br><span class="line">count1.increment();</span><br><span class="line"><span class="built_in">console</span>.log(count1.value());	<span class="comment">//2</span></span><br><span class="line">count1.decrement();</span><br><span class="line">count1.log(Counter.value());	<span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> count2 = Counter()</span><br><span class="line"><span class="built_in">console</span>.log(count2.value())		<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p><code>Counter()</code>形成了闭包环境(可认为是模块),返回三个对象方法:<code>increment</code>、<code>decrement</code> 和 <code>value</code>,这三个公共函数具有涵盖实例内部作用域的闭包,其本质也可看做是<strong>模块的公共API</strong>,通过它访问闭包环境内的私有属性和方法:<code>privateCounter</code> 的变量和名为 <code>changeBy</code> 的函数;</p>
<blockquote>
<p>通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p>
</blockquote>
<p>当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，我们已经创造了可以观察和实践闭包的条件。</p>
<p>对于模块模式,需要具备两个必要条件:</p>
<ol>
<li>必须有外部的封闭函数,形成私有作用域,该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)</li>
<li>封闭函数必须返回至少一个内部函数,即模块的公共API,以访问或者修改私有的状态</li>
</ol>
<p>上一个示例代码中有一个叫作<code>Counter()</code>的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来实现<strong>单例模式</strong>：</p>
<blockquote>
<p>采用匿名函数自调</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(count.value());	<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>YDKJS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于递归计算</title>
    <url>/2017/02/23/IT%E6%8A%80%E6%9C%AF/%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h3 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h3><p>在一个函数中直接或间接的调用自己的过程就是递归</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 自己调用自己，称为递归调用</span></span><br><span class="line">  fun();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;m2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>递归的两种形式:</p>
<ul>
<li><strong>函数+变量</strong></li>
<li><strong>函数+函数</strong></li>
</ul>
</blockquote>
<a id="more"></a>

<h4 id="函数-变量"><a href="#函数-变量" class="headerlink" title="函数+变量"></a>函数+变量</h4><h5 id="用递归来求5的阶乘"><a href="#用递归来求5的阶乘" class="headerlink" title="用递归来求5的阶乘"></a>用递归来求5的阶乘</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(n! = n * (n-1)!)</span></span><br><span class="line"><span class="comment">//f(n)=n*f(n-1)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n*func(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="递归的实现"><a href="#递归的实现" class="headerlink" title="递归的实现"></a>递归的实现</h5><p>1） 边界条件：决定递归何时向上返回</p>
<p>2） 递归前进：只要没满足递归的边界条件，就一直向下调用自己</p>
<p>3） 递归返回：当满足边界条件时，向上返回（将所有计算出来的值，依次返回给调用者）</p>
<h4 id="函数-函数"><a href="#函数-函数" class="headerlink" title="函数+函数"></a>函数+函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">斐波拉契数列(兔子生兔子题目)--从出生后第<span class="number">3</span>个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子对数为多少</span><br><span class="line"><span class="comment">// 产量分析：1， 1， 2， 3， 5， 8， 13， 21 。。。</span></span><br><span class="line"><span class="comment">// 第n个月的兔子总数  =  第n-1个月的兔子总数 + 第n-2个月的兔子总数</span></span><br><span class="line"><span class="comment">// 问题： 求任意月兔子的总数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> calc(n-<span class="number">1</span>)+calc(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一道面试题"><a href="#一道面试题" class="headerlink" title="一道面试题"></a>一道面试题</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;		<span class="comment">//在页面渲染出value值</span></span><br><span class="line">  value:<span class="number">1</span>,</span><br><span class="line">  children:[</span><br><span class="line">    &#123;</span><br><span class="line">      value:<span class="number">2</span>,</span><br><span class="line">      children:[]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      value:<span class="number">3</span>,</span><br><span class="line">      children:[&#123;</span><br><span class="line">        value:<span class="number">4</span>,</span><br><span class="line">        children:[]</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//采用无序列表</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">&quot;&lt;ul&gt;&quot;</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> li=<span class="string">&quot;&lt;li&gt;&quot;</span>+obj.value+<span class="string">&quot;&lt;/li&gt;&quot;</span>;</span><br><span class="line">  arr.push(li);</span><br><span class="line">  obj.children.map(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fun(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fun(obj);</span><br><span class="line">arr.push(<span class="string">&quot;&lt;/ul&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> str=arr.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> div=<span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">div.innerHTML=str;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>创建对象的Object.create与new</title>
    <url>/2018/04/07/IT%E6%8A%80%E6%9C%AF/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84Object.create%E4%B8%8Enew/</url>
    <content><![CDATA[<p>创建对象有几种方式:</p>
<ul>
<li><p>直接量:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1=&#123;<span class="attr">name</span>:<span class="string">&quot;xiaowang&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=<span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>:<span class="string">&quot;xiaowang&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj1,obj2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> M=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="built_in">this</span>.name=name&#125;;</span><br><span class="line"><span class="keyword">var</span> obj3=<span class="keyword">new</span> M(<span class="string">&#x27;xiaowang&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.create</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p=&#123;<span class="attr">name</span>:<span class="string">&#x27;xiaowang&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj4=<span class="built_in">Object</span>.create(p);</span><br><span class="line"><span class="built_in">console</span>.log(obj4);</span><br></pre></td></tr></table></figure>

<p>对应的输出结果为:</p>
<p><img src="https://haohome.top/18-4-7/88488666.jpg" alt="img"></p>
<a id="more"></a>
<p>可以看到,Object.create方法得到的对象是空对象，再输出各自对象的name属性看看:</p>
<p><code>console.log(obj2.name,obj3.name,obj4.name)</code></p>
<p>得到的结果为<code>xiaowang xiaowang xiaowang</code></p>
<p>这是为什么???</p>
</li>
</ul>
<ol>
<li><p><code>Object.create</code> 的实现方式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;&#125;</span></span><br><span class="line">obj1.name = <span class="string">&#x27;jian&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// &#x27;jian&#x27;, </span></span><br><span class="line">conosle.log(obj2.__proto__===obj1.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>obj2是空对象,但obj2.name输出了’jian’,obj2继承自obj1的原型对象</p>
<p>由此可以总结<code>Object.create()</code>做了： </p>
</li>
</ol>
<p>​    1. 创建空对象{} </p>
<p>​    2. 指定空对象{}继承自参数的原型对象,即空对象的    <code>__proto__</code> 指向Object.create()参数的原型对象。</p>
<ol start="2">
<li><p><code>var obj1=new M(&#123;name:&#39;xiaowang&#39;&#125;)</code> 的实现方式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义构造函数Person </span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = firstName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义Person原型对象的新方法</span></span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello, I&#x27;m &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"><span class="comment">//对象调用method</span></span><br><span class="line">person1.sayHello(); <span class="comment">// logs &quot;Hello, I&#x27;m Alice&quot;</span></span><br></pre></td></tr></table></figure>

<p>由此可以总结<code>new</code>做了： </p>
</li>
<li><p>创建实例对象person1 </p>
</li>
<li><p>调用构造函数(Person)初始化person1成员变量（name)。 </p>
</li>
<li><p>指定实例对象的继承自Person.prototype对象。即<code>person1.__proto__</code>指向构造函数的原型对象Person.prototype。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">对比</th>
<th align="center">Object.create</th>
<th align="center">new</th>
</tr>
</thead>
<tbody><tr>
<td align="center">创建对象</td>
<td align="center">创建空对象</td>
<td align="center">创建实例对象,并将参数初始化赋值</td>
</tr>
<tr>
<td align="center">继承</td>
<td align="center">空对象继承自参数对象的原型对象,本身为空对象</td>
<td align="center">实例对象继承自构造函数的原型对象</td>
</tr>
</tbody></table>
<p>  总结:Object.create得到的对象未实例化,本身为空对象,可继承对象,而new得到的对象是实例化的对象</p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>利用H5画随机色圆</title>
    <url>/2018/03/06/IT%E6%8A%80%E6%9C%AF/%E5%88%A9%E7%94%A8H5%E7%94%BB%E9%9A%8F%E6%9C%BA%E8%89%B2%E5%9C%86/</url>
    <content><![CDATA[<p>忽然想到曾经遇到的一个案例：</p>
<p>​    <strong>在页面上绘制随机数量的圆并填充随机色，但鼠标点击圆时该圆逐渐放大，同时透明度降低，直至消失。</strong></p>
<p>在这里用代码重现下，首先分析下需求：</p>
<ul>
<li><p>绘制页面：</p>
<ul>
<li>生成随机数，根据随机数生成随机颜色</li>
<li>利用svg绘图技术在页面绘制随机数量的圆</li>
<li>将圆填充随机色</li>
</ul>
</li>
<li><p>JS事件：</p>
<ul>
<li><p>为每个圆绑定单击事件</p>
</li>
<li><p>创建定时器</p>
</li>
</ul>
</li>
</ul>
<a id="more"></a>


<p>代码：</p>
<ol>
<li>生成随机数和随机颜色方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*获取指定范围内的随机数字*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomNum</span>(<span class="params">min,max</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n=<span class="built_in">Math</span>.random()*(max-min)+min;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*生成随机色*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomColor</span>(<span class="params">min,max</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r=randomNum(min,max);</span><br><span class="line">    <span class="keyword">var</span> g=randomNum(min,max);</span><br><span class="line">    <span class="keyword">var</span> b=randomNum(min,max);</span><br><span class="line">    <span class="keyword">var</span> a=<span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`rgba(<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>,<span class="subst">$&#123;a&#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用svg绘图</li>
</ol>
<p>html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">id</span>=<span class="string">&quot;svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1000px&quot;</span>  <span class="attr">height</span>=<span class="string">&quot;500px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> svg=<span class="built_in">document</span>.getElementById(<span class="string">&quot;svg&quot;</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//创建圆元素</span></span><br><span class="line">	<span class="keyword">var</span> c=<span class="built_in">document</span>.createElementNS(<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>,<span class="string">&quot;circle&quot;</span>);</span><br><span class="line">    c.setAttribute(<span class="string">&quot;r&quot;</span>,randomNum(<span class="number">10</span>,<span class="number">80</span>));</span><br><span class="line">    c.setAttribute(<span class="string">&quot;cx&quot;</span>,randomNum(<span class="number">0</span>,<span class="number">800</span>));</span><br><span class="line">    c.setAttribute(<span class="string">&quot;cy&quot;</span>,randomNum(<span class="number">0</span>,<span class="number">400</span>));</span><br><span class="line">    c.setAttribute(<span class="string">&quot;fill&quot;</span>,randomColor(<span class="number">0</span>,<span class="number">255</span>));</span><br><span class="line">    c.setAttribute(<span class="string">&quot;fill-opacity&quot;</span>,<span class="built_in">Math</span>.random());</span><br><span class="line">    svg.appendChild(c)</span><br><span class="line">  <span class="comment">//绑定单击事件</span></span><br><span class="line">  c.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that=<span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//设置循环定时器</span></span><br><span class="line">    <span class="keyword">var</span> timer=<span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> r=that.getAttribute(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">      r*=<span class="number">1.05</span>;</span><br><span class="line">      that.setAttribute(<span class="string">&quot;r&quot;</span>,r);</span><br><span class="line">      <span class="keyword">var</span> fillOpac=that.getAttribute(<span class="string">&quot;fill-opacity&quot;</span>);</span><br><span class="line">      fillOpac*=<span class="number">0.9</span>;</span><br><span class="line">      that.setAttribute(<span class="string">&quot;fill-opacity&quot;</span>,fillOpac);</span><br><span class="line">      <span class="comment">//设置循环定时器停止条件</span></span><br><span class="line">      <span class="keyword">if</span>(fillOpac&lt;<span class="number">0.001</span>)&#123;</span><br><span class="line">      	<span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        timer=<span class="literal">null</span>;</span><br><span class="line">       	svg.removeChild(that);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="number">20</span>)()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附上<a href="https://codepen.io/hfood/full/gvVovo/">codePen链接</a></p>
<p>效果图:</p>
<img src="https://haohome.top/18-3-8/79565300.jpg" width="80%">

]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>前端网摘</title>
    <url>/2018/02/20/IT%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF%E7%BD%91%E6%91%98/</url>
    <content><![CDATA[<h2 id="1-移动端网摘"><a href="#1-移动端网摘" class="headerlink" title="1. 移动端网摘"></a>1. 移动端网摘</h2><ol>
<li><a href="https://www.w3cplus.com/css/viewports.html">viewports剖析</a></li>
<li><a href="https://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html">使用Flexible实现手淘H5页面的终端适配</a></li>
<li><a href="https://www.w3cplus.com/css/vw-for-layout.html">再聊移动端适配</a></li>
<li><a href="https://www.w3cplus.com/mobile/vw-layout-in-vue.html">如何在Vue项目中使用vw实现移动端适配</a></li>
<li><a href="https://material.io/devices/">谷歌device列表</a></li>
<li><a href="http://www.shejidaren.com/examples/tools/chichun/ui-design-spec.html#nogo">最新Android &amp; iOS设计尺寸规范——2015</a></li>
<li><a href="http://www.woshipm.com/pmd/176328.html">px、pt、ppi、dpi、dp、sp之间的关系</a></li>
</ol>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>网摘</tag>
      </tags>
  </entry>
  <entry>
    <title>原生JS实现瀑布流效果</title>
    <url>/2018/03/10/IT%E6%8A%80%E6%9C%AF/%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@name</span>:瀑布流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>:parent(容器元素)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>:oneGap(只有一列时元素的间距,其他列数自适应)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>:自适应瀑布流,多列间距自适应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    waterFall: <span class="function"><span class="keyword">function</span> (<span class="params">parent, oneGap = <span class="number">0</span>, padding = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">      <span class="comment">/**容器的宽度(包含内边距、边框) */</span></span><br><span class="line">      <span class="keyword">var</span> width = parent.offsetWidth - padding;</span><br><span class="line">      <span class="comment">/**容器内盒子元素的宽度(包含内边距、边框)  */</span></span><br><span class="line">      <span class="keyword">var</span> items = parent.children;</span><br><span class="line">      <span class="keyword">var</span> itemWidth = items[<span class="number">0</span>].offsetWidth;</span><br><span class="line">      <span class="comment">/* 所有空隙的宽度和*/</span></span><br><span class="line">      <span class="keyword">var</span> gap = (width - <span class="built_in">parseInt</span>(width / itemWidth) * itemWidth);</span><br><span class="line">      <span class="comment">/**计算每列放的盒子元素个数 */</span></span><br><span class="line">      <span class="keyword">var</span> columns = <span class="built_in">parseInt</span>(width / (itemWidth + gap / <span class="number">2</span>));</span><br><span class="line">      <span class="comment">/**定义一个空数组,用来储存每列元素的高度 */</span></span><br><span class="line">      <span class="keyword">var</span> arr = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">        <span class="comment">/**1.将第一行元素的高度都存到arr中 */</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; columns) &#123;</span><br><span class="line">          items[i].style.top = padding + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">          items[i].style.left = (itemWidth + gap) * i + padding - padding * (i % <span class="number">2</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">          arr.push(items[i].offsetHeight);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/**2.找到每一行的最小高度 */</span></span><br><span class="line">          <span class="keyword">var</span> minHeight = arr[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minHeight &gt; arr[j]) &#123;</span><br><span class="line">              minHeight = arr[j]; <span class="comment">//获得当前行最小高度</span></span><br><span class="line">              index = j; <span class="comment">//记下当前列下标</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/**3.设置下一行第一个盒子的位置,</span></span><br><span class="line"><span class="comment">           * top值就是最小高度值+gap</span></span><br><span class="line"><span class="comment">           * left值就是最小列距离左边的距离</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">if</span> (gap != <span class="number">0</span>) &#123;</span><br><span class="line">            items[i].style.top = arr[index] + oneGap + padding + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">            items[i].style.left = items[index].offsetLeft + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">            <span class="comment">/**4.修改最小列的高度 </span></span><br><span class="line"><span class="comment">             * 最小列的高度 = 当前自己的高度 + 拼接过来的高度 + 间隙的高度</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            arr[index] = arr[index] + items[i].offsetHeight + oneGap;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            items[i].style.top = arr[index] + oneGap + padding + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">            items[i].style.left = padding + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">            arr[index] = arr[index] + items[i].offsetHeight + oneGap;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (columns === <span class="number">1</span>) &#123;</span><br><span class="line">          parent.style.height = arr[<span class="number">0</span>] + oneGap + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> height = arr[<span class="number">0</span>] &gt; arr[<span class="number">1</span>] ? arr[<span class="number">0</span>] : arr[<span class="number">1</span>]</span><br><span class="line">          <span class="keyword">if</span> (i &lt; items.length - <span class="number">1</span>) &#123;</span><br><span class="line">            parent.style.height = height + oneGap + padding + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.style.height = height + padding * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>图片上传与压缩</title>
    <url>/2018/09/30/IT%E6%8A%80%E6%9C%AF/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E4%B8%8E%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<blockquote>
<p> 最近在做关于移动端图片上传方面,项目中主要需要实现图片的本地预览、压缩和上传</p>
</blockquote>
<h2 id="1-图片选择和预览"><a href="#1-图片选择和预览" class="headerlink" title="1. 图片选择和预览"></a>1. 图片选择和预览</h2><p>添加<code>accept</code>属性,控制选择文件的类型为拍照和图像文件,设置multiple支持图片文件多选,监听<code>input</code>的<code>change</code>事件获取选择对象文件,每个文件都是Blob类型</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;file2&quot;</span>&gt;</span>多个图片上传<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/gif,image/jpeg,image/png&quot;</span> <span class="attr">multiple</span> <span class="attr">id</span>=<span class="string">&#x27;file2&#x27;</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;preview2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 模拟jQuery</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> $ = <span class="function"><span class="params">selector</span> =&gt;</span> <span class="built_in">document</span>.querySelector(selector)</span></span><br><span class="line"><span class="javascript"><span class="comment">// 多个图片</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> file2 = $(<span class="string">&quot;#file2&quot;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> preview2 = $(<span class="string">&#x27;#preview2&#x27;</span>)</span></span><br><span class="line"><span class="javascript">file2.onchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> fileList = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">this</span>.files)</span></span><br><span class="line"><span class="javascript">    fileList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> domImg = <span class="keyword">new</span> Image();</span></span><br><span class="line">        domImg.src = URL.createObjectURL(item)</span><br><span class="line">        preview2.appendChild(domImg)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-图片的压缩"><a href="#2-图片的压缩" class="headerlink" title="2. 图片的压缩"></a>2. 图片的压缩</h2><p>当前手机拍照质量月来越高,带来的问题就是大小也越来越大,直接上传原图,上传速度会很低,甚至很可能上传失败,而且后续加载也影响速度</p>
<p>下面是封装了一个压缩图片的方法,实现的原理是,利用canvas将图片绘制出来,并导出canvas图片.主要通过图片的缩放和控制canvas导出图片质量来实现图片的体积压缩</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩图片</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;file&#125;</span> </span>输入图片</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;quality&#125;</span> </span>图片质量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>resolved promise 返回压缩后的新图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compressImg</span>(<span class="params">file, quality</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">      img.src = URL.createObjectURL(file)</span><br><span class="line">      img.onerror = <span class="function"><span class="params">error</span> =&gt;</span> reject(error)</span><br><span class="line">      img.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line">          <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">          <span class="keyword">var</span> canvasWidth = <span class="built_in">document</span>.documentElement.clientWidth * <span class="built_in">window</span>.devicePixelRatio</span><br><span class="line">          <span class="keyword">var</span> canvasHeight = <span class="built_in">document</span>.documentElement.clientHeight * <span class="built_in">window</span>.devicePixelRatio</span><br><span class="line">          <span class="comment">// 水平方向想缩放比</span></span><br><span class="line">          <span class="keyword">var</span> scaleX = canvasWidth / img.width</span><br><span class="line">          <span class="keyword">var</span> scaleY = canvasHeight / img.height</span><br><span class="line">          <span class="comment">// 取缩放比更小的比例</span></span><br><span class="line">          <span class="keyword">var</span> scale = <span class="built_in">Math</span>.min(scaleX, scaleY)</span><br><span class="line">          <span class="comment">// 画布上绘制的图片尺寸</span></span><br><span class="line">          <span class="keyword">const</span> imageWidth = img.width * scale</span><br><span class="line">          <span class="keyword">const</span> imageHeight = img.height * scale</span><br><span class="line">          canvas.width = imageWidth</span><br><span class="line">          canvas.height = imageHeight</span><br><span class="line">          ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, imageWidth, imageHeight)</span><br><span class="line">          canvas.toBlob(<span class="function"><span class="params">file</span> =&gt;</span> resolve(file), <span class="string">&quot;image/jpeg&quot;</span>, quality);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">file2.onchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileList = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">this</span>.files)</span><br><span class="line">    fileList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        compressImg(imgfile, <span class="number">.5</span>).then(<span class="function"><span class="params">blobFile</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> domImg = <span class="keyword">new</span> Image();</span><br><span class="line">            domImg.src = URL.createObjectURL(blobFile)</span><br><span class="line">            preview2.appendChild(domImg)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-图片上传"><a href="#3-图片上传" class="headerlink" title="3. 图片上传"></a>3. 图片上传</h2><p>文件上传是通过<code>FormData</code>创建表单数据，并发起 ajax <code>POST</code>请求;</p>
<blockquote>
<p>发送<code>FormData</code>数据时，浏览器会自动设置<code>Content-Type</code>为合适的值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传图片</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;File&#125;</span> </span>file 待上传的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span> </span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params">file,url</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 准备表单数据</span></span><br><span class="line">        <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">        formData.append(<span class="string">&#x27;file&#x27;</span>, file)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交请求</span></span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">&#x27;POST&#x27;</span>, url)</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.readyState === XMLHttpRequest.DONE &amp;&amp; <span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">            resolve(<span class="built_in">JSON</span>.parse(<span class="built_in">this</span>.responseText))</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="built_in">this</span>.responseText)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(formData)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>最后奉上JSrun的demo:</p>
<iframe width="100%" height="300" src="//jsrun.net/kyhKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收机制与内存管理</title>
    <url>/2018/07/11/IT%E6%8A%80%E6%9C%AF/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-垃圾回收机制"><a href="#1-垃圾回收机制" class="headerlink" title="1. 垃圾回收机制"></a>1. 垃圾回收机制</h2><p>JavaScript是一门高级语言,具有自动垃圾回收机制(Garbage Collecatio), js创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放,其主要原理为:</p>
<blockquote>
<p> 垃圾收集器会<strong>定期（周期性）</strong>找出那些不在继续使用的变量，然后释放其内存。</p>
</blockquote>
<p>JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照<strong>固定的时间间隔周期性的执行</strong>。</p>
<ul>
<li>任何程序语言,内存生命周期都是一致的:<ol>
<li>分配你所需要的内存</li>
<li>使用分配到的内存（读、写）</li>
<li>不需要时将其释放/归还 </li>
</ol>
</li>
</ul>
<a id="more"></a>

<p><strong>JavaScript的内存分配</strong></p>
<ol>
<li><p>在<strong>定义变量时就完成了内存分配</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 给字符串分配内存</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过函数调用分配内存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 分配一个 Date 对象</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>); <span class="comment">// 分配一个 DOM 元素</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>当内存不再需要使用时释放</strong></p>
<p>不再使用的变量也就是内存生命周期的结束,只可能是局部变量,局部变量只在函数的执行过程中存在,<strong>全局变量的生命周期直至浏览器卸载页面才会结束</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;hanzichi&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;hanzichi&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = fn1();</span><br><span class="line"><span class="keyword">var</span> b = fn2();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面定义了两个function，分别叫做fn1和fn2:</p>
<ul>
<li>当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象<code>&#123;name: &#39;hanzichi&#39;, age: 10&#125;</code>,当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；</li>
<li>在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。</li>
</ul>
</blockquote>
<p>所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，垃圾回收算法主要依赖于引用的概念。</p>
<blockquote>
<p>在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。</p>
<p>例如:一个Javascript对象具有对它<a href="https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain">原型</a>的引用（隐式引用）和对它属性的引用（显式引用）。</p>
</blockquote>
<h3 id="1-1-标记清除"><a href="#1-1-标记清除" class="headerlink" title="1.1 标记清除"></a>1.1 标记清除</h3><p>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span> ;    <span class="comment">//被标记 ，进入环境  </span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span> ;    <span class="comment">//被标记 ，进入环境</span></span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//执行完毕 之后 a、b又被标离开环境，被回收。</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-引用计数"><a href="#1-2-引用计数" class="headerlink" title="1.2 引用计数"></a>1.2 引用计数</h3><p>引用计数的含义是跟踪记录每个值被引用的次数。</p>
<p>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = &#123;&#125; ; <span class="comment">//a的引用次数为0 </span></span><br><span class="line">    <span class="keyword">var</span> b = a ; <span class="comment">//a的引用次数加1，为1 </span></span><br><span class="line">    <span class="keyword">var</span> c =a; <span class="comment">//a的引用次数再加1，为2</span></span><br><span class="line">    <span class="keyword">var</span> b =&#123;&#125;; <span class="comment">//a的引用次数减1，为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 引用计数这种方式在老式浏览器中采用,在循环引用是会出现<strong>内存泄露</strong>问题:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">  a.pro = b;</span><br><span class="line">  b.pro = a;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<ul>
<li>标记清除: fn()执行完毕后，两个对象都已经离开环境,内存回收;</li>
<li>引用计数: fn()执行完毕后,a和b的引用次数都是2,不会被垃圾回收器回收内存;如果fn函数被大量调用，就会造成<strong>内存泄露</strong>。(在IE7与IE8上，内存直线上升)</li>
</ul>
<p>IE中有一部分对象并不是原生js对象。例如，其<strong>内存泄露</strong>DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使<strong>IE的js引擎采用标记清除策略</strong>来实现，但js访问的<strong>COM对象依然是基于引用计数策略</strong>的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">&quot;element&quot;</span>);</span><br><span class="line">    obj.onclick=<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>obj</code>引用了<code>document.getElementById(“element”)</code>，而<code>document.getElementById(“element”)</code>的onclick方法会引用外部环境中德变量，自然也包括obj，是不是很隐蔽?</p>
<p>最简单的方式就是自己手工解除循环引用:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">&quot;element&quot;</span>);</span><br><span class="line">   obj.onclick=<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">   obj=<span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>IE9+并不存在循环引用导致Dom内存泄露问题，可能是微软做了优化，或者Dom的回收方式已经改变</p>
</blockquote>
<h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h2><h3 id="2-1-合理的方案"><a href="#2-1-合理的方案" class="headerlink" title="2.1 合理的方案"></a>2.1 合理的方案</h3><p>当前比较合理的方案是标记清除:</p>
<blockquote>
<ol>
<li>遍历所有可访问的对象;</li>
<li>回收已不可访问的对象</li>
</ol>
</blockquote>
<h3 id="2-2-GC的缺陷"><a href="#2-2-GC的缺陷" class="headerlink" title="2.2 GC的缺陷"></a>2.2 GC的缺陷</h3><p>和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。</p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>你不知道的JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串操作slice、substr、sbustring比较</title>
    <url>/2018/01/13/IT%E6%8A%80%E6%9C%AF/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9Cslice%E3%80%81substr%E3%80%81substring%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>在截取字符串时常常会用到substr()、substring()、slice()截取数组或字符串的方法,几个方法之间有时易混淆.</p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><blockquote>
<p>可接受一个或者两个参数</p>
<ul>
<li>两个参数:slice(start,end),start指截取字符串开始的位置,end指截取字符串结束的位置(不包含)</li>
<li>一个参数:slice(start),指截取从start位置到结束位置(字符串长度为结束位置)</li>
</ul>
</blockquote>
<ul>
<li><p>1.传递参数为正值,end表示结束的位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">3</span>));<span class="comment">//&quot;loworld&quot;  </span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">//&#x27;loWo&#x27;  </span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li><p>2.传递参数为负值<br>slice()将传入的负值与字符串长度相加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;Helloworld&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.slice(-<span class="number">3</span>));<span class="comment">//&#x27;rld&#x27;   一个参数,与字符串长度相加即为slice(7);</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">3</span>,-<span class="number">4</span>));<span class="comment">//&#x27;low&#x27;   两个参数,字符串长度相加即为slice(3,6);</span></span><br></pre></td></tr></table></figure></li>
<li><p>3.第二个参数比第一个参数小,则返回空字符串</p>
</li>
<li><p>4.IE兼容性:在IE8浏览器测试下,没有兼容性问题</p>
</li>
</ul>
<h3 id="slice与substring、substr区别"><a href="#slice与substring、substr区别" class="headerlink" title="slice与substring、substr区别"></a>slice与substring、substr区别</h3><ul>
<li>传递参数为正值:<ol>
<li>substring与slice方法行为类似,但substring会将较小的数作为开始位置,较大的数作为结束位置(substring(3,0) 与substring(0,3)是一样效果);</li>
<li>substr第二个参数表示返回字符的个数,如果没有第二参数,则字符串的长度作为结束位置</li>
</ol>
</li>
<li>传递参数为负值:<ol>
<li>substring()会把所有负值参数转换为0;</li>
<li>substr()方法会将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str =<span class="string">&quot;helloWorld&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.substr(-<span class="number">3</span>,<span class="number">5</span>));<span class="comment">//&quot;rld&quot; 即为：substr(7,5) ，从位置7开始向后截取5个字符</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">3</span>,-<span class="number">2</span>));<span class="comment">//substr(3,0)，即从位置3截取0个字符串，则返回空</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>IE兼容性: slice() 和 substring ()在IE8都正常,substr()方法传递负值的情况下会存在问题，会返回原始的字符串。IE9修复了此问题。<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li>
<li>在传递正值参数情况下，slice() 和 substring () 行为是一致的，substr()方法在第二个参数上会容易混淆</li>
<li>在传递负值参数情况下，slice() 方法是通过字符串长度相加，符合一般思维，substring()第二个参数转换为0会容易出问题，起始位置会容易变更，</li>
<li>substr() 方法负值情况下会出现IE兼容性问题。<br>综上，一般推荐使用slice()方法。</li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>String</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟jQuery的ajax方法封装</title>
    <url>/2018/04/14/IT%E6%8A%80%E6%9C%AF/%E6%A8%A1%E6%8B%9FjQuery%E7%9A%84ajax%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>ajax在我们的前后端交互占据着重要的位置,前段时间在自己的小项目里模仿jQuery的模式封装了ajax请求的方法,但似乎没有达到满意的效果,同步异步实现并不是很满意,而且有一些局限性。感觉还是要单独拿出来记录，深入的去剖析ajax的原生封装更为妥当！</p>
<h3 id="jQuery的常规ajax实现："><a href="#jQuery的常规ajax实现：" class="headerlink" title="jQuery的常规ajax实现："></a>jQuery的常规ajax实现：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">	url:<span class="string">&quot;http://....&quot;</span>,</span><br><span class="line">  method:<span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  data:&#123;&#125;,</span><br><span class="line">  dataType:<span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">  success:<span class="function"><span class="keyword">function</span>(<span class="params">resp,status</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resp)</span><br><span class="line">  &#125;,</span><br><span class="line">  error:<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到jQuery的ajax方法是$.ajax()传了一个对象参数。</p>
<a id="more"></a>

<h3 id="ajax交互的四个基本步骤"><a href="#ajax交互的四个基本步骤" class="headerlink" title="ajax交互的四个基本步骤:"></a>ajax交互的四个基本步骤:</h3><blockquote>
<ol>
<li>创建对象</li>
<li>创建请求xhr.open;</li>
<li>设置onreadystatechange，判断readyState以及status并接受响应</li>
<li>发送请求：xhr.send()</li>
</ol>
</blockquote>
<ul>
<li>创建的对象obj需要包含url、method、data、dataType、success、error等属性</li>
<li>获得xhr对象:</li>
<li>判断请求方法是get还是post</li>
<li>data参数处理</li>
<li>ajax请求状态判断,要考虑重定向的情况</li>
<li>获得响应数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $=&#123;</span><br><span class="line">  <span class="comment">/*get方法传入data,返回一个拼接好的字符串uname=min&amp;age=12*/</span></span><br><span class="line">  params:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">      arr.push(key+<span class="string">&quot;=&quot;</span>+data[key])<span class="comment">//将对象键值对以字符串形式存入数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> str=arr.join(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/*该方法发送http请求*/</span></span><br><span class="line">  ajax:<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url=obj.url;</span><br><span class="line">    <span class="keyword">var</span> type=obj.method || obj.type;<span class="comment">//支持方法属性为method或type;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">async</span>=obj.async == <span class="literal">undefined</span> ? <span class="literal">true</span> : obj.async;</span><br><span class="line">		<span class="keyword">var</span> data = obj.data == <span class="literal">undefined</span> ? &#123;&#125; : obj.data;</span><br><span class="line">    <span class="keyword">var</span> success=obj.success;</span><br><span class="line">    <span class="keyword">var</span> error=obj.error;</span><br><span class="line">    <span class="comment">//创建一个XMLHttpRequest 对象</span></span><br><span class="line">    <span class="keyword">var</span> xhr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">      xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;	<span class="comment">//微软IE浏览器的xhr对象</span></span><br><span class="line">      xhr=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;MicroSoft.XMLHttp&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//判断请求类型是&quot;get&quot;还是&quot;post&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(type.toLowerCase()===<span class="string">&quot;get&quot;</span>)&#123;</span><br><span class="line">      <span class="comment">//get类型的url参数为拼接字符串</span></span><br><span class="line">      url=url+<span class="string">&quot;?&quot;</span>+<span class="built_in">this</span>.params(data);</span><br><span class="line">      data=<span class="literal">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//post类型要给服务器端一个请求头</span></span><br><span class="line">      xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建请求</span></span><br><span class="line">    xhr.open(type,url,<span class="keyword">async</span>);</span><br><span class="line">    <span class="comment">//当xhr的readyState发生改变时，要自动激发的操作</span></span><br><span class="line">    xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//返回的状态可能为200成功,也可能是304重定向</span></span><br><span class="line">       <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span> &amp;&amp; xhr.status==<span class="number">200</span> || xhr.status==<span class="number">304</span>)&#123;</span><br><span class="line">         <span class="keyword">var</span> respData=xhr.responseText;</span><br><span class="line">         success(data);<span class="comment">//</span></span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         error();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//xhr.send()方法要放在后面,这样xhr.onreadystatechange方法提前绑定监听xhr.readyState,同步请求才能拿到数据</span></span><br><span class="line">    xhr.send(data);	<span class="comment">//get类型data为null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上有一点需要<strong>注意</strong>,就是xhr.send()方法一定要放在最后,这样xhr.onreadystatechange才能监听xhr的readyState变化,否则同步发送请求时不能监听xhr的readyState变化</p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器兼容性</title>
    <url>/2018/09/26/IT%E6%8A%80%E6%9C%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1-视频截取第一帧"><a href="#1-视频截取第一帧" class="headerlink" title="1. 视频截取第一帧"></a>1. 视频截取第一帧</h2><ul>
<li>问题: 在加载h5 的视频时,PC端一半都会默认加载首帧显示,而在移动端就会显示空白或者一片黑</li>
</ul>
<blockquote>
<p><strong>解决方案</strong>: 在上传本地视频时,监听视频加载事件,获取第一帧图片,利用canvas绘制出图片并存储,作为移动端视频video的poster</p>
<p>onloadeddata事件:  浏览器加载声频、视频当前帧结束后触发的事件(与下一帧是否下载完成无关)<br>在音频和视频加载过程中,能够触发的事件如下:</p>
<ol>
<li>开始读入媒体数据时触发的事件(<a href="http://www.webkkl.com/api-v/onloadstart.php">onloadstart</a>)</li>
<li>更改声频、视频的时长时(<a href="http://www.webkkl.com/api-v/ondurationchange.php">ondurationchange</a>)</li>
<li>浏览器已加载声频、视频的元数据时触发的事件(<a href="http://www.webkkl.com/api-v/onloadedmetadata.php">onloadedmetadata</a>)</li>
<li>浏览器加载声频、视频当前帧结束后(<a href="http://www.webkkl.com/api-v/onloadeddata.php">onloadeddata</a>)</li>
<li>浏览器正在下载媒体数据时(<a href="http://www.webkkl.com/api-v/onprogress.php">onprogress</a>)</li>
<li>浏览器可以播放媒体数据时(<a href="http://www.webkkl.com/api-v/oncanplay.php">oncanplay</a>)</li>
<li>当浏览器可以在不因缓冲而停顿的情况下播放时(<a href="http://www.webkkl.com/api-v/oncanplaythrough.php">oncanplaythrough</a>)</li>
</ol>
</blockquote>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;视频获取第一帧&lt;/h1&gt;</span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;本地上传&lt;/p&gt;</span><br><span class="line">      &lt;label <span class="keyword">for</span>=<span class="string">&quot;file&quot;</span>&gt;选择视频&lt;/label&gt; </span><br><span class="line">      &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;&quot;</span> id=<span class="string">&quot;file&quot;</span><span class="string">&quot;&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;hr&gt;</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;外链&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;input type=&quot;</span>text<span class="string">&quot; id=&#x27;link&#x27;&gt;&lt;button id=&quot;</span>btn<span class="string">&quot;&gt;提交&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;hr&gt;</span></span><br><span class="line"><span class="string">  &lt;video id=&#x27;video&#x27;  preload=&quot;</span>meta<span class="string">&quot; style=&#x27;display:none&#x27; crossorigin=&quot;</span>anonymous<span class="string">&quot;&gt;&lt;/video&gt;</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;首帧图片显示&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;img src=&quot;</span><span class="string">&quot; alt=&quot;</span><span class="string">&quot; id=&quot;</span>img<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">	&lt;p&gt;外链视频: https://haohome.top/movie.mp4&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">    var video = document.getElementById(&quot;</span>video<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    var file = document.getElementById(&quot;</span>file<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    var btn = document.getElementById(&quot;</span>btn<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    var link = document.getElementById(&quot;</span>link<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    file.addEventListener(&quot;</span>change<span class="string">&quot;,function()&#123;</span></span><br><span class="line"><span class="string">      var file  = this.files[0];</span></span><br><span class="line"><span class="string">      var src = URL.createObjectURL(file)</span></span><br><span class="line"><span class="string">      var newFile = new FileReader(file)</span></span><br><span class="line"><span class="string">      video.src = src</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    btn.onclick=function()&#123;</span></span><br><span class="line"><span class="string">      video.src =link.value</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">     video.addEventListener(&quot;</span>loadeddata<span class="string">&quot;, function () &#123;</span></span><br><span class="line"><span class="string">      var canvas = document.createElement(&quot;</span>canvas<span class="string">&quot;);</span></span><br><span class="line"><span class="string">      canvas.width = this.videoWidth;</span></span><br><span class="line"><span class="string">      canvas.height = this.videoHeight;</span></span><br><span class="line"><span class="string">      setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="string">        canvas.getContext(&#x27;2d&#x27;).drawImage(video, 0, 0, canvas.width, canvas.height);</span></span><br><span class="line"><span class="string">        var imgSrc = &#x27;&#x27;;</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">          imgSrc = canvas.toDataURL(&quot;</span>image/png<span class="string">&quot;);</span></span><br><span class="line"><span class="string">          img.src = imgSrc</span></span><br><span class="line"><span class="string">        &#125; catch (e) &#123;</span></span><br><span class="line"><span class="string">          document.write(&quot;</span>只能截取当前域名视频图片! <span class="string">&quot;, e);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;, 200)</span></span><br><span class="line"><span class="string">    &#125;, false);</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure>

<iframe width="100%" height="300" src="//jsrun.net/PqhKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p><strong>当采用链接视频时,会存在视频的跨域问题,需要在video上添加属性crossOrigin=’Anonymous’ 即可</strong>(IE由于安全性问题,会报SecurityError)</p>
<blockquote>
<p>Tips:</p>
<p>获取本地地址两种方法:</p>
<ol>
<li><p><code>URL.createObjectURL</code>: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src = URL.createObjectURL(file)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>FileReader</code></strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fr=<span class="keyword">new</span> FileReader();</span><br><span class="line">fr.onload=<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> src =<span class="built_in">this</span>.result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前监听video视频获取首帧图片时,采用了延时200ms,是为了给视频加载以一定时间</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存问题</title>
    <url>/2018/03/29/IT%E6%8A%80%E6%9C%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>请求缓存的路线图:</p>
<img src="https://haohome.top/18-3-28/12713380.jpg" width="60%">

<h2 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h2><ol>
<li><p>强缓存<br>用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。</p>
</li>
<li><p>协商缓存<br>用户发送的请求，发送到服务器后，由服务器判定是否从缓存中获取资源。</p>
</li>
</ol>
<blockquote>
<p>共同点: 客户端获得的数据最后都是从客户端缓存中获得</p>
<p>区别: 强缓存不与服务器交互，而协商缓存则需要与服务器交互。</p>
</blockquote>
<a id="more"></a>

<h2 id="四个过程详解"><a href="#四个过程详解" class="headerlink" title="四个过程详解"></a>四个过程详解</h2><h3 id="（a）浏览器判定是否有缓存"><a href="#（a）浏览器判定是否有缓存" class="headerlink" title="（a）浏览器判定是否有缓存"></a>（a）浏览器判定是否有缓存</h3><p>所谓“客户端缓存”就是指用户设备中本地资源。不同浏览器缓存文件的地址也不尽相同。</p>
<p>对于一个html页面，缓存分3部分，一个是页面内容，一个是css样式，一个是JS文件</p>
<p>我们以chrome为例来查看下浏览器缓存文件的地址，<br>1）首先在chrome中输入：chrome://chrome-urls/，看到一堆列表,里面隐藏了许多浏览器的奥秘，有兴趣的可以自己深扒。<br>2）找到 chrome://cache（当然也可以直接输入这个地址）</p>
<h3 id="（b）缓存是否过期"><a href="#（b）缓存是否过期" class="headerlink" title="（b）缓存是否过期"></a>（b）缓存是否过期</h3><img src="https://haohome.top/18-3-29/57859267.jpg" width="80%">

<ul>
<li>expires</li>
</ul>
<p>Http1.0 中的标准，表明过期时间，注意此处的时间都是指的是服务器的时间。</p>
<p><strong>存在的问题：服务器时间与客户端时间的不一致，就会导致缓存跟期待效果出现偏差。</strong></p>
<ul>
<li><p>Cache-Control<br>Http1.1 中的标准，可以看成是 expires 的补充。使用的是相对时间的概念。<br>Cache-Control的属性:</p>
<p>1）max-age: 设置缓存的最大的有效时间，单位为秒（s）。max-age会覆盖掉Expires</p>
<ol start="2">
<li><p> s-maxage: 只用于共享缓存，比如CDN缓存（s -&gt; share）。与max-age 的区别是：max-age用于普通缓存，<br>而s-maxage用于代理缓存。如果存在s-maxage,则会覆盖max-age 和 Expires.</p>
</li>
<li><p> public：响应会被缓存，并且在多用户间共享。默认是public。</p>
</li>
<li><p> private: 响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private。</p>
</li>
</ol>
<p>5）no-cache: 指定不缓存响应，表明资源不进行缓存。但是设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。</p>
<p>6）no-store: 绝对禁止缓存。</p>
<p>7）must-revalidate: 如果页面过期，则去服务器进行获取。</p>
<img src="https://haohome.top/18-3-29/21518884.jpg" width="60%">

<p>所以判断缓存是否过期步骤是：<br>1） 查看是否有cache-control 的max-age / s-maxage , 如果有，则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期<br>2）查看是否有cache-control 的max-age / s-maxage，则用expires 作为过期时间比较</p>
</li>
</ul>
<blockquote>
<p>总结：（b）过程执行完后，如果判定为未过期，则使用客户端缓存。那么就是属于“强缓存”。</p>
</blockquote>
<h3 id="（c）跟服务器协商是否使用缓存"><a href="#（c）跟服务器协商是否使用缓存" class="headerlink" title="（c）跟服务器协商是否使用缓存"></a>（c）跟服务器协商是否使用缓存</h3><img src="https://haohome.top/18-3-29/19908920.jpg" width="80%">

<p>到这一步的时候，浏览器会向服务器发送请求，同时如果上一次的缓存中有Last-modified 和 Etag 字段，<br>浏览器将在request header 中加入If-Modified-Since（对应于Last-modified）， 和If-None-Match（对应于Etag）。</p>
<ul>
<li><p>Last-modified: 表明请求的资源上次的修改时间。</p>
</li>
<li><p>If-Modified-Since：客户端保留的资源上次的修改时间。</p>
</li>
<li><p>Etag：资源的内容标识。（不唯一，通常为文件的md5或者一段hash值，只要保证写入和验证时的方法一致即可）</p>
</li>
<li><p>If-None-Match： 客户端保留的资源内容标识。</p>
<blockquote>
<p>1） 分布式系统尽量关闭Etag，因为每台机器生成的Etag都不一样。<br>2）分布式系统里多台机器间文件的Last-Modified必须一致，以免负载均衡不同导致对比失败。</p>
</blockquote>
</li>
</ul>
<p>通常情况下，如果同时发送 If-None-Match 、If-Modified-Since字段，服务器只要比较etag 的内容即可，当然具体处理方式，看服务器的约定规则。</p>
<h3 id="（d）协商缓存"><a href="#（d）协商缓存" class="headerlink" title="（d）协商缓存"></a>（d）协商缓存</h3><p>在这个阶段，服务器一般会将Cache-control、expires 、last-modified、date、etag 等字段在response header 中返回，便于下次缓存。当然具体的场景，也是看服务器的约定规则设定。</p>
<h2 id="缓存的不同来源"><a href="#缓存的不同来源" class="headerlink" title="缓存的不同来源"></a>缓存的不同来源</h2><h3 id="from-disk-cache"><a href="#from-disk-cache" class="headerlink" title="from disk cache"></a>from disk cache</h3><p>从磁盘中获取缓存资源，等待下次访问时不需要重新下载资源，而直接从磁盘中获取。它的直接操作对象为CurlCacheManager。</p>
<h3 id="from-memory-cache"><a href="#from-memory-cache" class="headerlink" title="from memory cache"></a>from memory cache</h3><p>从内存中获取资源，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。<br>目前Webkit资源分成两类，一类是主资源，比如HTML页面，或者下载项，一类是派生资源，比如HTML页面中内嵌的图片或者脚本链接，分别对应代码中两个类：　　　　MainResourceLoader和SubresourceLoader。虽然Webkit支持memoryCache，但是也只是针对派生资源，它对应的类为CachedResource，用于保存原始数据（比如CSS，JS等），以及解码过的图片数据。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>当退出进程时，内存中的数据会被清空，而磁盘的数据不会，所以，当下次再进入该进程时，该进程仍可以从diskCache中获得数据，而memoryCache则不行。</p>
<h3 id="相似"><a href="#相似" class="headerlink" title="相似"></a>相似</h3><p>diskCache与memoryCache相似之处就是也只能存储一些派生类资源文件。它的存储形式为一个index.dat文件，记录存储数据的url，然后再分别存储该url的response信息和content内容。Response信息最大作用就是用于判断服务器上该url的content内容是否被修改。</p>
<h3 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h3><img src="https://haohome.top/18-3-29/99992671.jpg" width="80%">

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><h4 id="1、页面内容"><a href="#1、页面内容" class="headerlink" title="1、页面内容"></a>1、页面内容</h4><meta http-equiv="Expires" content="0">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Cache-control" content="no-cache">
<meta http-equiv="Cache" content="no-cache">

<h4 id="2、CSS和JS文件"><a href="#2、CSS和JS文件" class="headerlink" title="2、CSS和JS文件"></a>2、CSS和JS文件</h4><link rel="stylesheet" href="../css/register.css"/>
<script src="../scripts/register.js"></script>
改成
<link rel="stylesheet" href="../css/register.css?v=20161020"/>
<script src="../scripts/register.js?v=20161020"></script>
就是只要在每次修改后改一下版本号即可

<p>这样每次修改后都要改，有没有自动加版本号的东西，估计有，如果是JSP和php可以通过脚本<br>自动生成，如果是纯html也可以通过document.write，或者用动态加载JS的框架啥的。</p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>点击事件重复请求</title>
    <url>/2018/05/29/IT%E6%8A%80%E6%9C%AF/%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>当我们针对某个按钮绑定点击事件后，就可以随时通过点击鼠标来触发按钮的点击事件，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">$(<span class="string">&#x27;ele&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	num++;</span><br><span class="line">    <span class="comment">//执行的业务逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样num值会不断增加，依赖于num值的业务逻辑就会出错；<br>一般出现的场景有：</p>
<blockquote>
<ol>
<li>ajax请求;</li>
<li>问卷答题</li>
</ol>
</blockquote>
<p>接下来我们根据这些场景来分析下;</p>
<a id="more"></a>

<h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><h3 id="1-ajax提交"><a href="#1-ajax提交" class="headerlink" title="1. ajax提交"></a>1. ajax提交</h3><iframe width="100%" height="200px" src="//jsrun.net/ejZKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>当用户短时间内重复点击登录按钮时,会触发多次的表单提交;<br>解决方案: 当点击提交按钮后,给按钮添加disabled属性,事件完成后再<code>removeAttr(&#39;disabled&#39;)</code></p>
<iframe width="100%" height="200px" src="//jsrun.net/tjZKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h3 id="2-问卷答题"><a href="#2-问卷答题" class="headerlink" title="2. 问卷答题"></a>2. 问卷答题</h3><iframe width="100%" height="200px" src="//jsrun.net/RjZKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>当选择一个答案时,重复点击,机会造成num重复增加,可能会造成中间某些选题未答直接跳到后面的答题，而添加一个name数组判断是否重复就可以避免该问题;</p>
<iframe width="100%" height="200px" src="//jsrun.net/rjZKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决重复点击问题可以归结为标记作用位点，有两种方法:</p>
<ol>
<li>点击触发请求后，作用点设为disabled属性，请求（或者包括请求后具体的业务流程处理）后，移除disabled属性；</li>
<li>记录作用点，判断作用点是否重复，重复则直接return</li>
</ol>
<p>其实ajax还有一个更好的方法来避免重复提交,我们知道js是单线程执行事件的,所以可以根据此原理定义事件序列，重新封装ajax方法来避免。</p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现一个前端路由</title>
    <url>/2018/11/18/IT%E6%8A%80%E6%9C%AF/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<blockquote>
<p>单页面应用利用了JavaScript动态变换网页内容,避免了页面重载;路由则提供了浏览器地址变化,网页内容也跟随变化,两者结合起来则为我们提供了体验良好的单页面web应用</p>
</blockquote>
<h2 id="前端路由实现方式"><a href="#前端路由实现方式" class="headerlink" title="前端路由实现方式"></a>前端路由实现方式</h2><p>路由需要实现三个功能:</p>
<p>​    ①浏览器地址变化,切换页面;</p>
<p>​    ②点击浏览器【后退】、【前进】按钮，网页内容跟随变化；</p>
<p>​    ③刷新浏览器，网页加载当前路由对应内容</p>
<p>在单页面web网页中,单纯的浏览器地址改变,网页不会重载,如单纯的hash网址改变网页不会变化,因此我们的路由主要是通过监听事件,并利用js实现动态改变网页内容,有两种实现方式:</p>
<p><code>hash</code>路由: 监听浏览器地址hash值变化,执行相应的js切换网页<br><code>history</code>路由: 利用history API实现url地址改变,网页内容改变</p>
<a id="more"></a>

<h2 id="hash路由"><a href="#hash路由" class="headerlink" title="hash路由"></a>hash路由</h2><p>首先定义一个<code>Router</code>类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 路由模式</span></span><br><span class="line">    <span class="built_in">this</span>.mode = obj.mode</span><br><span class="line">    <span class="comment">// 配置路由</span></span><br><span class="line">    <span class="built_in">this</span>.routes = &#123;</span><br><span class="line">      <span class="string">&#x27;/index&#x27;</span>							: <span class="string">&#x27;views/index/index&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;/index/detail&#x27;</span>				: <span class="string">&#x27;views/index/detail/detail&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;/index/detail/more&#x27;</span>	: <span class="string">&#x27;views/index/detail/more/more&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;/subscribe&#x27;</span>					: <span class="string">&#x27;views/subscribe/subscribe&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;/proxy&#x27;</span>							: <span class="string">&#x27;views/proxy/proxy&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;/state&#x27;</span>							: <span class="string">&#x27;views/state/stateDemo&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;/state/sub&#x27;</span>					: <span class="string">&#x27;views/state/components/subState&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;/dom&#x27;</span>								: <span class="string">&#x27;views/visualDom/visualDom&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;/error&#x27;</span>							: <span class="string">&#x27;views/error/error&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.init()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路由初始化<code>init()</code>时监听<code>load</code>,<code>hashchange</code>两个事件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="built_in">this</span>.hashRefresh.bind(<span class="built_in">this</span>), <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="built_in">this</span>.hashRefresh.bind(<span class="built_in">this</span>), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>浏览器地址hash值变化直接通过a标签链接实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span> <span class="attr">class</span>=<span class="string">&quot;nav-tab&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&#x27;tab&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&#x27;nav-item&#x27;</span> <span class="attr">href</span>=<span class="string">&quot;#/index&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&#x27;nav-item&#x27;</span> <span class="attr">href</span>=<span class="string">&quot;#/subscribe&quot;</span>&gt;</span>观察者<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&#x27;nav-item&#x27;</span> <span class="attr">href</span>=<span class="string">&quot;#/proxy&quot;</span>&gt;</span>代理<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&#x27;nav-item&#x27;</span> <span class="attr">href</span>=<span class="string">&quot;#/state&quot;</span>&gt;</span>状态管理<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&#x27;nav-item&#x27;</span> <span class="attr">href</span>=<span class="string">&quot;#/dom&quot;</span>&gt;</span>虚拟DOM<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">class</span>=<span class="string">&#x27;container&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">class</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>hash值变化后,回调方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash路由刷新执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">hashRefresh</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前路径,去掉查询字符串,默认&#x27;/index&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> currentURL = location.hash.slice(<span class="number">1</span>).split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">0</span>] || <span class="string">&#x27;/index&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="built_in">this</span>.routes[<span class="built_in">this</span>.currentURL]</span><br><span class="line">  <span class="built_in">this</span>.controller(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 组件控制器</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>name </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="title">controller</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 获得相应组件</span></span><br><span class="line">  <span class="keyword">var</span> Component = <span class="built_in">require</span>(<span class="string">&#x27;../&#x27;</span> + name).default;</span><br><span class="line">  <span class="comment">// 判断是否已经配置挂载元素,默认为$(&#x27;#main&#x27;)</span></span><br><span class="line">  <span class="keyword">var</span> controller = <span class="keyword">new</span> Component($(<span class="string">&#x27;#main&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到存在多级页面嵌套路由的存在,需要对嵌套路由进行处理:</p>
<ul>
<li>直接子页面路由时,按父路由到子路由的顺序加载页面</li>
<li>父页面已经加载,再加载子页面时,父页面保留,只加载子页面</li>
</ul>
<p>改造后的路由刷新方法为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">hashRefresh</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前路径,去掉查询字符串,默认&#x27;/index&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> currentURL = location.hash.slice(<span class="number">1</span>).split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">0</span>] || <span class="string">&#x27;/index&#x27;</span>;  </span><br><span class="line">  <span class="comment">// 多级链接拆分为数组,遍历依次加载</span></span><br><span class="line">  <span class="built_in">this</span>.currentURLlist = currentURL.slice(<span class="number">1</span>).split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">  <span class="built_in">this</span>.url = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="built_in">this</span>.currentURLlist.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 导航菜单激活显示</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.navActive(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.url += <span class="string">&quot;/&quot;</span> + item</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="built_in">this</span>.routes[<span class="built_in">this</span>.url]</span><br><span class="line">    <span class="comment">// 404页面处理</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.name) &#123;</span><br><span class="line">      location.href = <span class="string">&#x27;#/error&#x27;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于嵌套路由的处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.oldURL &amp;&amp; <span class="built_in">this</span>.oldURL[<span class="number">0</span>]==<span class="built_in">this</span>.currentURLlist[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.handleSubRouter(item,index)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.controller(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 记录链接数组,后续处理子级组件</span></span><br><span class="line">  <span class="built_in">this</span>.oldURL = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.currentURLlist))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 处理嵌套路由</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>item 链接list中当前项</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>index 链接list中当前索引</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="title">handleSubRouter</span>(<span class="params">item,index</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 新路由是旧路由的子级</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.oldURL.length &lt; <span class="built_in">this</span>.currentURLlist.length) &#123;</span><br><span class="line">    <span class="comment">// 相同路由部分不重新加载</span></span><br><span class="line">    <span class="keyword">if</span> (item !== <span class="built_in">this</span>.oldURL[index]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.controller(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新路由是旧路由的父级</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.oldURL.length &gt; <span class="built_in">this</span>.currentURLlist.length) &#123;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.oldURL.length, <span class="built_in">this</span>.currentURLlist.length)</span><br><span class="line">    <span class="comment">// 只重新加载最后一个路由</span></span><br><span class="line">    <span class="keyword">if</span> (index == len - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.controller(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;				</span><br></pre></td></tr></table></figure>

<p>这样,一个hash路由组件就实现了</p>
<p>使用时,只需new一个Router实例即可:<code>new Router(&#123;mode:&#39;hash&#39;&#125;)</code></p>
<h2 id="history-路由"><a href="#history-路由" class="headerlink" title="history 路由"></a>history 路由</h2><p><code>window.history</code>属性指向 History 对象,是浏览器的一个属性,表示当前窗口的浏览历史,History 对象保存了当前窗口访问过的所有页面地址。更多了解History对象,可参考阮一峰老师的介绍:<a href="https://wangdoc.com/javascript/bom/history.html"> History 对象</a></p>
<blockquote>
<p>webpack开发环境下,需要在devServer对象添加以下配置:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">historyApiFallback: &#123;</span><br><span class="line">  rewrites: [</span><br><span class="line">    &#123; <span class="attr">from</span>: <span class="regexp">/.*/</span>, to: path.posix.join(config.dev.assetsPublicPath, <span class="string">&#x27;index.html&#x27;</span>) &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>history路由主要是通过<code>history.pushState()</code>方法向浏览记录中添加一条历史记录,并同时触发js回调加载页面</p>
<p>当【前进】、【后退】时，会触发<code>history.popstate</code> 事件,加载<code>history.state</code>中存放的路径</p>
<p>history路由实现与hash路由的步骤类似,由于需要配置路由模式切换,页面中所有的a链接都采用了hash类型链接,history路由初始化时,需要拦截a标签的默认跳转:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * history模式劫持 a链接</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="title">bindLink</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   $(<span class="string">&#x27;#nav&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;a.nav-item&#x27;</span>, <span class="built_in">this</span>.handleLink.bind(<span class="built_in">this</span>))</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * history 处理a链接</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param  </span>e 当前对象Event</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="title">handleLink</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">   e.preventDefault();</span><br><span class="line">   <span class="comment">// 获取元素路径属性</span></span><br><span class="line">   <span class="keyword">let</span> href = $(e.target).attr(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">   <span class="comment">// 对非路由链接直接跳转</span></span><br><span class="line">   <span class="keyword">if</span> (href.slice(<span class="number">0</span>, <span class="number">1</span>) !== <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">     <span class="built_in">window</span>.location.href = href</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> path = href.slice(<span class="number">1</span>)</span><br><span class="line">     history.pushState(&#123;</span><br><span class="line">       path: path</span><br><span class="line">     &#125;, <span class="literal">null</span>, path)</span><br><span class="line">     <span class="comment">// 加载相应页面</span></span><br><span class="line">     <span class="built_in">this</span>.loadView(path.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>history路由初始化需要绑定<code>load</code>、<code>popstate</code>事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.bindLink()</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="built_in">this</span>.loadView.bind(<span class="built_in">this</span>, location.pathname));</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;popstate&#x27;</span>, <span class="built_in">this</span>.historyRefresh.bind(<span class="built_in">this</span>));</span><br></pre></td></tr></table></figure>

<p>浏览是【前进】或【后退】时,触发<code>popstate</code>事件,执行回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * history模式刷新页面</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param  </span>e  当前对象Event</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="title">historyRefresh</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> state = e.state || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> path = state.path.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">0</span>] || <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (path) &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadView(path)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>history路由模式首次加载页面时,可以默认一个页面,这时可以用<code>history.replaceState</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.mode === <span class="string">&#x27;history&#x27;</span> &amp;&amp; currentURL === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">  history.replaceState(&#123;<span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>&#125;, <span class="literal">null</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">  currentURL = <span class="string">&#x27;/index&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于404页面的处理,也类似</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">history.replaceState(&#123;<span class="attr">path</span>: <span class="string">&#x27;/error&#x27;</span>&#125;, <span class="literal">null</span>, <span class="string">&#x27;/error&#x27;</span>)</span><br><span class="line"><span class="built_in">this</span>.loadView(<span class="string">&#x27;/error&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://www.haohome.top/webpack-spa/">点击预览</a></p>
<p>更多源码请访问<a href="https://github.com/yifoo/webpack-demo">Github</a></p>
<p><a href="https://juejin.im/post/5bf16b506fb9a049b22178b4"><img src="https://badge.juejin.im/entry/5bf16b506fb9a049b22178b4/likes.svg?style=flat-square"></a></p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>router</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域请求的jsonp处理</title>
    <url>/2018/04/07/IT%E6%8A%80%E6%9C%AF/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84jsonp%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="跨域简介"><a href="#跨域简介" class="headerlink" title="跨域简介"></a>跨域简介</h3><p>跨域是指不用域之间相互请求资源,只要协议，主机名，端口号，二级域名等不同都算跨域。</p>
<p>浏览器认为多数由js程序发起的跨域请求都是不合法的，主要为xhr，但不由js发起的跨域是允许的，包括：img，link，script，iframe；</p>
<a id="more"></a>

<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><ul>
<li>JSON with Padding 填充式 json</li>
</ul>
<p>正常的ajax请求是不允许跨域请求的，只能用允许跨域请求的元素script代替</p>
<ul>
<li><p>处理步骤</p>
<ol>
<li>客户端定义一个专门处理相应的有名函数doResponse(<strong>处理函数中仅接受并处理服务端json数据,不用xhr对象，更不用判断状态</strong>)</li>
<li> 服务器端php: 接受请求数据并处理,返回一条js语句echo ‘doResponse($json)’;</li>
<li>动态创建一个script元素,设置src指向服务器端的php地址</li>
</ol>
<p>客户端js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResponse</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(resp);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> resp)&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">$(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*动态追加script元素*/</span></span><br><span class="line">  $(<span class="string">&quot;body&quot;</span>).append(<span class="string">`&lt;script src=&quot;http://127.0.0.1/jsonp.php?callback=doResponse&quot;&gt;&lt;\/script&gt;`</span>);</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>

<p>也可以采用ajax获得返回数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.getJSON(<span class="string">&quot;https://www.haohome.top/demo/jsonp.php?callback=doResponse&quot;</span>,<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  type:<span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  url:<span class="string">&quot;https://www.haohome.top/demo/jsonp.php?callback=doResponse&quot;</span>,</span><br><span class="line">  success:<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;返回数据&quot;</span>,data);</span><br><span class="line">  &#125;,</span><br><span class="line">  dataType:<span class="string">&quot;jsonp&quot;</span></span><br><span class="line">&#125;)			</span><br></pre></td></tr></table></figure>

<p>服务器端php:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">header(<span class="string">&quot;Content-type:application/javascript;charset:utf-8&quot;</span>);</span><br><span class="line"><span class="variable">$getData</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;callback&#x27;</span>];</span><br><span class="line"><span class="variable">$hello</span>=json_encode([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$getData</span>.<span class="string">&quot;(&#x27;<span class="subst">$hello</span>&#x27;)&quot;</span>;</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>http</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域资源共享CORS</title>
    <url>/2018/01/14/IT%E6%8A%80%E6%9C%AF/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%20CORS/</url>
    <content><![CDATA[<p>CORS是一个W3C标准,全称是”跨域资源共享”(Cross-origin resource sharing)。它允许浏览器向夸源服务器发出XMLHttpRequest请求，克服Ajax只能同源使用的限制。</p>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。<br>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<a id="more"></a>
<h3 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h3><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<ul>
<li><p>2.1简单请求<br>简单请求满足一下两大条件<br>(1)请求方法时一下三种方法之一</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>(2)HTTP的头信息不超出一下几种字段:</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
</blockquote>
<ul>
<li>2.1.1 基本流程<br>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。<blockquote>
<p>下面的例子,浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: <span class="string">&#x27;http://api.bob.com&#x27;</span></span><br><span class="line">Host: <span class="string">&#x27;api.alice.com&#x27;</span></span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br><span class="line"><span class="comment">//上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。</p>
<blockquote>
<p>这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200</p>
</blockquote>
</li>
<li><p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//浏览器响应头res</span></span><br><span class="line">Access-Control-Allow-Origin: <span class="string">&#x27;http://api.bob.com&#x27;</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br><span class="line"><span class="comment">//上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>(1)Access-Control-Allow-Origin(必须)<br>该字段是必须的。受任意域名的请求。</p>
</li>
<li><p>(2)Access-Control-Allow-Credentials(可选)<br>它的值是一个布尔值，表示是否允许发送<strong>Cookie</strong>。<br>默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
</li>
<li><p>(3)Access-Control-Expose-Headers(可选)<br>CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p>
</li>
<li><p>2.1.2 withCredentials 属性<br>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>同时开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>  这样就能向服务器发送Cookie,服务器才能获得SessionId;<br>  否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理,这时服务器会新建一个新的Cookie的Id号。</p>
<blockquote>
<p>但是，有时即使省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p>
<ul>
<li><p>2.2非简单请求</p>
</li>
<li><p>2.2.1预检请求<br>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。<br>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://api.alice.com/cors&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">xhr.send();</span><br><span class="line"><span class="comment">//上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。</span></span><br></pre></td></tr></table></figure>
<p> 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。<br> 下面是这个”预检”请求的HTTP头信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">OPTIONS /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: <span class="string">&#x27;http://api.bob.com&#x27;</span></span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>
<p> “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。<br> 除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p>
<ul>
<li>(1)Access-Control-Request-Method<br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li>
<li>(2)Access-Control-Request-Headers<br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</li>
</ul>
<p> 转载自<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">阮一峰的网络日志</a></p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Http</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域问题解决方案汇总</title>
    <url>/2018/10/22/IT%E6%8A%80%E6%9C%AF/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。但是有时候跨域请求资源是合理的需求，本文尝试从多篇文章中汇总至今存在的所有跨域请求解决方案。</p>
<h2 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h2><p>首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。而有关跨域请求受到限制的原因可以参考如下 MDN 文档片段：</p>
<blockquote>
<p>跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。</p>
</blockquote>
<a id="more"></a>

<h2 id="解决方法汇总"><a href="#解决方法汇总" class="headerlink" title="解决方法汇总"></a>解决方法汇总</h2><p>以下我们由简及深介绍各种存在的跨域请求解决方案，包括 <code>document.domain, location.hash, window.name, window.postMessage, JSONP, WebSocket, CORS</code>。</p>
<h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p><code>document.domain</code> 的作用是用来获取/设置当前文档的原始域部分，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于文档 www.example.xxx/good.html</span></span><br><span class="line"><span class="built_in">document</span>.domain=<span class="string">&quot;www.example.xxx&quot;</span></span><br><span class="line"><span class="comment">// 对于URI http://developer.mozilla.org/en/docs/DOM </span></span><br><span class="line"><span class="built_in">document</span>.domain=<span class="string">&quot;developer.mozilla.org&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果当前文档的域无法识别，那么 domain 属性会返回 null。</p>
<p>在根域范围内，Mozilla允许你把domain属性的值设置为它的上一级域。例如，在 developer.mozilla.org 域内，可以把domain设置为 “mozilla.org” 但不能设置为 “mozilla.com” 或者”org”。</p>
</blockquote>
<p>因此，若两个源所用协议、端口一致，主域相同而二级域名不同的话，可以借鉴该方法解决跨域请求。</p>
<p>比如若我们在 <a href="http://a.github.io/">http://a.github.io</a> 页面执行以下语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">&quot;github.io&quot;</span></span><br></pre></td></tr></table></figure>

<p>那么之后页面对 <code>github.io</code> 发起请求时页面则会成功通过对 <code>github.io</code> 的同源检测。比较直接的一个操作是，当我们在 <code>a.github.io</code> 页面中利用 iframe 去加载 <code>github.io</code> 时，通过如上的赋值后，我们可以在 <code>a.github.io</code> 页面中去操作 iframe 里的内容。</p>
<p>我们同时考虑另一种情况：存在两个子域名 <code>a.github.io</code> 以及 <code>b.github.io</code>， 其中前者域名下网页 a.html 通过 iframe 引入了后者域名下的 b.html，此时在 a.html 中是无法直接操作 b.html 的内容的。</p>
<p>同样利用 <code>document.domain</code>，我们在两个页面中均加入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain=<span class="string">&#x27;github.io&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样在以上的 a.html 中就可以操作通过 iframe 引入的 b.html 了。</p>
<p><strong>document.domain</strong> 的优点在于解决了主语相同的跨域请求，但是其缺点也是很明显的：比如一个站点受到攻击后，另一个站点会因此引起安全漏洞；若一个页面中引入多个 iframe，想要操作所有的 iframe 则需要设置相同的 domain。</p>
<h3 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h3><p><code>location.hash</code> 是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分）。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于页面 http://example.com:1234/test.htm#part2</span></span><br><span class="line">location.hash = <span class="string">&quot;#part2&quot;</span></span><br></pre></td></tr></table></figure>

<p>同时，由于我们知道改变 hash 并不会导致页面刷新，所以可以利用 hash 在不同源间传递数据。</p>
<p>假设 <code>github.io</code> 域名下 a.html 和 <code>shaonian.eu</code> 域名下 b.html 存在跨域请求，那么利用 location.hash 的一个解决方案如下：</p>
<ul>
<li><p>a.html 页面中创建一个隐藏的 iframe， src 指向 b.html，其中 src 中可以通过 hash 传入参数给 b.html</p>
</li>
<li><p>b.html 页面在处理完传入的 hash 后通过修改 a.html 的 hash 值达到将数据传送给 a.html 的目的</p>
</li>
<li><p>a.html 页面添加一个定时器，每隔一定时间判断自身的 location.hash 是否变化，以此响应处理</p>
</li>
</ul>
<p>以上步骤中需要注意第二点：如何在 iframe 页面中修改 父亲页面的 hash 值。由于在 IE 和 Chrome 下，两个不同域的页面是不允许 <code>parent.location.hash</code> 这样赋值的，所以对于这种情况，我们需要在父亲页面域名下添加另一个页面来实现跨域请求，具体如下：</p>
<ul>
<li><p>假设 a.html 中 iframe 引入了 b.html, 数据需要在这两个页面之间传递，且 c.html 是一个与 a.html 同源的页面</p>
</li>
<li><p>a.html 通过 iframe 将数据通过 hash 传给 b.html</p>
</li>
<li><p>b.html 通过 iframe 将数据通过 hash 传给 c.html</p>
</li>
<li><p>c.html 通过 <code>parent.parent.location.hash</code> 设置 a.html 的 hash 达到传递数据的目的</p>
</li>
</ul>
<p><strong>location.bash</strong> 方法的优点在于可以解决域名完全不同的跨域请求，并且可以实现双向通讯；而缺点则包括以下几点：</p>
<ul>
<li><p>利用这种方法传递的数据量受到 url 大小的限制，传递数据类型有限</p>
</li>
<li><p>由于数据直接暴露在 url 中则存在安全问题</p>
</li>
<li><p>若浏览器不支持 <code>onhashchange</code> 事件，则需要通过轮训来获知 url 的变化</p>
</li>
<li><p>有些浏览器会在 hash 变化时产生历史记录，因此可能影响用户体验</p>
</li>
</ul>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>该属性用于获取/设置窗口的名称。其特征在于：一个窗口的生命周期内，窗口载入的所有页面共享该值，且都具有对该属性的读写权限。这意味着如果不修改该值，那么在不同页面加载之后该值也不会变，且其支持长达 2MB 的存储量。</p>
<p>利用该特性我们可以将跨域请求用如下步骤解决：</p>
<ul>
<li><p>在 a.github.io/a.html 中创建 iframe 指向 b.github.io/b.html (页面会将自身的 window.name 附在 iframe 上)</p>
</li>
<li><p>给 a.github.io/a.html 添加监听 iframe 的 onload 事件，在该事件中将 iframe 的 src 设置为本地域的代理文件（代理文件和a.html处于同一域下，可以相互通信），同时可以传出 iframe 的 name 值</p>
</li>
<li><p>获取数据后销毁 iframe，释放内存，同时也保证了安全</p>
</li>
</ul>
<p><strong>window.name</strong> 的优势在于巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h3><p>HTML5 为了解决这个问题，引入了一个全新的 API：跨文档通信 API（Cross-document messaging）。这个 API 为 window 对象新增了一个 window.postMessage 方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p>API 的详细使用方法请见 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">MDN</a>。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP, 全称 JSON with Padding，是使用 AJAX 实现的请求不同源的跨域。其基本原理：网页通过添加一个 <code>&lt;script&gt;</code> 元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>
<p>以下为一个例子，由于 test.js 返回的内容直接作为代码运行，所以只要 a.html 中定义了 <code>callback</code> 函数, 它就会立即被调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前页面 a.com/a.html</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(data.message);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;http://b.com/test.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="comment">// 调用callback函数，并以json数据形式作为阐述传递，完成回调</span></span><br><span class="line">callback(&#123;<span class="attr">message</span>:<span class="string">&quot;success&quot;</span>&#125;); </span><br></pre></td></tr></table></figure>

<p>为了保证 script 的灵活，我们可以通过 JavaScript 动态创建 script 标签，并通过 HTTP 参数向服务器传入回调函数名，案例如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// 添加&lt;script&gt;标签的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.setAttribute(<span class="string">&quot;type&quot;</span>,<span class="string">&quot;text/javascript&quot;</span>);</span><br><span class="line">        script.src = src;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 搜索apple，将自定义的回调函数名result传入callback参数中</span></span><br><span class="line">        addScriptTag(<span class="string">&quot;http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q=apple&amp;callback=result&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义的回调函数result</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 我们就简单的获取apple搜索结果的第一条记录中url数据</span></span><br><span class="line">        alert(data.responseData.results[<span class="number">0</span>].unescapedUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>jQuery 有相应的 JSONP 的实现方法，见 <a href="http://api.jquery.com/jquery.getjson/">API</a>。</p>
<p><strong>JSONP</strong>的优点在于简单适用，老式浏览器全部支持，服务器改造小。不需要XMLHttpRequest或ActiveX的支持；但缺点是只支持 GET 请求。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><blockquote>
<p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>
</blockquote>
<p>跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。其需要服务端和客户端同时支持。</p>
<blockquote>
<p>跨域资源共享标准（ cross-origin sharing standard ）允许在下列场景中使用跨域 HTTP 请求：</p>
<p>由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求</p>
<p>Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用</p>
<p>WebGL 贴图</p>
<p>使用 drawImage 将 Images/video 画面绘制到 canvas</p>
<p>样式表（使用 CSSOM）</p>
<p>Scripts (未处理的异常)</p>
</blockquote>
<p>CORS 存在以下三种主要场景，分别是<strong>简单请求，预检请求和附带身份凭证的请求</strong>。</p>
<ul>
<li><strong>简单请求</strong>：若只使用 GET, HEAD 或者 POST 请求，且除 CORS 安全的首部字段集合外，无人为设置该集合之外的其他首部字段，同时 Content-Type 值属于下列之一，那么该请求则可以被视为简单请求：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">application&#x2F;x-www-form-urlencoded</span><br><span class="line">multipart&#x2F;form-data</span><br><span class="line">text&#x2F;plain</span><br></pre></td></tr></table></figure>

<p>此情况下，若服务端返回的 <code>Access-Control-Allow-Origin: *</code> ，则表明该资源可以被任意外域访问。若要指定仅允许来自某些域的访问，需要将 <code>*</code> 设定为该域，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;foo.example</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>预检请求</strong>：与前述简单请求不同，该要求必须首先使用 OPTIONS   方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。当请求满足以下三个条件任意之一时，<br>即应首先发送预检请求：</li>
</ul>
<ol>
<li>使用了 PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH 中任一的 HTTP 方法</li>
<li>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段</li>
<li>Content-Type 的值不属于下列之一</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">application&#x2F;x-www-form-urlencoded</span><br><span class="line">multipart&#x2F;form-data</span><br><span class="line">text&#x2F;plain</span><br></pre></td></tr></table></figure>

<p>预检请求完成之后（通过 OPTIONS 方法实现），才发送实际请求。一个示范 HTTP 请求如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://bar.other/resources/post-here/&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> body = <span class="string">&#x27;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callOtherDomain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(invocation)</span><br><span class="line">    &#123;</span><br><span class="line">      invocation.open(<span class="string">&#x27;POST&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">      invocation.setRequestHeader(<span class="string">&#x27;X-PINGOTHER&#x27;</span>, <span class="string">&#x27;pingpong&#x27;</span>);</span><br><span class="line">      invocation.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/xml&#x27;</span>);</span><br><span class="line">      invocation.onreadystatechange = handler;</span><br><span class="line">      invocation.send(body); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>附带身份凭证的请求</strong>：这种方式的特点在于能够在跨域请求时向服务器发送凭证请求，例如 Cookies (withCredentials 标志设置为 true)。</li>
</ul>
<p>一般而言，对于跨域 XMLHttpRequest 或 Fetch 请求，浏览器不会发送身份凭证信息。如果要发送凭证信息，需要设置 XMLHttpRequest 的某个特殊标志位。但是需要注意的是，如果服务器端的响应中未携带 <code>Access-Control-Allow-Credentials: true</code>，浏览器将不会把响应内容返回给请求的发送者。</p>
<blockquote>
<p>附带身份凭证的请求与通配符</p>
<p>对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为“*”。</p>
<p>这是因为请求的首部中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为“*”，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 <a href="http://foo.example,则请求将成功执行./">http://foo.example，则请求将成功执行。</a></p>
<p>另外，响应首部中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。</p>
</blockquote>
<p>MDN 引例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://bar.other/resources/credentialed-content/&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callOtherDomain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(invocation) &#123;</span><br><span class="line">    invocation.open(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    invocation.withCredentials = <span class="literal">true</span>;</span><br><span class="line">    invocation.onreadystatechange = handler;</span><br><span class="line">    invocation.send(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实由上我们知道，<strong>CORS</strong> 的优点也非常明显：CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案。</p>
<p>以上就是所有的跨域请求解决方案，根据实际生产环境，总有一款适合你。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://github.com/wengjq/Blog/issues/2">https://github.com/wengjq/Blog/issues/2</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/zichi/p/4620656.html">http://www.cnblogs.com/zichi/p/4620656.html</a></p>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2></li>
<li><p><a href="https://sites.google.com/site/amitsciscozone/home/security/ssl-connection-setup">https://sites.google.com/site/amitsciscozone/home/security/ssl-connection-setup</a></p>
</li>
<li><p><a href="http://robertheaton.com/2014/03/27/how-does-https-actually-work/">http://robertheaton.com/2014/03/27/how-does-https-actually-work/</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/lixiansen/p/5618541.html">http://www.cnblogs.com/lixiansen/p/5618541.html</a></p>
</li>
<li><p><a href="http://harttle.com/2016/01/22/doctype.html">http://harttle.com/2016/01/22/doctype.html</a></p>
</li>
<li><p><a href="http://jerryzou.com/posts/cookie-and-web-storage/">http://jerryzou.com/posts/cookie-and-web-storage/</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/20653055/answer/17786008">https://www.zhihu.com/question/20653055/answer/17786008</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes</a></p>
</li>
<li><p><a href="http://blog.csdn.net/NJUPT_T/article/details/50700209">http://blog.csdn.net/NJUPT_T/article/details/50700209</a></p>
</li>
<li><p><a href="http://web.jobbole.com/84826/">http://web.jobbole.com/84826/</a></p>
</li>
<li><p><a href="http://web.jobbole.com/85340/">http://web.jobbole.com/85340/</a></p>
</li>
</ul>
<p>文章参考了以上资源，同时参照 <a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers">https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers</a> 的部分问题列表重新归纳了详细问题答案。</p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>通俗易懂的原型与原型链</title>
    <url>/2018/03/11/IT%E6%8A%80%E6%9C%AF/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="普通对象与函数对象"><a href="#普通对象与函数对象" class="headerlink" title="普通对象与函数对象"></a>普通对象与函数对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> o2 =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> f1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;str&#x27;</span>,<span class="string">&#x27;console.log(str)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">//function </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">//function  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1); <span class="comment">//function </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f2); <span class="comment">//function </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f3); <span class="comment">//function   </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o1); <span class="comment">//object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o2); <span class="comment">//object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o3); <span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中: o1、o2、o3都是普通对象object，而f1、f2、f3是函数对象function</p>
<blockquote>
<p><strong>凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1、f2归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的</strong>。</p>
</blockquote>
<a id="more"></a>    

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line"> <span class="built_in">this</span>.age = age;</span><br><span class="line"> <span class="built_in">this</span>.job = job;</span><br><span class="line"> <span class="built_in">this</span>.intr = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.name+<span class="string">&quot;年龄是&quot;</span>+<span class="built_in">this</span>.age) &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lilei = <span class="keyword">new</span> Student(<span class="string">&#x27;lilei&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;Software Engineer&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> hmm = <span class="keyword">new</span> Student(<span class="string">&#x27;hmm&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;Doctor&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这个例子中lilei、hmm都是构造函数Student的实例</p>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>JavaScript中,每定义一个对象,对象中都会包含一些预定义的属性,每个普通对象和函数对象都包含<code>__proto__</code> ，而每个函数对象都会有<code>prototype</code> 属性，指向函数的原型对象;</p>
<p>看一个简单示意图:</p>
<img src="https://haohome.top/18-3-11/88286547.jpg" width="70%">

<p>例子中,<code>Student</code> 是构造函数(昵称”妈”),其<code>prototype</code>(原型对象)就是<code>Student.prototype</code> (昵称”爹”)，原型对象(爹)的构造函数属性(妈)是构造函数，而lilei和hmm都是构造函数Student(妈)的实例(儿子/女儿)，儿子/女儿都继承(<code>__proto__</code>)了爹，遗传了爹的方法和属性，用公式表示即：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Student===Student.prototype.constructor;	<span class="comment">//true</span></span><br><span class="line">lilei.__proto__===Student.prototype;			<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数具有<code>prototype</code> 属性，指向原型对象</li>
<li>原型对象具有<code>constructor</code> 属性，指向构造函数</li>
<li>实例对象具有<code>__protot__</code> 属性，指向原型对象</li>
</ul>
<blockquote>
<p>从 ECMAScript 6 开始，<code>[[Prototype]]</code> 可以通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"><code>Object.getPrototypeOf()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a>访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 <code>__proto__</code>。</p>
</blockquote>
<p>原型对象其实就是普通对象，但Function.prototype除外，它是函数对象，且没有prototype属性(前面说函数对象具有prototype属性)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> <span class="built_in">console</span>.log(Student.prototype) <span class="comment">//Student&#123;&#125; 空对象,具有constructor属性</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> Student.prototype) <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// function，这个特殊</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype) <span class="comment">// object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.prototype) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="原型对象的应用"><a href="#原型对象的应用" class="headerlink" title="原型对象的应用"></a>原型对象的应用</h2><p>原型对象的应用主要就是继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name; <span class="comment">// tip: 当函数执行时这个 this 指该构造函数的实例</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">/*给Student添加getName方法*/</span></span><br><span class="line">  Student.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;  <span class="comment">// tip: 当函数执行时这个 this 指该构造函数的实例</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> lilei = <span class="keyword">new</span> Student(<span class="string">&#x27;lilei&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(lilei.name); <span class="comment">//&#x27;lilei&#x27; 此时 lilei 已经有 name 这个属性了</span></span><br><span class="line">  <span class="built_in">console</span>.log(lilei.getName()); <span class="comment">//lilei </span></span><br></pre></td></tr></table></figure>

<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><img src="https://haohome.top/18-3-11/41073082.jpg" width="90%">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lilei.__proto__ 是Student.prototype</span><br><span class="line">Student.__proto__ 是<span class="built_in">Function</span>.prototype</span><br><span class="line">Student.prototype.__proto__ 是<span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="built_in">Object</span>.__proto__ 是<span class="built_in">Function</span>.prototype,<span class="built_in">Object</span>也是构造函数</span><br><span class="line"><span class="built_in">Object</span>.prototype__proto__ 是<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>所有的函数对象的<code>__proto__</code> 都指向<code>Function.prototype</code> ,它是一个空函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.constructor == <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">RegExp</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Error</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.__proto__ === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的<code>__proto__</code> 是Object.prototype。如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Math</span>.construrctor == <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.construrctor == <span class="built_in">Object</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>本文借鉴了</p>
<p>Yi罐可乐: <a href="https://www.jianshu.com/p/dee9f8b14771">最详尽的 JS 原型与原型链终极详解，没有「可能是」</a></p>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包与模块</title>
    <url>/2018/03/01/IT%E6%8A%80%E6%9C%AF/%E9%97%AD%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>闭包是有重用机制，同时保护变量不被污染的一种机制</p>
<table>
<thead>
<tr>
<th align="center">变量类型</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">全局变量</td>
<td align="center">可重用</td>
<td align="center">污染/随处可用</td>
</tr>
<tr>
<td align="center">局部变量</td>
<td align="center">仅作用域内部可用,不会污染不可重用全局</td>
<td align="center">不可重用</td>
</tr>
</tbody></table>
<blockquote>
<p>闭包在需要重用一个变量，又需要保护变量不被污染的情况时使用</p>
<p><strong>即使函数已经完成了运行，它依然可以“记住”并持续访问函数的作用域。</strong></p>
</blockquote>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;		<span class="comment">// 参数x是一个内部变量</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">y</span>) </span>&#123;	<span class="comment">// 内部函数add()使用x，所以它对x拥有一个“闭包”</span></span><br><span class="line">		<span class="keyword">return</span> y + x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用<code>makeAdder(...)</code> 所对应的<code>add(...)</code> 函数引用都会记住被传入<code>makeAdder()</code> 的参数<code>X</code> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = makeAdder( <span class="number">1</span> ); <span class="comment">//plusOne得到一个指向内部函数add(..)的引用,add()函数拥有对外部makeAdder(..)的参数x的闭包,相当于add()中x=2</span></span><br><span class="line"><span class="keyword">var</span> plusTen = makeAdder( <span class="number">10</span> );	<span class="comment">//相当于add()中x=10</span></span><br><span class="line">plusOne( <span class="number">3</span> );		<span class="comment">//调用add()方法,y=3,返回值为4</span></span><br><span class="line">plusOne( <span class="number">41</span> );	<span class="comment">//调用add()方法,y=41,返回值为42</span></span><br><span class="line">plusTen( <span class="number">13</span> );	<span class="comment">//x=10,调用add()方法,y=13,返回值为23</span></span><br></pre></td></tr></table></figure>

<p> 这段代码的工作机制:</p>
<blockquote>
<ul>
<li>当调用makeAdder(1)时,会得到返回的内部函数add(),该函数引用了<strong>参数x</strong>为1并记住了1;</li>
<li>将调用返回的函数引用为plusOne;</li>
<li>当调用plusOne(3)时,它会在传入参数y为3的基础上加上记住的x为1，结果为4；</li>
</ul>
</blockquote>
<p>实现闭包的三个步骤：</p>
<ol>
<li>用外层函数包裹要保护的变量和操作变量的函数</li>
<li>外层函数将内层函数的对象返回到外部</li>
<li>使用者调用外层函数,获得内层函数对象</li>
</ol>
<p><strong>闭包形成原因：外层函数的作用域对象(AO)无法释放,被内层函数对象引用着</strong></p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是闭包中最常见的用法，模块让你定义对外面世界不可见的私有实现细节（变量，函数），和暴露给外面可访问的公有API。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> username, password;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doLogin</span>(<span class="params">user,pw</span>) </span>&#123;		<span class="comment">//登录的方法</span></span><br><span class="line">		username = user;</span><br><span class="line">		password = pw;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> publicAPI = &#123;			<span class="comment">//需要暴露给外面的API</span></span><br><span class="line">		login: doLogin</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> publicAPI;			<span class="comment">//将API暴露出来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fred = User();		<span class="comment">// 创建一个 `User` 模块的实例</span></span><br><span class="line">fred.login( <span class="string">&quot;fred&quot;</span>, <span class="string">&quot;12Battery34!&quot;</span> );</span><br></pre></td></tr></table></figure>

<p>工作机制:</p>
<blockquote>
<ul>
<li>接口 <code>publicAPI</code>是一个带有一个属性/方法的对象，<code>login</code>是一个指向内部<code>doLogin()</code>函数的引用</li>
<li>方法<code>User()</code> 内部包含两个局部作用域变量username和password，私有的doLogin()方法接受从API传入的两个参数值,并赋值给相应的username和password</li>
<li>执行<code>User()</code>创建了<code>User</code>模块的一个 <em>实例</em> —— 一个全新的作用域会被创建，而每个内部变量/函数因此被创建新的副本。将这个实例赋值给<code>fred</code> 如果再次运行<code>User()</code> ，将会得到一个与fred完全分离的新实例；</li>
<li>当<code>User()</code> 函数执行完，<code>username</code> 和<code>password</code> 这样的内部变量不会消失，因为<code>login()</code> 函数里有一个闭包保护变量</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>一年四季的时令蔬菜水果表</title>
    <url>/2016/06/08/%E9%A3%9F%E5%93%81%E7%A7%91%E5%AD%A6/%E4%B8%80%E5%B9%B4%E5%9B%9B%E5%AD%A3%E7%9A%84%E6%97%B6%E4%BB%A4%E8%94%AC%E8%8F%9C%E6%B0%B4%E6%9E%9C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="春季（农历一-三月）"><a href="#春季（农历一-三月）" class="headerlink" title="春季（农历一~三月）"></a>春季（农历一~三月）</h2><p>蔬菜：辣椒、青椒、彩椒、洋葱、花椰菜、甜豆、豌豆、芹菜、<br>莴苣、荠菜、油菜、菠菜、香椿、春笋、马兰头、瓠瓜、韭菜、<br>春韭、菜心、茼蒿、豆苗、蒜苗、春笋等<br>水果：番石榴、青枣、枇杷、桑葚、樱桃、莲雾（春末）。 <a id="more"></a></p>
<h2 id="夏季（农历四-六月）"><a href="#夏季（农历四-六月）" class="headerlink" title="夏季（农历四~六月）"></a>夏季（农历四~六月）</h2><p>蔬菜：辣椒、丝瓜、苦瓜、冬瓜、菜豆、芦笋、茭白、洋葱、黄瓜、佛手瓜、<br>南瓜、苋菜、山苏、空心菜、龙须菜、地瓜叶、竹笋、生菜、西红柿、卷心菜、<br>茄子、豇豆、黄瓜、西红柿、东瓜、四季豆、蚕豆等<br>水果：草莓、莲雾、桃、李、西瓜、菠萝、芒果、柠檬、百香果、<br>火龙果、杏、荔枝、猕猴桃、香蕉、椰子、樱桃。 </p>
<h2 id="秋季（农历七-九月）"><a href="#秋季（农历七-九月）" class="headerlink" title="秋季（农历七~九月）"></a>秋季（农历七~九月）</h2><p>蔬菜：秋葵、菱角、莲藕、辣椒、栗子、冬瓜、四季豆（芸豆）、<br>地瓜叶、豆角、山药、白菜、扁豆。 菜花、胡萝卜、藕、大葱、<br>豆角、黄瓜、西红柿、藕、茄子、百合<br>水果：柚子、梨、柿子、木瓜、苹果、莲子、甘蔗、葡萄、火龙果、<br>杨桃、番石榴、杏、橘子、红枣、山楂、核桃。 </p>
<h2 id="冬季（农历十-十二月）"><a href="#冬季（农历十-十二月）" class="headerlink" title="冬季（农历十~十二月）"></a>冬季（农历十~十二月）</h2><p>蔬菜：青椒、卷心菜、白菜、洋葱、花椰菜、胡萝卜、萝卜、<br>甜豆、芹菜、菠菜、芥菜、葵年菜、莴苣、花椰菜、大白菜、<br>油菜、油麦菜、菜心、芥菜、菠菜、黄芽白、芥蓝、荸荠、藕等<br>水果：橙、橘子、柚子、青枣、甘蔗、释迦。</p>
<h2 id="按月份排的时令蔬菜水果"><a href="#按月份排的时令蔬菜水果" class="headerlink" title="按月份排的时令蔬菜水果"></a>按月份排的时令蔬菜水果</h2><ul>
<li>1月：青菜、卷心菜、菠菜、芹菜、萝卜、慈菇等</li>
<li>2月：青菜、卷心菜、菠菜、芹菜、菜尖等</li>
<li>3月：青菜、菠菜、芹菜、菜尖、花菜等</li>
<li>4月：青菜、莴笋、鸡毛菜、芹菜</li>
<li>5月：青菜、卷心菜、莴笋、鸡毛菜、黄瓜、蚕豆、茭白、番茄等</li>
<li>6月：卷心菜、黄瓜、番茄、土豆、鸡毛菜、刀豆（菜豆）、茄子、南瓜等</li>
<li>7月：豇豆、茄子、鸡毛菜、卷心菜、冬瓜、丝瓜、毛豆、辣椒、土豆、扁豆、卷心菜、空心菜等</li>
<li>8月：冬瓜、豇豆、茄子、青菜、鸡毛菜、南瓜、丝瓜、毛豆、辣椒、土豆、扁豆、卷心菜、空心菜等</li>
<li>9月：青菜、冬瓜、萝卜、丝瓜、毛豆、豇豆、茄子、辣椒、芋艿、茭白、卷心菜、扁豆等</li>
<li>10月：青菜、卷心菜、菠菜、芹菜、萝卜、芋艿、茭白、花菜、茼蒿、生菜、花瓜等</li>
<li>11月：青菜、卷心菜、菠菜、芹菜、萝卜、莴笋、花菜、荠菜、草头、生菜、慈菇、青蒜等</li>
<li>12月：青菜、卷心菜、博菜、芹菜、萝卜、塌菜、荠菜、慈菇、花菜等</li>
</ul>
<h2 id="要吃就吃当季水果各种水果成熟时间汇总"><a href="#要吃就吃当季水果各种水果成熟时间汇总" class="headerlink" title="要吃就吃当季水果各种水果成熟时间汇总"></a>要吃就吃当季水果各种水果成熟时间汇总</h2><ul>
<li>1月(冬季)</li>
</ul>
<p>木瓜 红香蕉 樱桃番茄 杨桃 柑橘橙 青枣 甘果蔗 草莓 番石榴 牛奶蕉 柑桔 观赏南瓜 无花果 鹤首瓜</p>
<ul>
<li>2月(冬季)</li>
</ul>
<p>木瓜 红香蕉 樱桃番茄杨桃 番荔枝 青枣 甘果蔗 草莓 番石榴 牛奶蕉 柑桔 观赏南瓜 鹤首瓜</p>
<ul>
<li>3月(春季)</li>
</ul>
<p>枇杷 红香蕉 樱桃番茄杨桃 番荔枝 青枣 甘果蔗 草莓 番石榴 牛奶蕉 柑桔 观赏南瓜 果桑 鹤首瓜 蛇瓜</p>
<ul>
<li>4月(春季)</li>
</ul>
<p>枇杷 红香蕉 樱桃番茄荔枝 番荔枝 蛇瓜 甘果蔗 果桑 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 澳州坚果 柠檬</p>
<ul>
<li>5月(春季)</li>
</ul>
<p>芒果 红香蕉 樱桃番茄荔枝 番荔枝 蛇瓜 黄皮 果桑 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 李 西瓜 桃 香瓜 柠檬 台湾莲雾 澳州坚果油梨</p>
<ul>
<li>6月(夏季)</li>
</ul>
<p>芒果 红香蕉 樱桃番茄荔枝 番荔枝 蒲瓜 黄皮 果桑 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 李 西瓜 桃 香瓜 柠檬 台湾莲雾 澳州坚果菠萝 火龙果油梨</p>
<ul>
<li>7月(夏季)</li>
</ul>
<p>芒果 红香蕉 樱桃番茄荔枝 番荔枝 蒲瓜 黄皮 番龙眼 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 李 西瓜 桃 香瓜 柠檬 台湾莲雾 澳州坚果菠萝 火龙果 油梨龙眼 百香果 菠萝蜜</p>
<ul>
<li>8月(夏季)</li>
</ul>
<p>芒果 红香蕉 樱桃番茄木瓜 番荔枝 蒲瓜 杨桃 番龙眼 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 日本甜柿 西瓜 黑提子 香瓜 柠檬 菠萝蜜澳州坚果 菠萝 火龙果油梨 龙眼 百香果</p>
<ul>
<li>9月(秋季)</li>
</ul>
<p>芒果 红香蕉 鸡蛋果木瓜 番荔枝 百香果 杨桃 番龙眼 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 日本甜柿 西瓜 黑提子 香瓜 柠檬 菠萝蜜油梨 菠萝火龙果</p>
<ul>
<li>10月(秋季)</li>
</ul>
<p>樱桃番茄 红香蕉 鸡蛋果木瓜 台湾甜玉米 百香果 杨桃 无花果 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 火龙果 西瓜 黑提子 人心果 柠檬菠萝 油梨</p>
<ul>
<li>11月(秋季)</li>
</ul>
<p>樱桃番茄 红香蕉 鸡蛋果木瓜 台湾甜玉米 百香果 杨桃 无花果 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 火龙果 台湾青枣 黑提子 人心果柠檬 菠萝油梨</p>
<ul>
<li>12月(冬季)</li>
</ul>
<p>樱桃番茄 红香蕉 鸡蛋果木瓜 草莓 百香果 杨桃 无花果 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 果蔗 台湾青枣 黑提子 人心果 柠檬 菠萝油梨柑橘橙</p>
<h2 id="按季节分的时令蔬果："><a href="#按季节分的时令蔬果：" class="headerlink" title="按季节分的时令蔬果："></a>按季节分的时令蔬果：</h2><ul>
<li>春季（农历一~三月）</li>
</ul>
<p>蔬菜：辣椒、青椒、彩椒、洋葱、花椰菜、甜豆、豌豆、芹菜、莴苣、荠菜、油菜、菠菜、香椿、春笋、马兰头、瓠瓜。<br>水果：番石榴、青枣、枇杷、桑葚、樱桃、莲雾（春末）。</p>
<ul>
<li>夏季（农历四~六月）</li>
</ul>
<p>蔬菜：辣椒、丝瓜、苦瓜、冬瓜、菜豆、芦笋、茭白、洋葱、黄瓜、佛手瓜、南瓜、苋菜、山苏、空心菜、龙须菜、地瓜叶、竹笋、生菜、西红柿、卷心菜、茄子。<br>水果：草莓、莲雾、桃、李、西瓜、菠萝、芒果、柠檬、百香果、火龙果、杏、荔枝、猕猴桃、香蕉、椰子、樱桃。</p>
<ul>
<li>秋季（农历七~九月）</li>
</ul>
<p>蔬菜：秋葵、菱角、莲藕、辣椒、栗子、冬瓜、四季豆（芸豆）、地瓜叶、豆角、山药、白菜、扁豆。<br>水果：柚子、梨、柿子、木瓜、苹果、莲子、甘蔗、葡萄、火龙果、杨桃、番石榴、杏、橘子、红枣、山楂、核桃。</p>
<ul>
<li>冬季（农历十~十二月）</li>
</ul>
<p>蔬菜：青椒、卷心菜、白菜、洋葱、花椰菜、胡萝卜、萝卜、甜豆、芹菜、菠菜、芥菜、葵年菜、莴苣。<br>水果：橙、橘子、柚子、青枣、甘蔗、释迦。</p>
<hr>
<p>吃当季当地的蔬果,自然成熟的蔬果。<br>吃水果要分清寒热,根据自己的体质选择。</p>
<h2 id="常见水果的性质："><a href="#常见水果的性质：" class="headerlink" title="常见水果的性质："></a>常见水果的性质：</h2><ul>
<li>温性水果：山楂、樱桃、石榴、荔枝、青果、木瓜、白果等</li>
<li>凉性水果：西瓜、甜瓜、梨、柑、桔、香蕉、桑椹、柿子、荸荠等。</li>
<li>中性水果：葡萄、苹果、桃、杏、菠萝、龙眼、甘蔗、乌梅等。<br>食物的温寒性</li>
</ul>
<hr>
<ul>
<li>属于寒性的食物有</li>
</ul>
<p>苦瓜、番茄、茭白、荸荠、菱肉、百合、藕、竹笋、慈姑、魔芋、空心菜、蒲公英、败酱草、鱼腥草、马齿苋、蕨菜、苦菜、荠菜、香椿、莼菜、黑鱼、鲤鱼、河蟹、泥螺、文蛤、蛏子、海蜇、海带、紫菜、田螺、河蚌、蛤蜊、牛奶、豆豉、桑葚、甘蔗、梨、西瓜、柿子、香蕉等。</p>
<ul>
<li>温热性食物有：</li>
</ul>
<p>适用于风寒感冒、发热、恶寒、流涕、头痛等症象的生姜、葱白、香菜；适用于腹痛、呕吐、喜热饮等症象的干姜、红茶；适用于肢冷、畏寒、风湿性关节痛等症象的辣椒、酒等。</p>
<ul>
<li>平性食物有：</li>
</ul>
<p>大米、黄豆、黑芝麻、花生、土豆、白菜、圆白菜、胡萝卜、洋葱、黑木耳、柠檬猪肉、主题、鸡蛋，鱼肉中的鲤鱼、鲫鱼、泥鳅、黄鱼、鲳鱼。另外我们日常里饮用的牛奶也属于平性食物。</p>
<ul>
<li>凉性食物有：</li>
</ul>
<p>荞麦、玉米、白萝卜、冬瓜、蘑菇、芹菜、莴笋、油菜、橙子、苹果等等。</p>
<ul>
<li>寒性食物有：</li>
</ul>
<p>小米、绿豆、海带、绿豆芽、苦瓜、西红柿、黄瓜、香蕉、西瓜、甜瓜等等。<br>食物的性是指“四性”，即寒、热、温、凉四种食性。凉性和寒性，温性和热性，在作用上有一定同性。只是在作用大小方面稍有差别。此外，有些食物其食性平和，称为平性。能减轻或消除热证的食物，属寒凉性；能减轻和消除寒证的食物属温热性。一般认为，寒凉性食物大都具有清热、泻火、解毒作用，常用于热性病证。温热性食物大多具有温中、助阳、散寒等作用，常用于寒性病证。平性食物则有健脾、开胃、补益身体的作用。</p>
<ul>
<li>01.樱桃成熟期在5月中旬到6月中旬；</li>
<li>02.露地草莓在5月中下旬开始采摘，草莓的酸甜味道才浓厚；</li>
<li>03.杏成熟期在5月下旬至7月中旬；</li>
<li>04.桃从6月中旬到10月初都有成熟的；</li>
<li>05.李子早熟品种6月上旬就开始上市，最好吃的品种应在8、9月间成熟;</li>
<li>06.枣品种的成熟期在9月中下旬到10月上旬，大枣才有枣味，在此之前上市的枣又柴又木，根本没法吃；</li>
<li>07.有些苹果品种入伏后就成熟，即“伏苹果”，中晚期成熟的苹果，如“红星”9月底才熟，“富士”系列到10月份才能上市；</li>
<li>08.梨的早熟品种8月上旬成熟，如“绿宝石”，但价钱较贵，大多数梨在9月底或10月初上市；</li>
<li>09.柿子一般在霜降节气，也就是10月下旬才开始上市；</li>
<li>10.桔子分早熟的和晚熟的,一般来说早熟的在8月就可以了,晚熟的话可以晚到11月,不过这也不是绝对的,要看你是在哪个地域,还有就是当年的气候：</li>
<li>11.芒果开花至果实成熟时间因气候和品种而异，一般约需110～150天，6～9月间可陆续采收：</li>
<li>12.柚严格来讲，柚子成熟于深秋和初冬交接的时间，</li>
<li>13.一般的柚品种的成熟期大多集中在11-12月份，但矮晚柚的成熟期在第二年重-2月，正值春节期间；</li>
<li>14.红毛丹每年2月至4月开花，6月至8月为果实成熟采摘季节；</li>
<li>15.菠萝蜜又称木菠萝、树菠萝，海南特产的一种热带桑科常绿乔木。果实6~7月成熟，果实巨大，最重达40公斤，被称为水果之王、热带水果皇后，果实硕大，重者有20至25千克。</li>
<li>16.香蕉-按其种植时期，大致有三种蕉：春种蕉，每年在”雨水”前后的2至3月份种植，8至9月份抽蕾，11至12月份成熟。秋植蕉，一般于秋分前后的9至10月间种植，次年7月份抽蕾，10月中至11月初成熟。还有夏植蕉，于6至8月份种植，次年7月初抽蕾，9月底至10月份采果。以上是正常情况，若遇异常情况，尤其是遇寒害低温，则会延期成熟；</li>
<li>17.桃——桃从6月中旬到10月初都有成熟的；</li>
<li>18.榴莲成熟时间在7·8月，榴莲从树上摘下来后，十天就可成熟；</li>
<li>19.核桃：每年的九月份开始是山核桃的收获季节；</li>
<li>20.柠檬胡成熟季节在冬季；</li>
<li>21.杨梅的成熟期在5-6月份，南方5-6月份又是多雨季节，所以称为梅雨；</li>
<li>22.珍珠番石榴种后6——8个月即可开花结果，第二年即可四季开花结果，开花期集中于4——5月和8——10月，成熟期集中于7——9月和12——1月；</li>
<li>23.菠萝：一般热带一年可两次收获菠萝,有冬春菠萝和夏季菠萝之分,冬春菠萝在4、5月份成熟,夏季菠萝在7月份左右才可收收获；</li>
<li>24.龙眼就是桂圆..桂圆是龙眼干，9月至10月上旬成熟.</li>
<li>25.水蜜桃:依成熟期早晚分为极早熟、早熟、中熟、晚熟、极晚熟5类。果实发育期（即开花盛期至果实成熟所需天数）在80天以内的为极早熟，80～85天的为早熟，100～120天的为中熟，120～150天的为晚熟，150天以上的为极晚熟。</li>
</ul>
<blockquote>
<p>特早熟水蜜桃（5月底、6月上旬成熟）    五月鲜：6月下旬成熟，尖顶圆形，缝合线深而明显，色鲜红，肉脆，汁少，味酸甜。</p>
<p>大久保：7月下旬成熟，果大近圆形，底色黄绿，果顶有红晕，柔软多汁，芳香离核，味甜微酸，品质上等。</p>
<p>白凤：8月上旬成熟，近圆形，果面有鲜红色条纹，皮薄易剥，果肉白中透绿，多汁粘核，味甘甜，品质上等。</p>
<p>巨红水蜜桃：7月上旬成熟，大久保芽变选育而成，单果重200克，含糖量高，有清淡桃香，离皮、离核，品质上等。<br>魁桃：又称红蜜，7月重旬成熟，色淡黄托着鲜红，皮薄肉细，汁多而稠，甘甜如蜜，品质上等</p>
</blockquote>
<ul>
<li>26.番荔枝又称佛头果一年可开花3次，开花至采收需时60~70天，以6月上旬结果最多，5月下旬所结的果最优；</li>
<li>27.荔枝成熟季节在5月初至6月底；</li>
</ul>
<blockquote>
<p>葡萄的正常成熟期是在七八月份，冬天也能吃上葡萄，．．研制了一年两熟的葡萄栽培技术，并开始大面积栽种，预计每次产量可达6万吨；</p>
</blockquote>
<ul>
<li>28.枇杷秋冬开花，春末夏初果实成熟；</li>
<li>29.木瓜一般几时都有；</li>
<li>30.椰子树一年四季都开花，但椰子只在每年最热的时候成熟，椰子的特殊性情使得它对高温特别依恋，所以在热带…；</li>
<li>31.火龙果高产，同时产果期长达6个月，分12至15批成熟火龙果从开花到果实成熟，约35天，当果实由绿色逐渐变红色，果实微香、鲜艳时，就可采收</li>
<li>32.无花果成熟季节在9－10月；</li>
<li>33.芭蕉每年2月至4月开花，6月至8月为果实成熟采摘季节；</li>
<li>34.人心果每年2月至4月开花，6月至8月为果实成熟采摘季节；</li>
<li>35.薄桃在年均温度在20度以上可开花，结果，一般盛花期3－4月，夏、秋季也有零星的花朵开放。果实于5-7月成熟。</li>
</ul>
]]></content>
      <categories>
        <category>food</category>
      </categories>
      <tags>
        <tag>蔬菜</tag>
        <tag>水果</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈餐饮的标准化</title>
    <url>/2016/05/12/%E9%A3%9F%E5%93%81%E7%A7%91%E5%AD%A6/%E6%B5%85%E8%B0%88%E9%A4%90%E9%A5%AE%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96/</url>
    <content><![CDATA[<img src="/images/西红柿炒鸡蛋.jpg" width=50%>
<p>对于餐饮，我其实第一感觉就是不喜欢，因为不规范。</p>
<p>餐饮从业者大部分都是厨师，他们有丰富的厨艺和从业经验，可以说他们炒一个菜是分分钟的事。但是，并不是每一位厨师都是大师，更多的是一个厨子。</p>  <a id="more"></a>
<p>当前餐饮连锁店都倡导标准化转化，厨师也做起了研发，一道“西红柿炒鸡蛋”可以分解成几种原料形式，分别打包在独立包装，用时拆包混合就行。似乎看起来很简单，但实际做的时候没有那么简单。做一锅一人份的和一锅100人份的西红柿炒鸡蛋的配方和工艺完全不一样，加工的时间、加热的温度、所需要的原辅料添加重量、添加的顺序都需要重新计算，不再是适量、少许、火候、爆香等传统厨师用语来衡量，必须由准确的数据来定量每一道工序，普通的厨师做得到吗？</p>  <p>现在的餐饮必然会是厨师+食品专业技术人员结合，由厨师做出一道菜，专业人员负责从食材的选择、工艺记录、产品标准制定等整个过程。不仅仅是这样，专业人员还需要研究这道菜在做出来后的风味变化，采用什么的工艺、包装以及储存条件才能让菜品风味保存更久，口感达到最佳的一个状态。这个就需要科学的理论支持。</p>
  <p>现在我们总是自以为是，以为自己什么都会，厨师可以去研究专业理论，食品专业的人可以去做菜。**真正的资源最大化利用是取长补短，由食品专业的人科普食品加工知识，厨师传授做菜的经验。**</p>
  >一道“西红柿炒鸡蛋”可以有几十种口味，但一份工艺只会产出一种口味或者说几种相近的口味，这就是标准化的能力。

<p>现在的研发厨师不一定会编制这样的工艺，但都懂这样的标准化工艺带来的好处。但进一步的说,如何将这样标准化的菜品提升，可能才是餐饮标准化的核心技术。</p>
<p>菜品进一步分解：</p>
> * 选择不同的食材、采用不同的工艺技术，做出不同等级的菜品；
> * 利用食品添加剂，改善菜品最终的成色和口感；
> * 通过杀菌技术和包装技术，最大程度的延长货架期和保留风味；
> * 总结菜品的加工规律，利用数据分析菜品加工变化，优化菜品加工工艺；

<p>知识是为人服务的并指引正确方向的，资源也是要共享的，餐饮的标准化一定是厨师传授专业人员做菜过程，专业人员用科学的方法指引厨师做菜提升菜品品质。



]]></content>
      <categories>
        <category>food</category>
      </categories>
      <tags>
        <tag>工作感想</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果为什么会褐变</title>
    <url>/2016/04/19/%E9%A3%9F%E5%93%81%E7%A7%91%E5%AD%A6/%E8%8B%B9%E6%9E%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%A4%90%E5%8F%98/</url>
    <content><![CDATA[<p><img src="https://haohome.top/Apple-whole-fresh-and-brown.jpg" alt="image"><br>    当切开的苹果不及时吃掉，它就会由白色苹果慢慢变成暗淡的棕褐色苹果，影响你的食欲。最好的消息是它依然是安全的苹果，你可以吃掉它。导致苹果变色的原因是酶促褐变，当植物组织内存在的酶与多酚类物质结合在氧气的环境下产生的分子反应，产生的黑色素。 <a id="more"></a></p>
<p>不仅苹果有这种现象，其他水果如梨、香蕉、鳄梨、茄子和土豆都存在酶促褐变，因为他们都存在酶的底物————酚类化合物。<br><img src="https://haohome.top/Banana-whole-fresh-and-brown.jpg" alt="image"></p>
<blockquote>
<p>切块的苹果让细胞组织破碎，原本分开的酚类物质和酶相结合，同时当你切开苹果时，酚类物质与酶的混合物就会暴露在空气中，就会产生氧化褐变过程。这个过程持续时间越长，褐变程度越深，直到酚类物质消耗完，这时苹果也就变成棕色的了。</p>
</blockquote>
<p><img src="https://haohome.top/Avocado-whole-diced-fresh-brown.jpg" alt="image"><br>酶只是普通的蛋白质，但是它在自然界中有特殊的功能。大多数化学反应需要较高的活化能才能进行，而酶可以降低化学反应的活化能促使一些反应发生。酶是一种催化剂，它能加快化学反应速率。本身酶在反应过程中不被消耗，也不影响反应的化学平衡。但它会不断催化化学反应进行。有些反应是不可逆的，如水果切块的酶促褐变反应，</p>
<p>但酶在食品中也有重要的积极作用，举个例子：凝乳酶可以促使液态来凝结成奶酪，乳糖酶可以分解我们人体内的乳糖（除非你有乳糖不耐症），食品工业中还利用酶含量来判断海鲜的新鲜度、巴氏杀菌奶的安全以及其他积极应用。此外，酶促褐变反应还有利于茶、咖啡和葡萄干形成理想的色泽。<br><img src="https://haohome.top/Potato-whole-fresh-and-brown1.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>food</category>
      </categories>
      <tags>
        <tag>保鲜知识</tag>
      </tags>
  </entry>
  <entry>
    <title>餐饮研发员的基本素质</title>
    <url>/2016/07/12/%E9%A3%9F%E5%93%81%E7%A7%91%E5%AD%A6/%E9%A4%90%E9%A5%AE%E7%A0%94%E5%8F%91%E5%91%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B4%A0%E8%B4%A8/</url>
    <content><![CDATA[<p>餐饮属于快节奏的行业，对研发员的工作是很大的挑战。</p>
<p>现在的餐饮都要做标准化，也要做创新，那么如何去做一位合格的餐饮研发员呢？<a id="more"></a></p>
<p>首先要明确研发的定位，设定一个场景：</p>
<blockquote>
<p>当一家连锁餐饮企业希望由我们作为他们的中央厨房代加工，他们有自己成熟的菜品，包括配方和工艺，但他们缺少工业化生产的工艺和经验，需要我们为他们解决以达到合作。</p>
</blockquote>
<p>这里研发的价值就是：转化客户现有的产品，在保证客户口感的前提下，实现产品和工业化生产，输出工业化生产工艺标准和产品标准。</p>
<p>这里有两种做法：</p>
<ol>
<li>将客户的产品在研发厨房模拟操作，做到口味相近，写出标准化生产的工艺和产品标准，再去生产车间按标准中试，产品达到客户要求则研发过程结束，产品不合格再调整工艺直到符合客户要求；</li>
<li>对客户的产品进行分拆：原料、配方、工艺、包装、成品。分析成品选择合适的原料，结合研发厨房和测试，确定生产加工的工艺和产品和包装，寻求产品在品质和成本之间的平衡点。</li>
</ol>
<p>两类研发都输出产品的工业化工艺标准和产品标准，但却有本质的区别。</p>
<p>第一种是标准化转化工作，只能凭借自身丰富的厨政经验和生产实际经验，不断摸索尝试，达到产品输出的目的。只能针对普通要求的客户进行产品制作，专业性差。</p>
<p>第二种是才是研发工作，运用专业的知识从源头为客户提供解决方案。针对客户的需求选用合适的原料和合适的加工工艺，并且在源头就解决产品在输出过程中可能遇到的问题。可以针对不同层次要求的客户进行产品定制，并在研发中不断积累自身的核心产品和加工技术。</p>
<p>做食品研发不仅要明确方向，更要专一、沉稳！浮躁的心做不好研发工作。</p>
<p>餐饮的研发是食品研发中最考验研发员的工作态度的工作，承接餐饮客户的部分产品是必然，这就决定了工作节奏快，不能给你充足的时间去研究产品，以解决问题为主。而在一些项目开发中，你要深度运用自己的专业知识去挖掘。专业的事让专业的人做，研发要追求完美的产品，过程不一定全程参与，但一定要明白产品做出来的关键点也就是核心技术，这样才能掌握产品和标准，你才是产品的核心！</p>
<p>不论是餐饮客户产品转化还是项目开发，作为一名合格的餐饮研发员，需要明白工作的目的，明确自己的目标，要不断去比较，不断的去总结。  </p>
<p> ** 研发是一门独孤求败的匠心工作，追求极致，如果你心沉浸在这里，一切的辛苦，在看到产品被人赞美的那一刻，都是值得的！** </p>
]]></content>
      <categories>
        <category>food</category>
      </categories>
      <tags>
        <tag>工作感想</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack入门</title>
    <url>/2018/01/28/IT%E6%8A%80%E6%9C%AF/webpack%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>ES6 的模块系统: import 和export</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> custom = &#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************/</span></span><br><span class="line"><span class="keyword">import</span> custom <span class="keyword">from</span> <span class="string">&#x27;.....&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Common.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = fs.readfile;</span><br></pre></td></tr></table></figure>

<p>没有模块加载和打包工具前,需要要么手工合并文件，要么使用一堆<code>&lt;script&gt;</code>标签,带来一些问题</p>
<ul>
<li>必须保证文件加载的顺序没错，包括知道哪些文件依赖另外一些文件，以及不包含不需要的文件。</li>
<li>多个<code>&lt;script&gt;</code>标签意味着对服务器发送多次请求，性能会受影响。</li>
</ul>
<p>模块文件使用很方便,通过npm安装相应插件模块,直接import引入即可</p>
<a id="more"></a>

<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>webpack 是一个现代 JavaScript 应用程序的<strong>静态模块打包器</strong>(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
<p><img src="../img/webpack.jpg"></p>
<p>认识webpack,需了解四个核心概念:</p>
<ul>
<li>入口(entry)</li>
<li>输出(output)</li>
<li>loader</li>
<li>插件(plugins)</li>
</ul>
<h4 id="1-1-入口-entry"><a href="#1-1-入口-entry" class="headerlink" title="1.1 入口(entry )"></a>1.1 <a href="https://doc.webpack-china.org/concepts/entry-points">入口(entry )</a></h4><p>入口起点指示 webpack 应该使用哪个模块，来作为构建其内部<em>依赖图</em>的开始。</p>
<p>每个依赖项随即被处理，最后<strong>输出到称之为 bundles 的文件</strong>中</p>
<blockquote>
<p>可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./index.js&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当工程是多页面应用程序:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    pageOne: <span class="string">&#x27;./src/pageOne/index.js&#x27;</span>,</span><br><span class="line">    pageTwo: <span class="string">&#x27;./src/pageTwo/index.js&#x27;</span>,</span><br><span class="line">    pageThree: <span class="string">&#x27;./src/pageThree/index.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-出口-output"><a href="#1-2-出口-output" class="headerlink" title="1.2 出口(output)"></a>1.2 <a href="https://doc.webpack-china.org/concepts/output">出口(output)</a></h4><p><code>output</code>属性指在哪里输出它所创建的 <em>bundles</em>，包括以下两点：</p>
<ul>
<li><code>filename</code> 用于输出文件的文件名。</li>
<li> <code>path</code>指输出 的绝对路径。</li>
</ul>
<figure class="highlight plain"><figcaption><span>属性告诉 webpack 在**哪里(path)输出它所创建的 bundles**，以及如何命名这些文件。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;JavaScript</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;file.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#39;dist&#39;),</span><br><span class="line">    filename: &#39;[name].bundle.js&#39;,            &#x2F;&#x2F;输出的文件名将为file.bundle.js,在当前文件夹dist目录下</span><br><span class="line">    publicPath: &#39;&#x2F;dist&#x2F;&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plain"><figcaption><span>决定了每个输出 bundle 的名称</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">| 模板          | 描述                             |</span><br><span class="line">| ----------- | ------------------------------ |</span><br><span class="line">| [hash]      | 模块标识符(module identifier)的 hash |</span><br><span class="line">| [chunkhash] | chunk 内容的 hash                 |</span><br><span class="line">| [name]      | 模块名称                           |</span><br><span class="line">| [id]        | 模块标识符(module identifier)       |</span><br><span class="line">| [query]     | 模块的 query，例如，文件名 &#96;?&#96; 后面的字符串    |</span><br><span class="line"></span><br><span class="line">#### 1.3 [loader](https:&#x2F;&#x2F;doc.webpack-china.org&#x2F;concepts&#x2F;loaders)</span><br><span class="line"></span><br><span class="line">*loader* 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效[模块](https:&#x2F;&#x2F;doc.webpack-china.org&#x2F;concepts&#x2F;modules).</span><br><span class="line"></span><br><span class="line">本质: webpack loader 将所有类型的文件，转换为应用程序的依赖图可以直接引用的模块。</span><br><span class="line"></span><br><span class="line">webpack 的配置中 **loader** 有两个属性:</span><br><span class="line"></span><br><span class="line">-  &#96;test&#96; :识别出应该被对应的 loader 进行转换的那些文件;</span><br><span class="line">- &#96;use&#96;:转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）</span><br><span class="line"></span><br><span class="line">当编译时碰到 &#96;require()&#96;&#x2F;&#96;import&#96; 语句中被解析为路径时,打包前将执行loader进行转换</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;JavaScript</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line"> entry: &#39;.&#x2F;path&#x2F;to&#x2F;my&#x2F;entry&#x2F;file.js&#39;,</span><br><span class="line"> output: &#123;</span><br><span class="line">   path: path.resolve(__dirname, &#39;dist&#39;),</span><br><span class="line">   filename: &#39;my-first-webpack.bundle.js&#39;</span><br><span class="line"> &#125;,</span><br><span class="line"> module: &#123;</span><br><span class="line">   rules: [</span><br><span class="line">     &#123; test: &#x2F;\.css$&#x2F;, use: &#39;css-loader&#39; &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="1-4-插件-plugins"><a href="#1-4-插件-plugins" class="headerlink" title="1.4 插件(plugins)"></a>1.4 <a href="https://doc.webpack-china.org/concepts/plugins/">插件(plugins)</a></h4><p>插件的执行范围比较广,包括从打包优化和压缩,一直到重新定义环境中的变量</p>
<ul>
<li>使用步骤：先require（），再添加到plugins数组中</li>
<li>tips：<ul>
<li>①多数插件可以通过选项options自定义</li>
<li>②多次使用同一个插件时，可以通过new 创建实例</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./file.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: <span class="string">&#x27;css-loader&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>&#125;) <span class="comment">//使用html模板</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-配置-Configuration"><a href="#1-5-配置-Configuration" class="headerlink" title="1.5 配置(Configuration)"></a>1.5 配置(Configuration)</h4><p> webpack 的配置文件，是导出一个对象的 JavaScript 文件(module.exports)</p>
<p>webpack 配置是标准的 <code>Node.js CommonJS</code> 模块:</p>
<ul>
<li>通过 <code>require(...)</code> 导入其他文件</li>
<li>通过 <code>require(...)</code> 使用 npm 的工具函数</li>
<li>使用 JavaScript 控制流表达式，例如 <code>?:</code> 操作符</li>
<li>对常用值使用常量或变量</li>
<li>编写并执行函数来生成部分配置</li>
</ul>
<p>导出多个配置对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;./dist-amd.js&#x27;</span>,</span><br><span class="line">    libraryTarget: <span class="string">&#x27;amd&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  entry: <span class="string">&#x27;./app.js&#x27;</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;./dist-commonjs.js&#x27;</span>,</span><br><span class="line">    libraryTarget: <span class="string">&#x27;commonjs&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  entry: <span class="string">&#x27;./app.js&#x27;</span>,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h4 id="1-6-模块-Modules"><a href="#1-6-模块-Modules" class="headerlink" title="1.6 模块(Modules)"></a>1.6 模块(Modules)</h4><p>对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系,如:</p>
<ul>
<li>ES2015 import 语句</li>
<li>CommonJS require() 语句</li>
<li>AMD define 和 require 语句</li>
<li>css/sass/less 文件中的 @import 语句。</li>
<li>样式(url(…))或 HTML 文件(<img src=...>)中的图片链接(image url)</li>
</ul>
<blockquote>
<p>webpack 通过 <em>loader</em> 可以支持各种语言和预处理器编写模块。</p>
</blockquote>
<h4 id="1-7-模块解析-Module-Resolution"><a href="#1-7-模块解析-Module-Resolution" class="headerlink" title="1.7 模块解析(Module Resolution)"></a>1.7 模块解析(Module Resolution)</h4><p>一个模块可以作为另一个模块的依赖模块，然后被后者引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;path/to/module&#x27;</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;path/to/module&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-8-构建目标-Targets"><a href="#1-8-构建目标-Targets" class="headerlink" title="1.8 构建目标(Targets)"></a>1.8 构建目标(Targets)</h4><p>多个 Target:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> serverConfig = &#123;</span><br><span class="line">  target: <span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;lib.node.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> clientConfig = &#123;</span><br><span class="line">  target: <span class="string">&#x27;web&#x27;</span>, <span class="comment">// &lt;=== 默认是 &#x27;web&#x27;，可省略</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;lib.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = [ serverConfig, clientConfig ];</span><br><span class="line"><span class="comment">//将在dist 文件夹下创建 lib.js 和 lib.node.js 文件。</span></span><br></pre></td></tr></table></figure>

<h4 id="1-9-Manifest"><a href="#1-9-Manifest" class="headerlink" title="1.9 Manifest"></a>1.9 Manifest</h4><ul>
<li>runtime:在模块交互时，连接模块所需的加载和解析逻辑</li>
<li>manifest:当编译器(compiler)开始执行、解析和映射应用程序时，保留的所有模块详细要点的数据集合</li>
</ul>
<blockquote>
<p>通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块。</p>
</blockquote>
<h4 id="1-10-模块热替换-Hot-Module-Replacement"><a href="#1-10-模块热替换-Hot-Module-Replacement" class="headerlink" title="1.10 模块热替换(Hot Module Replacement)"></a>1.10 <a href="https://doc.webpack-china.org/concepts/hot-module-replacement/">模块热替换(Hot Module Replacement)</a></h4><p>在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面</p>
<ul>
<li>保留在完全重新加载页面时丢失的应用程序状态。</li>
<li>只更新变更内容，以节省宝贵的开发时间。</li>
<li>调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。</li>
</ul>
<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack</span><br><span class="line">npm install --save-dev webpack@&lt;version&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.<a href="https://doc.webpack-china.org/configuration/">配置</a></h3><p>在webpack.config.js文件中进行配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;   <span class="comment">// string | object | array</span></span><br><span class="line">    app: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    print: <span class="string">&#x27;./src/print.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123; 		<span class="comment">// webpack 如何输出结果的相关选项, 必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span>,<span class="comment">//文件名模板	</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    publicPath: <span class="string">&#x27;/&#x27;</span> 	 <span class="comment">// 输出解析文件的目录，url 相对于 HTML 页面</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">&#x27;inline-source-map&#x27;</span>,<span class="comment">//追踪到错误和警告在源代码中的原始位置</span></span><br><span class="line">  devServer: &#123;  <span class="comment">//提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)</span></span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>),  <span class="comment">//服务器的位置</span></span><br><span class="line">    port: <span class="number">3000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>]),<span class="comment">//每次build都会清理dist文件夹</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;  <span class="comment">//指定模板输出,自动生成新的index,所有的bundle 会自动添加到 html 中</span></span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">      template: <span class="string">&#x27;src/assets/test.html&#x27;</span><span class="comment">//模板文件路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;				<span class="comment">//加载对应资源</span></span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         test: <span class="regexp">/\.(csv|tsv)$/</span>,</span><br><span class="line">         use: [</span><br><span class="line">           <span class="string">&#x27;csv-loader&#x27;</span></span><br><span class="line">         ]</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         test: <span class="regexp">/\.xml$/</span>,</span><br><span class="line">         use: [</span><br><span class="line">           <span class="string">&#x27;xml-loader&#x27;</span></span><br><span class="line">         ]</span><br><span class="line">       &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><ul>
<li>PostCSS</li>
</ul>
<p><a href="https://github.com/postcss/postcss">PostCSS</a>是一个利用JS插件来对CSS进行转换的工具，这些插件非常强大，强大到无所不能。其中，<a href="https://github.com/postcss/autoprefixer">Autoprefixer</a>就是众多PostCSS插件中最流行的一个。</p>
<p>安装方法:</p>
<p><code>npm i --save-dev postcss</code></p>
<p>一般postcss会结合autoprefixer一起使用,autoprefixer是css的后处理器,可为css添加浏览器前缀,使兼容不同浏览器,安装方法:</p>
<p><code>npm install --save-dev autoprefixer</code></p>
<p><strong>配置1:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">		use: ExtractTextPlugin.extract(&#123;<span class="attr">fallback</span>: <span class="string">&quot;style-loader&quot;</span>,<span class="attr">use</span>: <span class="string">&#x27;css-loader!postcss-loader!less-loader&#x27;</span>&#125;)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/*可以处理less或sass*/</span></span><br></pre></td></tr></table></figure>

<p>这种方式需要在项目根目录下添加<code>psotcss-config.js</code>文件,里面添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  plugins: [  </span><br><span class="line">      <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)(&#123;<span class="attr">browsers</span>: [<span class="string">&#x27;last 5 versions&#x27;</span>]&#125;)  </span><br><span class="line">  ]  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>配置2:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">    fallback: <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;<span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>&#125;, </span><br><span class="line">      &#123;<span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">       options: &#123;<span class="attr">plugins</span>: [<span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)(&#123;<span class="attr">browsers</span>: [<span class="string">&#x27;last 5 versions&#x27;</span>]&#125;)</span><br><span class="line">       ]&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;<span class="attr">loader</span>: <span class="string">&#x27;less-loader&#x27;</span>&#125;]</span><br><span class="line">  )&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种配置是将postcss配置依赖直接放在里面了</p>
<ul>
<li>babel</li>
</ul>
<p>安装<code>npm install --save-dev babel-loader babel-core</code></p>
<p>安装: <code>npm install babel-preset-env --save-dev</code></p>
<p>在根目录下新建<code>.babelrc</code> 文件,添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;env&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, </span><br><span class="line">  exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">      loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        options: &#123;							<span class="comment">//</span></span><br><span class="line">          presets: [<span class="string">&quot;env&quot;</span>]			<span class="comment">//如果有.babellrc文件这个配置可省略</span></span><br><span class="line">        &#125;												<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="4-环境构建"><a href="#4-环境构建" class="headerlink" title="4.环境构建"></a>4.环境构建</h3><h4 id="4-1-配置"><a href="#4-1-配置" class="headerlink" title="4.1 配置"></a>4.1 配置</h4><ul>
<li>开发环境(development)：需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server；</li>
<li>生产环境(production)：我们的目标转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间；</li>
</ul>
<blockquote>
<p>由于要遵循逻辑分离，我们通常建议为每个环境编写<strong>彼此独立的 webpack 配置</strong>，但会保留”通用”配置。</p>
</blockquote>
<p>通过工具<code>webpack-merge</code> ,将”通用”配置合并在一起:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-merge</span><br></pre></td></tr></table></figure>

<p><strong>project项目结构</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">webpack-demo</span><br><span class="line">  |- package.json</span><br><span class="line">  |- config</span><br><span class="line">    |- webpack.common.js</span><br><span class="line">    |- webpack.dev.js</span><br><span class="line">    |- webpack.prod.js</span><br><span class="line">  |-src</span><br><span class="line">	|-index.js</span><br><span class="line">  |- index.html</span><br></pre></td></tr></table></figure>

<p><strong>webpack.common.js公共配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: path.resolve(__dirname,<span class="string">&#x27;../src/index.js&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;  <span class="comment">//别名,引入第三方库jQuery之后起的别名</span></span><br><span class="line">      jquery: path.resolve(__dirname,<span class="string">&#x27;../libs/jquery-3.2.1.js&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(<span class="comment">//清理文件夹</span></span><br><span class="line">      [<span class="string">&#x27;*.js&#x27;</span>,<span class="string">&#x27;*.map&#x27;</span>,<span class="string">&#x27;*.png&#x27;</span>,<span class="string">&#x27;*.css&#x27;</span>,<span class="string">&#x27;*.html&#x27;</span>],　 <span class="comment">//匹配删除的文件,若为*则全部删除</span></span><br><span class="line">      &#123;</span><br><span class="line">        root: path.resolve(__dirname,<span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">        verbose:  <span class="literal">true</span>,  <span class="comment">//开启在控制台输出信息</span></span><br><span class="line">      &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;  <span class="comment">//指定模板输出</span></span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">      template: <span class="string">&#x27;./index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;     <span class="comment">//自动生成全局变量,一旦引用,就会打包</span></span><br><span class="line">      $:<span class="string">&quot;jquery&quot;</span>,</span><br><span class="line">      jQuery:<span class="string">&quot;jquery&quot;</span>,</span><br><span class="line">      <span class="string">&#x27;window.jQuery&#x27;</span>:<span class="string">&quot;jquery&quot;</span>,</span><br><span class="line">      <span class="string">&#x27;window.$&#x27;</span>:<span class="string">&quot;jquery&quot;</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, </span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [<span class="string">&quot;env&quot;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,  </span><br><span class="line">  output: &#123;   <span class="comment">//打包输出配置路径</span></span><br><span class="line">    filename: <span class="string">&#x27;[name]-[hash].bundle.js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">    publicPath: <span class="string">&#x27;&#x27;</span> <span class="comment">//上线的绝对地址 可以为http://www.haohome.top/</span></span><br><span class="line">  &#125;,  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>webpack.dev.js 开发配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;  <span class="comment">//与公共配置合并</span></span><br><span class="line">  devtool: <span class="string">&#x27;inline-source-map&#x27;</span>,<span class="comment">//追踪错误和警告</span></span><br><span class="line">  devServer: &#123;  <span class="comment">//提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)</span></span><br><span class="line">    contentBase:path.resolve(__dirname, <span class="string">&quot;../&quot;</span>),  <span class="comment">//服务器的位置</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>webpack.prod.js 生产配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);<span class="comment">//代码压缩工具</span></span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  devtool: <span class="string">&#x27;source-map&#x27;</span>,	<span class="comment">//调试源码(debug)和运行基准测试(benchmark tests)很有用</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyJSPlugin(&#123;</span><br><span class="line">      sourceMap: <span class="literal">true</span>		<span class="comment">//如果配置了devtool则加改选项</span></span><br><span class="line">    &#125;)			</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line">/ 避免在生产中使用 inline-*** 和 <span class="built_in">eval</span>-***，因为它们可以增加 bundle 大小，并降低整体性能。</span><br></pre></td></tr></table></figure>

<p><strong>package.json配置NPM Scripts:</strong> </p>
<p>把 <code>scripts</code> 重新指向到新配置。我们将 <code>npm start</code> 定义为<em>开发环境</em>脚本，并在其中使用 <code>webpack-dev-server</code>，将 <code>npm run build</code> 定义为<em>生产环境</em>脚本:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server --progress --colors --open --config webpack.dev.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --progress --colors --config webpack.prod.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-指定环境"><a href="#4-2-指定环境" class="headerlink" title="4.2 指定环境"></a>4.2 指定环境</h4><p>许多 library 将通过与 <code>process.env.NODE_ENV</code> 环境变量关联，以决定 library 中应该引用哪些内容。当使用 <code>process.env.NODE_ENV === &#39;production&#39;</code> 时，一些 library 可能针对具体用户的环境进行代码优化，从而删除或添加一些重要代码。</p>
<p>可以使用 webpack 内置的 <code>DefinePlugin</code>为所有的依赖定义这个变量</p>
<p><strong>webpack.prod.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+ <span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);<span class="comment">//引入webpack</span></span><br><span class="line">  <span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">    devtool: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> UglifyJSPlugin(&#123;</span><br><span class="line">        sourceMap: <span class="literal">true</span></span><br><span class="line">      &#125;),</span><br><span class="line">+     <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">+       <span class="string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="built_in">JSON</span>.stringify(<span class="string">&#x27;production&#x27;</span>)<span class="comment">//指定为生产环境</span></span><br><span class="line">+     &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
